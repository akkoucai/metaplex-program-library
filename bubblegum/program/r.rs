#![feature(prelude_import)]
#[prelude_import]
use std::prelude::rust_2018::*;
#[macro_use]
extern crate std;
use {
    crate::error::BubblegumError,
    crate::state::metaplex_anchor::MplTokenMetadata,
    crate::state::{
        leaf_schema::{LeafSchema, Version},
        metaplex_adapter::{Creator, MetadataArgs, TokenProgramVersion},
        metaplex_anchor::{MasterEdition, TokenMetadata},
        request::{MintRequest, MINT_REQUEST_SIZE},
        NFTDecompressionEvent, NewNFTEvent, TreeConfig, Voucher, ASSET_PREFIX, TREE_AUTHORITY_SIZE,
        VOUCHER_PREFIX, VOUCHER_SIZE,
    },
    crate::utils::{
        append_leaf, assert_metadata_is_mpl_compatible, assert_pubkey_equal, cmp_bytes,
        cmp_pubkeys, get_asset_id, replace_leaf,
    },
    anchor_lang::{
        prelude::*,
        solana_program::{
            keccak,
            program::{invoke, invoke_signed},
            program_error::ProgramError,
            program_pack::Pack,
            system_instruction,
        },
    },
    gummyroll::{program::Gummyroll, state::CandyWrapper, utils::wrap_event, Node},
    spl_token::state::Mint as SplMint,
    std::collections::HashSet,
};
pub mod error {
    use anchor_lang::prelude::*;
    #[repr(u32)]
    pub enum BubblegumError {
        AssetOwnerMismatch,
        PublicKeyMismatch,
        HashingMismatch,
        UnsupportedSchemaVersion,
        CreatorShareTotalMustBe100,
        DuplicateCreatorAddress,
        CreatorDidNotVerify,
        CreatorNotFound,
        NoCreatorsPresent,
        CreatorsTooLong,
        MetadataNameTooLong,
        MetadataSymbolTooLong,
        MetadataUriTooLong,
        MetadataBasisPointsTooHigh,
        InsufficientMintCapacity,
        MintRequestNotApproved,
        MintRequestKeyMismatch,
        MintRequestDiscriminatorMismatch,
        CloseMintRequestError,
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::fmt::Debug for BubblegumError {
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            match (&*self,) {
                (&BubblegumError::AssetOwnerMismatch,) => {
                    ::core::fmt::Formatter::write_str(f, "AssetOwnerMismatch")
                }
                (&BubblegumError::PublicKeyMismatch,) => {
                    ::core::fmt::Formatter::write_str(f, "PublicKeyMismatch")
                }
                (&BubblegumError::HashingMismatch,) => {
                    ::core::fmt::Formatter::write_str(f, "HashingMismatch")
                }
                (&BubblegumError::UnsupportedSchemaVersion,) => {
                    ::core::fmt::Formatter::write_str(f, "UnsupportedSchemaVersion")
                }
                (&BubblegumError::CreatorShareTotalMustBe100,) => {
                    ::core::fmt::Formatter::write_str(f, "CreatorShareTotalMustBe100")
                }
                (&BubblegumError::DuplicateCreatorAddress,) => {
                    ::core::fmt::Formatter::write_str(f, "DuplicateCreatorAddress")
                }
                (&BubblegumError::CreatorDidNotVerify,) => {
                    ::core::fmt::Formatter::write_str(f, "CreatorDidNotVerify")
                }
                (&BubblegumError::CreatorNotFound,) => {
                    ::core::fmt::Formatter::write_str(f, "CreatorNotFound")
                }
                (&BubblegumError::NoCreatorsPresent,) => {
                    ::core::fmt::Formatter::write_str(f, "NoCreatorsPresent")
                }
                (&BubblegumError::CreatorsTooLong,) => {
                    ::core::fmt::Formatter::write_str(f, "CreatorsTooLong")
                }
                (&BubblegumError::MetadataNameTooLong,) => {
                    ::core::fmt::Formatter::write_str(f, "MetadataNameTooLong")
                }
                (&BubblegumError::MetadataSymbolTooLong,) => {
                    ::core::fmt::Formatter::write_str(f, "MetadataSymbolTooLong")
                }
                (&BubblegumError::MetadataUriTooLong,) => {
                    ::core::fmt::Formatter::write_str(f, "MetadataUriTooLong")
                }
                (&BubblegumError::MetadataBasisPointsTooHigh,) => {
                    ::core::fmt::Formatter::write_str(f, "MetadataBasisPointsTooHigh")
                }
                (&BubblegumError::InsufficientMintCapacity,) => {
                    ::core::fmt::Formatter::write_str(f, "InsufficientMintCapacity")
                }
                (&BubblegumError::MintRequestNotApproved,) => {
                    ::core::fmt::Formatter::write_str(f, "MintRequestNotApproved")
                }
                (&BubblegumError::MintRequestKeyMismatch,) => {
                    ::core::fmt::Formatter::write_str(f, "MintRequestKeyMismatch")
                }
                (&BubblegumError::MintRequestDiscriminatorMismatch,) => {
                    ::core::fmt::Formatter::write_str(f, "MintRequestDiscriminatorMismatch")
                }
                (&BubblegumError::CloseMintRequestError,) => {
                    ::core::fmt::Formatter::write_str(f, "CloseMintRequestError")
                }
            }
        }
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::clone::Clone for BubblegumError {
        #[inline]
        fn clone(&self) -> BubblegumError {
            {
                *self
            }
        }
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::marker::Copy for BubblegumError {}
    impl BubblegumError {
        /// Gets the name of this [#enum_name].
        pub fn name(&self) -> String {
            match self {
                BubblegumError::AssetOwnerMismatch => "AssetOwnerMismatch".to_string(),
                BubblegumError::PublicKeyMismatch => "PublicKeyMismatch".to_string(),
                BubblegumError::HashingMismatch => "HashingMismatch".to_string(),
                BubblegumError::UnsupportedSchemaVersion => "UnsupportedSchemaVersion".to_string(),
                BubblegumError::CreatorShareTotalMustBe100 => {
                    "CreatorShareTotalMustBe100".to_string()
                }
                BubblegumError::DuplicateCreatorAddress => "DuplicateCreatorAddress".to_string(),
                BubblegumError::CreatorDidNotVerify => "CreatorDidNotVerify".to_string(),
                BubblegumError::CreatorNotFound => "CreatorNotFound".to_string(),
                BubblegumError::NoCreatorsPresent => "NoCreatorsPresent".to_string(),
                BubblegumError::CreatorsTooLong => "CreatorsTooLong".to_string(),
                BubblegumError::MetadataNameTooLong => "MetadataNameTooLong".to_string(),
                BubblegumError::MetadataSymbolTooLong => "MetadataSymbolTooLong".to_string(),
                BubblegumError::MetadataUriTooLong => "MetadataUriTooLong".to_string(),
                BubblegumError::MetadataBasisPointsTooHigh => {
                    "MetadataBasisPointsTooHigh".to_string()
                }
                BubblegumError::InsufficientMintCapacity => "InsufficientMintCapacity".to_string(),
                BubblegumError::MintRequestNotApproved => "MintRequestNotApproved".to_string(),
                BubblegumError::MintRequestKeyMismatch => "MintRequestKeyMismatch".to_string(),
                BubblegumError::MintRequestDiscriminatorMismatch => {
                    "MintRequestDiscriminatorMismatch".to_string()
                }
                BubblegumError::CloseMintRequestError => "CloseMintRequestError".to_string(),
            }
        }
    }
    impl From<BubblegumError> for u32 {
        fn from(e: BubblegumError) -> u32 {
            e as u32 + anchor_lang::error::ERROR_CODE_OFFSET
        }
    }
    impl From<BubblegumError> for anchor_lang::error::Error {
        fn from(error_code: BubblegumError) -> anchor_lang::error::Error {
            anchor_lang::error::Error::from(anchor_lang::error::AnchorError {
                error_name: error_code.name(),
                error_code_number: error_code.into(),
                error_msg: error_code.to_string(),
                error_origin: None,
                compared_values: None,
            })
        }
    }
    impl std::fmt::Display for BubblegumError {
        fn fmt(
            &self,
            fmt: &mut std::fmt::Formatter<'_>,
        ) -> std::result::Result<(), std::fmt::Error> {
            match self {
                BubblegumError::AssetOwnerMismatch => {
                    let result = fmt.write_fmt(::core::fmt::Arguments::new_v1(
                        &["Asset Owner Does not match"],
                        &[],
                    ));
                    result
                }
                BubblegumError::PublicKeyMismatch => {
                    let result =
                        fmt.write_fmt(::core::fmt::Arguments::new_v1(&["PublicKeyMismatch"], &[]));
                    result
                }
                BubblegumError::HashingMismatch => {
                    let result = fmt.write_fmt(::core::fmt::Arguments::new_v1(
                        &["Hashing Mismatch Within Leaf Schema"],
                        &[],
                    ));
                    result
                }
                BubblegumError::UnsupportedSchemaVersion => {
                    let result = fmt.write_fmt(::core::fmt::Arguments::new_v1(
                        &["Unsupported Schema Version"],
                        &[],
                    ));
                    result
                }
                BubblegumError::CreatorShareTotalMustBe100 => {
                    let result = fmt.write_fmt(::core::fmt::Arguments::new_v1(
                        &["Creator shares must sum to 100"],
                        &[],
                    ));
                    result
                }
                BubblegumError::DuplicateCreatorAddress => {
                    let result = fmt.write_fmt(::core::fmt::Arguments::new_v1(
                        &["No duplicate creator addresses in metadata"],
                        &[],
                    ));
                    result
                }
                BubblegumError::CreatorDidNotVerify => {
                    let result = fmt.write_fmt(::core::fmt::Arguments::new_v1(
                        &["Creator did not verify the metadata"],
                        &[],
                    ));
                    result
                }
                BubblegumError::CreatorNotFound => {
                    let result = fmt.write_fmt(::core::fmt::Arguments::new_v1(
                        &["Creator not found in creator Vec"],
                        &[],
                    ));
                    result
                }
                BubblegumError::NoCreatorsPresent => {
                    let result = fmt.write_fmt(::core::fmt::Arguments::new_v1(
                        &["No creators in creator Vec"],
                        &[],
                    ));
                    result
                }
                BubblegumError::CreatorsTooLong => {
                    let result = fmt.write_fmt(::core::fmt::Arguments::new_v1(
                        &["Creators list too long"],
                        &[],
                    ));
                    result
                }
                BubblegumError::MetadataNameTooLong => {
                    let result = fmt.write_fmt(::core::fmt::Arguments::new_v1(
                        &["Name in metadata is too long"],
                        &[],
                    ));
                    result
                }
                BubblegumError::MetadataSymbolTooLong => {
                    let result = fmt.write_fmt(::core::fmt::Arguments::new_v1(
                        &["Symbol in metadata is too long"],
                        &[],
                    ));
                    result
                }
                BubblegumError::MetadataUriTooLong => {
                    let result = fmt.write_fmt(::core::fmt::Arguments::new_v1(
                        &["Uri in metadata is too long"],
                        &[],
                    ));
                    result
                }
                BubblegumError::MetadataBasisPointsTooHigh => {
                    let result = fmt.write_fmt(::core::fmt::Arguments::new_v1(
                        &["Basis points in metadata cannot exceed 10000"],
                        &[],
                    ));
                    result
                }
                BubblegumError::InsufficientMintCapacity => {
                    let result = fmt.write_fmt(::core::fmt::Arguments::new_v1(
                        &["Not enough unapproved mints left"],
                        &[],
                    ));
                    result
                }
                BubblegumError::MintRequestNotApproved => {
                    let result = fmt.write_fmt(::core::fmt::Arguments::new_v1(
                        &["Mint request not approved"],
                        &[],
                    ));
                    result
                }
                BubblegumError::MintRequestKeyMismatch => {
                    let result = fmt.write_fmt(::core::fmt::Arguments::new_v1(
                        &["Mint authority key does not match request"],
                        &[],
                    ));
                    result
                }
                BubblegumError::MintRequestDiscriminatorMismatch => {
                    let result = fmt.write_fmt(::core::fmt::Arguments::new_v1(
                        &["Mint request data has incorrect disciminator"],
                        &[],
                    ));
                    result
                }
                BubblegumError::CloseMintRequestError => {
                    let result = fmt.write_fmt(::core::fmt::Arguments::new_v1(
                        &["Something went wrong closing mint request"],
                        &[],
                    ));
                    result
                }
            }
        }
    }
}
pub mod state {
    pub mod leaf_schema {
        use anchor_lang::{prelude::*, solana_program::keccak};
        use gummyroll::Node;
        pub struct LeafSchemaEvent {
            pub version: Version,
            pub schema: LeafSchema,
            pub leaf_hash: [u8; 32],
        }
        impl borsh::ser::BorshSerialize for LeafSchemaEvent
        where
            Version: borsh::ser::BorshSerialize,
            LeafSchema: borsh::ser::BorshSerialize,
            [u8; 32]: borsh::ser::BorshSerialize,
        {
            fn serialize<W: borsh::maybestd::io::Write>(
                &self,
                writer: &mut W,
            ) -> ::core::result::Result<(), borsh::maybestd::io::Error> {
                borsh::BorshSerialize::serialize(&self.version, writer)?;
                borsh::BorshSerialize::serialize(&self.schema, writer)?;
                borsh::BorshSerialize::serialize(&self.leaf_hash, writer)?;
                Ok(())
            }
        }
        impl borsh::de::BorshDeserialize for LeafSchemaEvent
        where
            Version: borsh::BorshDeserialize,
            LeafSchema: borsh::BorshDeserialize,
            [u8; 32]: borsh::BorshDeserialize,
        {
            fn deserialize(
                buf: &mut &[u8],
            ) -> ::core::result::Result<Self, borsh::maybestd::io::Error> {
                Ok(Self {
                    version: borsh::BorshDeserialize::deserialize(buf)?,
                    schema: borsh::BorshDeserialize::deserialize(buf)?,
                    leaf_hash: borsh::BorshDeserialize::deserialize(buf)?,
                })
            }
        }
        impl anchor_lang::Event for LeafSchemaEvent {
            fn data(&self) -> Vec<u8> {
                let mut d = [56, 139, 154, 164, 204, 170, 78, 204].to_vec();
                d.append(&mut self.try_to_vec().unwrap());
                d
            }
        }
        impl anchor_lang::Discriminator for LeafSchemaEvent {
            fn discriminator() -> [u8; 8] {
                [56, 139, 154, 164, 204, 170, 78, 204]
            }
        }
        pub enum Version {
            V1,
        }
        impl borsh::de::BorshDeserialize for Version {
            fn deserialize(
                buf: &mut &[u8],
            ) -> core::result::Result<Self, borsh::maybestd::io::Error> {
                let variant_idx: u8 = borsh::BorshDeserialize::deserialize(buf)?;
                let return_value = match variant_idx {
                    0u8 => Version::V1,
                    _ => {
                        let msg = {
                            let res = ::alloc::fmt::format(::core::fmt::Arguments::new_v1(
                                &["Unexpected variant index: "],
                                &[::core::fmt::ArgumentV1::new_debug(&variant_idx)],
                            ));
                            res
                        };
                        return Err(borsh::maybestd::io::Error::new(
                            borsh::maybestd::io::ErrorKind::InvalidInput,
                            msg,
                        ));
                    }
                };
                Ok(return_value)
            }
        }
        impl borsh::ser::BorshSerialize for Version {
            fn serialize<W: borsh::maybestd::io::Write>(
                &self,
                writer: &mut W,
            ) -> core::result::Result<(), borsh::maybestd::io::Error> {
                let variant_idx: u8 = match self {
                    Version::V1 => 0u8,
                };
                writer.write_all(&variant_idx.to_le_bytes())?;
                match self {
                    Version::V1 => {}
                }
                Ok(())
            }
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::core::clone::Clone for Version {
            #[inline]
            fn clone(&self) -> Version {
                {
                    *self
                }
            }
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::core::marker::Copy for Version {}
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::core::fmt::Debug for Version {
            fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                match (&*self,) {
                    (&Version::V1,) => ::core::fmt::Formatter::write_str(f, "V1"),
                }
            }
        }
        impl Default for Version {
            fn default() -> Self {
                Version::V1
            }
        }
        impl Version {
            pub fn to_bytes(&self) -> u8 {
                match self {
                    Version::V1 => 1,
                }
            }
        }
        pub enum LeafSchema {
            V1 {
                id: Pubkey,
                owner: Pubkey,
                delegate: Pubkey,
                nonce: u64,
                data_hash: [u8; 32],
                creator_hash: [u8; 32],
            },
        }
        impl borsh::de::BorshDeserialize for LeafSchema
        where
            Pubkey: borsh::BorshDeserialize,
            Pubkey: borsh::BorshDeserialize,
            Pubkey: borsh::BorshDeserialize,
            u64: borsh::BorshDeserialize,
            [u8; 32]: borsh::BorshDeserialize,
            [u8; 32]: borsh::BorshDeserialize,
        {
            fn deserialize(
                buf: &mut &[u8],
            ) -> core::result::Result<Self, borsh::maybestd::io::Error> {
                let variant_idx: u8 = borsh::BorshDeserialize::deserialize(buf)?;
                let return_value = match variant_idx {
                    0u8 => LeafSchema::V1 {
                        id: borsh::BorshDeserialize::deserialize(buf)?,
                        owner: borsh::BorshDeserialize::deserialize(buf)?,
                        delegate: borsh::BorshDeserialize::deserialize(buf)?,
                        nonce: borsh::BorshDeserialize::deserialize(buf)?,
                        data_hash: borsh::BorshDeserialize::deserialize(buf)?,
                        creator_hash: borsh::BorshDeserialize::deserialize(buf)?,
                    },
                    _ => {
                        let msg = {
                            let res = ::alloc::fmt::format(::core::fmt::Arguments::new_v1(
                                &["Unexpected variant index: "],
                                &[::core::fmt::ArgumentV1::new_debug(&variant_idx)],
                            ));
                            res
                        };
                        return Err(borsh::maybestd::io::Error::new(
                            borsh::maybestd::io::ErrorKind::InvalidInput,
                            msg,
                        ));
                    }
                };
                Ok(return_value)
            }
        }
        impl borsh::ser::BorshSerialize for LeafSchema
        where
            Pubkey: borsh::ser::BorshSerialize,
            Pubkey: borsh::ser::BorshSerialize,
            Pubkey: borsh::ser::BorshSerialize,
            u64: borsh::ser::BorshSerialize,
            [u8; 32]: borsh::ser::BorshSerialize,
            [u8; 32]: borsh::ser::BorshSerialize,
        {
            fn serialize<W: borsh::maybestd::io::Write>(
                &self,
                writer: &mut W,
            ) -> core::result::Result<(), borsh::maybestd::io::Error> {
                let variant_idx: u8 = match self {
                    LeafSchema::V1 { .. } => 0u8,
                };
                writer.write_all(&variant_idx.to_le_bytes())?;
                match self {
                    LeafSchema::V1 {
                        id,
                        owner,
                        delegate,
                        nonce,
                        data_hash,
                        creator_hash,
                    } => {
                        borsh::BorshSerialize::serialize(id, writer)?;
                        borsh::BorshSerialize::serialize(owner, writer)?;
                        borsh::BorshSerialize::serialize(delegate, writer)?;
                        borsh::BorshSerialize::serialize(nonce, writer)?;
                        borsh::BorshSerialize::serialize(data_hash, writer)?;
                        borsh::BorshSerialize::serialize(creator_hash, writer)?;
                    }
                }
                Ok(())
            }
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::core::clone::Clone for LeafSchema {
            #[inline]
            fn clone(&self) -> LeafSchema {
                {
                    let _: ::core::clone::AssertParamIsClone<Pubkey>;
                    let _: ::core::clone::AssertParamIsClone<Pubkey>;
                    let _: ::core::clone::AssertParamIsClone<Pubkey>;
                    let _: ::core::clone::AssertParamIsClone<u64>;
                    let _: ::core::clone::AssertParamIsClone<[u8; 32]>;
                    let _: ::core::clone::AssertParamIsClone<[u8; 32]>;
                    *self
                }
            }
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::core::marker::Copy for LeafSchema {}
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::core::fmt::Debug for LeafSchema {
            fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                match (&*self,) {
                    (&LeafSchema::V1 {
                        id: ref __self_0,
                        owner: ref __self_1,
                        delegate: ref __self_2,
                        nonce: ref __self_3,
                        data_hash: ref __self_4,
                        creator_hash: ref __self_5,
                    },) => {
                        let debug_trait_builder =
                            &mut ::core::fmt::Formatter::debug_struct(f, "V1");
                        let _ = ::core::fmt::DebugStruct::field(
                            debug_trait_builder,
                            "id",
                            &&(*__self_0),
                        );
                        let _ = ::core::fmt::DebugStruct::field(
                            debug_trait_builder,
                            "owner",
                            &&(*__self_1),
                        );
                        let _ = ::core::fmt::DebugStruct::field(
                            debug_trait_builder,
                            "delegate",
                            &&(*__self_2),
                        );
                        let _ = ::core::fmt::DebugStruct::field(
                            debug_trait_builder,
                            "nonce",
                            &&(*__self_3),
                        );
                        let _ = ::core::fmt::DebugStruct::field(
                            debug_trait_builder,
                            "data_hash",
                            &&(*__self_4),
                        );
                        let _ = ::core::fmt::DebugStruct::field(
                            debug_trait_builder,
                            "creator_hash",
                            &&(*__self_5),
                        );
                        ::core::fmt::DebugStruct::finish(debug_trait_builder)
                    }
                }
            }
        }
        impl Default for LeafSchema {
            fn default() -> Self {
                Self::V1 {
                    id: Default::default(),
                    owner: Default::default(),
                    delegate: Default::default(),
                    nonce: 0,
                    data_hash: [0; 32],
                    creator_hash: [0; 32],
                }
            }
        }
        impl LeafSchema {
            pub fn new_v0(
                id: Pubkey,
                owner: Pubkey,
                delegate: Pubkey,
                nonce: u64,
                data_hash: [u8; 32],
                creator_hash: [u8; 32],
            ) -> Self {
                Self::V1 {
                    id,
                    owner,
                    delegate,
                    nonce,
                    data_hash,
                    creator_hash,
                }
            }
            pub fn version(&self) -> Version {
                match self {
                    LeafSchema::V1 { .. } => Version::V1,
                }
            }
            pub fn id(&self) -> Pubkey {
                match self {
                    LeafSchema::V1 { id, .. } => *id,
                }
            }
            pub fn nonce(&self) -> u64 {
                match self {
                    LeafSchema::V1 { nonce, .. } => *nonce,
                }
            }
            pub fn data_hash(&self) -> [u8; 32] {
                match self {
                    LeafSchema::V1 { data_hash, .. } => *data_hash,
                }
            }
            pub fn to_event(&self) -> LeafSchemaEvent {
                LeafSchemaEvent {
                    version: self.version(),
                    schema: *self,
                    leaf_hash: self.to_node(),
                }
            }
            pub fn to_node(&self) -> Node {
                let hashed_leaf = match self {
                    LeafSchema::V1 {
                        id,
                        owner,
                        delegate,
                        nonce,
                        data_hash,
                        creator_hash,
                    } => keccak::hashv(&[
                        &[self.version().to_bytes()],
                        id.as_ref(),
                        owner.as_ref(),
                        delegate.as_ref(),
                        nonce.to_le_bytes().as_ref(),
                        data_hash.as_ref(),
                        creator_hash.as_ref(),
                    ])
                    .to_bytes(),
                };
                hashed_leaf
            }
        }
    }
    pub mod metaplex_adapter {
        use anchor_lang::prelude::*;
        pub enum TokenProgramVersion {
            Original,
            Token2022,
        }
        impl borsh::ser::BorshSerialize for TokenProgramVersion {
            fn serialize<W: borsh::maybestd::io::Write>(
                &self,
                writer: &mut W,
            ) -> core::result::Result<(), borsh::maybestd::io::Error> {
                let variant_idx: u8 = match self {
                    TokenProgramVersion::Original => 0u8,
                    TokenProgramVersion::Token2022 => 1u8,
                };
                writer.write_all(&variant_idx.to_le_bytes())?;
                match self {
                    TokenProgramVersion::Original => {}
                    TokenProgramVersion::Token2022 => {}
                }
                Ok(())
            }
        }
        impl borsh::de::BorshDeserialize for TokenProgramVersion {
            fn deserialize(
                buf: &mut &[u8],
            ) -> core::result::Result<Self, borsh::maybestd::io::Error> {
                let variant_idx: u8 = borsh::BorshDeserialize::deserialize(buf)?;
                let return_value = match variant_idx {
                    0u8 => TokenProgramVersion::Original,
                    1u8 => TokenProgramVersion::Token2022,
                    _ => {
                        let msg = {
                            let res = ::alloc::fmt::format(::core::fmt::Arguments::new_v1(
                                &["Unexpected variant index: "],
                                &[::core::fmt::ArgumentV1::new_debug(&variant_idx)],
                            ));
                            res
                        };
                        return Err(borsh::maybestd::io::Error::new(
                            borsh::maybestd::io::ErrorKind::InvalidInput,
                            msg,
                        ));
                    }
                };
                Ok(return_value)
            }
        }
        impl ::core::marker::StructuralPartialEq for TokenProgramVersion {}
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::core::cmp::PartialEq for TokenProgramVersion {
            #[inline]
            fn eq(&self, other: &TokenProgramVersion) -> bool {
                {
                    let __self_vi = ::core::intrinsics::discriminant_value(&*self);
                    let __arg_1_vi = ::core::intrinsics::discriminant_value(&*other);
                    if true && __self_vi == __arg_1_vi {
                        match (&*self, &*other) {
                            _ => true,
                        }
                    } else {
                        false
                    }
                }
            }
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::core::marker::Copy for TokenProgramVersion {}
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::core::clone::Clone for TokenProgramVersion {
            #[inline]
            fn clone(&self) -> TokenProgramVersion {
                {
                    *self
                }
            }
        }
        pub struct Creator {
            pub address: Pubkey,
            pub verified: bool,
            pub share: u8,
        }
        impl borsh::ser::BorshSerialize for Creator
        where
            Pubkey: borsh::ser::BorshSerialize,
            bool: borsh::ser::BorshSerialize,
            u8: borsh::ser::BorshSerialize,
        {
            fn serialize<W: borsh::maybestd::io::Write>(
                &self,
                writer: &mut W,
            ) -> ::core::result::Result<(), borsh::maybestd::io::Error> {
                borsh::BorshSerialize::serialize(&self.address, writer)?;
                borsh::BorshSerialize::serialize(&self.verified, writer)?;
                borsh::BorshSerialize::serialize(&self.share, writer)?;
                Ok(())
            }
        }
        impl borsh::de::BorshDeserialize for Creator
        where
            Pubkey: borsh::BorshDeserialize,
            bool: borsh::BorshDeserialize,
            u8: borsh::BorshDeserialize,
        {
            fn deserialize(
                buf: &mut &[u8],
            ) -> ::core::result::Result<Self, borsh::maybestd::io::Error> {
                Ok(Self {
                    address: borsh::BorshDeserialize::deserialize(buf)?,
                    verified: borsh::BorshDeserialize::deserialize(buf)?,
                    share: borsh::BorshDeserialize::deserialize(buf)?,
                })
            }
        }
        impl ::core::marker::StructuralPartialEq for Creator {}
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::core::cmp::PartialEq for Creator {
            #[inline]
            fn eq(&self, other: &Creator) -> bool {
                match *other {
                    Creator {
                        address: ref __self_1_0,
                        verified: ref __self_1_1,
                        share: ref __self_1_2,
                    } => match *self {
                        Creator {
                            address: ref __self_0_0,
                            verified: ref __self_0_1,
                            share: ref __self_0_2,
                        } => {
                            (*__self_0_0) == (*__self_1_0)
                                && (*__self_0_1) == (*__self_1_1)
                                && (*__self_0_2) == (*__self_1_2)
                        }
                    },
                }
            }
            #[inline]
            fn ne(&self, other: &Creator) -> bool {
                match *other {
                    Creator {
                        address: ref __self_1_0,
                        verified: ref __self_1_1,
                        share: ref __self_1_2,
                    } => match *self {
                        Creator {
                            address: ref __self_0_0,
                            verified: ref __self_0_1,
                            share: ref __self_0_2,
                        } => {
                            (*__self_0_0) != (*__self_1_0)
                                || (*__self_0_1) != (*__self_1_1)
                                || (*__self_0_2) != (*__self_1_2)
                        }
                    },
                }
            }
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::core::marker::Copy for Creator {}
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::core::clone::Clone for Creator {
            #[inline]
            fn clone(&self) -> Creator {
                {
                    let _: ::core::clone::AssertParamIsClone<Pubkey>;
                    let _: ::core::clone::AssertParamIsClone<bool>;
                    let _: ::core::clone::AssertParamIsClone<u8>;
                    *self
                }
            }
        }
        impl Creator {
            pub fn adapt(&self) -> mpl_token_metadata::state::Creator {
                mpl_token_metadata::state::Creator {
                    address: self.address,
                    verified: self.verified,
                    share: self.share,
                }
            }
        }
        pub enum TokenStandard {
            NonFungible,
            FungibleAsset,
            Fungible,
            NonFungibleEdition,
        }
        impl borsh::ser::BorshSerialize for TokenStandard {
            fn serialize<W: borsh::maybestd::io::Write>(
                &self,
                writer: &mut W,
            ) -> core::result::Result<(), borsh::maybestd::io::Error> {
                let variant_idx: u8 = match self {
                    TokenStandard::NonFungible => 0u8,
                    TokenStandard::FungibleAsset => 1u8,
                    TokenStandard::Fungible => 2u8,
                    TokenStandard::NonFungibleEdition => 3u8,
                };
                writer.write_all(&variant_idx.to_le_bytes())?;
                match self {
                    TokenStandard::NonFungible => {}
                    TokenStandard::FungibleAsset => {}
                    TokenStandard::Fungible => {}
                    TokenStandard::NonFungibleEdition => {}
                }
                Ok(())
            }
        }
        impl borsh::de::BorshDeserialize for TokenStandard {
            fn deserialize(
                buf: &mut &[u8],
            ) -> core::result::Result<Self, borsh::maybestd::io::Error> {
                let variant_idx: u8 = borsh::BorshDeserialize::deserialize(buf)?;
                let return_value = match variant_idx {
                    0u8 => TokenStandard::NonFungible,
                    1u8 => TokenStandard::FungibleAsset,
                    2u8 => TokenStandard::Fungible,
                    3u8 => TokenStandard::NonFungibleEdition,
                    _ => {
                        let msg = {
                            let res = ::alloc::fmt::format(::core::fmt::Arguments::new_v1(
                                &["Unexpected variant index: "],
                                &[::core::fmt::ArgumentV1::new_debug(&variant_idx)],
                            ));
                            res
                        };
                        return Err(borsh::maybestd::io::Error::new(
                            borsh::maybestd::io::ErrorKind::InvalidInput,
                            msg,
                        ));
                    }
                };
                Ok(return_value)
            }
        }
        impl ::core::marker::StructuralPartialEq for TokenStandard {}
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::core::cmp::PartialEq for TokenStandard {
            #[inline]
            fn eq(&self, other: &TokenStandard) -> bool {
                {
                    let __self_vi = ::core::intrinsics::discriminant_value(&*self);
                    let __arg_1_vi = ::core::intrinsics::discriminant_value(&*other);
                    if true && __self_vi == __arg_1_vi {
                        match (&*self, &*other) {
                            _ => true,
                        }
                    } else {
                        false
                    }
                }
            }
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::core::fmt::Debug for TokenStandard {
            fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                match (&*self,) {
                    (&TokenStandard::NonFungible,) => {
                        ::core::fmt::Formatter::write_str(f, "NonFungible")
                    }
                    (&TokenStandard::FungibleAsset,) => {
                        ::core::fmt::Formatter::write_str(f, "FungibleAsset")
                    }
                    (&TokenStandard::Fungible,) => ::core::fmt::Formatter::write_str(f, "Fungible"),
                    (&TokenStandard::NonFungibleEdition,) => {
                        ::core::fmt::Formatter::write_str(f, "NonFungibleEdition")
                    }
                }
            }
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::core::clone::Clone for TokenStandard {
            #[inline]
            fn clone(&self) -> TokenStandard {
                match (&*self,) {
                    (&TokenStandard::NonFungible,) => TokenStandard::NonFungible,
                    (&TokenStandard::FungibleAsset,) => TokenStandard::FungibleAsset,
                    (&TokenStandard::Fungible,) => TokenStandard::Fungible,
                    (&TokenStandard::NonFungibleEdition,) => TokenStandard::NonFungibleEdition,
                }
            }
        }
        pub enum UseMethod {
            Burn,
            Multiple,
            Single,
        }
        impl borsh::ser::BorshSerialize for UseMethod {
            fn serialize<W: borsh::maybestd::io::Write>(
                &self,
                writer: &mut W,
            ) -> core::result::Result<(), borsh::maybestd::io::Error> {
                let variant_idx: u8 = match self {
                    UseMethod::Burn => 0u8,
                    UseMethod::Multiple => 1u8,
                    UseMethod::Single => 2u8,
                };
                writer.write_all(&variant_idx.to_le_bytes())?;
                match self {
                    UseMethod::Burn => {}
                    UseMethod::Multiple => {}
                    UseMethod::Single => {}
                }
                Ok(())
            }
        }
        impl borsh::de::BorshDeserialize for UseMethod {
            fn deserialize(
                buf: &mut &[u8],
            ) -> core::result::Result<Self, borsh::maybestd::io::Error> {
                let variant_idx: u8 = borsh::BorshDeserialize::deserialize(buf)?;
                let return_value = match variant_idx {
                    0u8 => UseMethod::Burn,
                    1u8 => UseMethod::Multiple,
                    2u8 => UseMethod::Single,
                    _ => {
                        let msg = {
                            let res = ::alloc::fmt::format(::core::fmt::Arguments::new_v1(
                                &["Unexpected variant index: "],
                                &[::core::fmt::ArgumentV1::new_debug(&variant_idx)],
                            ));
                            res
                        };
                        return Err(borsh::maybestd::io::Error::new(
                            borsh::maybestd::io::ErrorKind::InvalidInput,
                            msg,
                        ));
                    }
                };
                Ok(return_value)
            }
        }
        impl ::core::marker::StructuralPartialEq for UseMethod {}
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::core::cmp::PartialEq for UseMethod {
            #[inline]
            fn eq(&self, other: &UseMethod) -> bool {
                {
                    let __self_vi = ::core::intrinsics::discriminant_value(&*self);
                    let __arg_1_vi = ::core::intrinsics::discriminant_value(&*other);
                    if true && __self_vi == __arg_1_vi {
                        match (&*self, &*other) {
                            _ => true,
                        }
                    } else {
                        false
                    }
                }
            }
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::core::fmt::Debug for UseMethod {
            fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                match (&*self,) {
                    (&UseMethod::Burn,) => ::core::fmt::Formatter::write_str(f, "Burn"),
                    (&UseMethod::Multiple,) => ::core::fmt::Formatter::write_str(f, "Multiple"),
                    (&UseMethod::Single,) => ::core::fmt::Formatter::write_str(f, "Single"),
                }
            }
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::core::clone::Clone for UseMethod {
            #[inline]
            fn clone(&self) -> UseMethod {
                match (&*self,) {
                    (&UseMethod::Burn,) => UseMethod::Burn,
                    (&UseMethod::Multiple,) => UseMethod::Multiple,
                    (&UseMethod::Single,) => UseMethod::Single,
                }
            }
        }
        pub struct Uses {
            pub use_method: UseMethod,
            pub remaining: u64,
            pub total: u64,
        }
        impl borsh::ser::BorshSerialize for Uses
        where
            UseMethod: borsh::ser::BorshSerialize,
            u64: borsh::ser::BorshSerialize,
            u64: borsh::ser::BorshSerialize,
        {
            fn serialize<W: borsh::maybestd::io::Write>(
                &self,
                writer: &mut W,
            ) -> ::core::result::Result<(), borsh::maybestd::io::Error> {
                borsh::BorshSerialize::serialize(&self.use_method, writer)?;
                borsh::BorshSerialize::serialize(&self.remaining, writer)?;
                borsh::BorshSerialize::serialize(&self.total, writer)?;
                Ok(())
            }
        }
        impl borsh::de::BorshDeserialize for Uses
        where
            UseMethod: borsh::BorshDeserialize,
            u64: borsh::BorshDeserialize,
            u64: borsh::BorshDeserialize,
        {
            fn deserialize(
                buf: &mut &[u8],
            ) -> ::core::result::Result<Self, borsh::maybestd::io::Error> {
                Ok(Self {
                    use_method: borsh::BorshDeserialize::deserialize(buf)?,
                    remaining: borsh::BorshDeserialize::deserialize(buf)?,
                    total: borsh::BorshDeserialize::deserialize(buf)?,
                })
            }
        }
        impl ::core::marker::StructuralPartialEq for Uses {}
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::core::cmp::PartialEq for Uses {
            #[inline]
            fn eq(&self, other: &Uses) -> bool {
                match *other {
                    Uses {
                        use_method: ref __self_1_0,
                        remaining: ref __self_1_1,
                        total: ref __self_1_2,
                    } => match *self {
                        Uses {
                            use_method: ref __self_0_0,
                            remaining: ref __self_0_1,
                            total: ref __self_0_2,
                        } => {
                            (*__self_0_0) == (*__self_1_0)
                                && (*__self_0_1) == (*__self_1_1)
                                && (*__self_0_2) == (*__self_1_2)
                        }
                    },
                }
            }
            #[inline]
            fn ne(&self, other: &Uses) -> bool {
                match *other {
                    Uses {
                        use_method: ref __self_1_0,
                        remaining: ref __self_1_1,
                        total: ref __self_1_2,
                    } => match *self {
                        Uses {
                            use_method: ref __self_0_0,
                            remaining: ref __self_0_1,
                            total: ref __self_0_2,
                        } => {
                            (*__self_0_0) != (*__self_1_0)
                                || (*__self_0_1) != (*__self_1_1)
                                || (*__self_0_2) != (*__self_1_2)
                        }
                    },
                }
            }
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::core::fmt::Debug for Uses {
            fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                match *self {
                    Uses {
                        use_method: ref __self_0_0,
                        remaining: ref __self_0_1,
                        total: ref __self_0_2,
                    } => {
                        let debug_trait_builder =
                            &mut ::core::fmt::Formatter::debug_struct(f, "Uses");
                        let _ = ::core::fmt::DebugStruct::field(
                            debug_trait_builder,
                            "use_method",
                            &&(*__self_0_0),
                        );
                        let _ = ::core::fmt::DebugStruct::field(
                            debug_trait_builder,
                            "remaining",
                            &&(*__self_0_1),
                        );
                        let _ = ::core::fmt::DebugStruct::field(
                            debug_trait_builder,
                            "total",
                            &&(*__self_0_2),
                        );
                        ::core::fmt::DebugStruct::finish(debug_trait_builder)
                    }
                }
            }
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::core::clone::Clone for Uses {
            #[inline]
            fn clone(&self) -> Uses {
                match *self {
                    Uses {
                        use_method: ref __self_0_0,
                        remaining: ref __self_0_1,
                        total: ref __self_0_2,
                    } => Uses {
                        use_method: ::core::clone::Clone::clone(&(*__self_0_0)),
                        remaining: ::core::clone::Clone::clone(&(*__self_0_1)),
                        total: ::core::clone::Clone::clone(&(*__self_0_2)),
                    },
                }
            }
        }
        impl Uses {
            pub fn adapt(&self) -> mpl_token_metadata::state::Uses {
                mpl_token_metadata::state::Uses {
                    use_method: match self.use_method {
                        UseMethod::Burn => mpl_token_metadata::state::UseMethod::Burn,
                        UseMethod::Multiple => mpl_token_metadata::state::UseMethod::Multiple,
                        UseMethod::Single => mpl_token_metadata::state::UseMethod::Single,
                    },
                    remaining: self.remaining,
                    total: self.total,
                }
            }
        }
        #[repr(C)]
        pub struct Collection {
            pub verified: bool,
            pub key: Pubkey,
        }
        impl borsh::ser::BorshSerialize for Collection
        where
            bool: borsh::ser::BorshSerialize,
            Pubkey: borsh::ser::BorshSerialize,
        {
            fn serialize<W: borsh::maybestd::io::Write>(
                &self,
                writer: &mut W,
            ) -> ::core::result::Result<(), borsh::maybestd::io::Error> {
                borsh::BorshSerialize::serialize(&self.verified, writer)?;
                borsh::BorshSerialize::serialize(&self.key, writer)?;
                Ok(())
            }
        }
        impl borsh::de::BorshDeserialize for Collection
        where
            bool: borsh::BorshDeserialize,
            Pubkey: borsh::BorshDeserialize,
        {
            fn deserialize(
                buf: &mut &[u8],
            ) -> ::core::result::Result<Self, borsh::maybestd::io::Error> {
                Ok(Self {
                    verified: borsh::BorshDeserialize::deserialize(buf)?,
                    key: borsh::BorshDeserialize::deserialize(buf)?,
                })
            }
        }
        impl ::core::marker::StructuralPartialEq for Collection {}
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::core::cmp::PartialEq for Collection {
            #[inline]
            fn eq(&self, other: &Collection) -> bool {
                match *other {
                    Collection {
                        verified: ref __self_1_0,
                        key: ref __self_1_1,
                    } => match *self {
                        Collection {
                            verified: ref __self_0_0,
                            key: ref __self_0_1,
                        } => (*__self_0_0) == (*__self_1_0) && (*__self_0_1) == (*__self_1_1),
                    },
                }
            }
            #[inline]
            fn ne(&self, other: &Collection) -> bool {
                match *other {
                    Collection {
                        verified: ref __self_1_0,
                        key: ref __self_1_1,
                    } => match *self {
                        Collection {
                            verified: ref __self_0_0,
                            key: ref __self_0_1,
                        } => (*__self_0_0) != (*__self_1_0) || (*__self_0_1) != (*__self_1_1),
                    },
                }
            }
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::core::fmt::Debug for Collection {
            fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                match *self {
                    Collection {
                        verified: ref __self_0_0,
                        key: ref __self_0_1,
                    } => {
                        let debug_trait_builder =
                            &mut ::core::fmt::Formatter::debug_struct(f, "Collection");
                        let _ = ::core::fmt::DebugStruct::field(
                            debug_trait_builder,
                            "verified",
                            &&(*__self_0_0),
                        );
                        let _ = ::core::fmt::DebugStruct::field(
                            debug_trait_builder,
                            "key",
                            &&(*__self_0_1),
                        );
                        ::core::fmt::DebugStruct::finish(debug_trait_builder)
                    }
                }
            }
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::core::clone::Clone for Collection {
            #[inline]
            fn clone(&self) -> Collection {
                match *self {
                    Collection {
                        verified: ref __self_0_0,
                        key: ref __self_0_1,
                    } => Collection {
                        verified: ::core::clone::Clone::clone(&(*__self_0_0)),
                        key: ::core::clone::Clone::clone(&(*__self_0_1)),
                    },
                }
            }
        }
        impl Collection {
            pub fn adapt(&self) -> mpl_token_metadata::state::Collection {
                mpl_token_metadata::state::Collection {
                    verified: self.verified,
                    key: self.key,
                }
            }
        }
        pub struct MetadataArgs {
            /// The name of the asset
            pub name: String,
            /// The symbol for the asset
            pub symbol: String,
            /// URI pointing to JSON representing the asset
            pub uri: String,
            /// Royalty basis points that goes to creators in secondary sales (0-10000)
            pub seller_fee_basis_points: u16,
            pub primary_sale_happened: bool,
            pub is_mutable: bool,
            /// nonce for easy calculation of editions, if present
            pub edition_nonce: Option<u8>,
            /// Since we cannot easily change Metadata, we add the new DataV2 fields here at the end.
            pub token_standard: Option<TokenStandard>,
            /// Collection
            pub collection: Option<Collection>,
            /// Uses
            pub uses: Option<Uses>,
            pub token_program_version: TokenProgramVersion,
            pub creators: Vec<Creator>,
        }
        impl borsh::ser::BorshSerialize for MetadataArgs
        where
            String: borsh::ser::BorshSerialize,
            String: borsh::ser::BorshSerialize,
            String: borsh::ser::BorshSerialize,
            u16: borsh::ser::BorshSerialize,
            bool: borsh::ser::BorshSerialize,
            bool: borsh::ser::BorshSerialize,
            Option<u8>: borsh::ser::BorshSerialize,
            Option<TokenStandard>: borsh::ser::BorshSerialize,
            Option<Collection>: borsh::ser::BorshSerialize,
            Option<Uses>: borsh::ser::BorshSerialize,
            TokenProgramVersion: borsh::ser::BorshSerialize,
            Vec<Creator>: borsh::ser::BorshSerialize,
        {
            fn serialize<W: borsh::maybestd::io::Write>(
                &self,
                writer: &mut W,
            ) -> ::core::result::Result<(), borsh::maybestd::io::Error> {
                borsh::BorshSerialize::serialize(&self.name, writer)?;
                borsh::BorshSerialize::serialize(&self.symbol, writer)?;
                borsh::BorshSerialize::serialize(&self.uri, writer)?;
                borsh::BorshSerialize::serialize(&self.seller_fee_basis_points, writer)?;
                borsh::BorshSerialize::serialize(&self.primary_sale_happened, writer)?;
                borsh::BorshSerialize::serialize(&self.is_mutable, writer)?;
                borsh::BorshSerialize::serialize(&self.edition_nonce, writer)?;
                borsh::BorshSerialize::serialize(&self.token_standard, writer)?;
                borsh::BorshSerialize::serialize(&self.collection, writer)?;
                borsh::BorshSerialize::serialize(&self.uses, writer)?;
                borsh::BorshSerialize::serialize(&self.token_program_version, writer)?;
                borsh::BorshSerialize::serialize(&self.creators, writer)?;
                Ok(())
            }
        }
        impl borsh::de::BorshDeserialize for MetadataArgs
        where
            String: borsh::BorshDeserialize,
            String: borsh::BorshDeserialize,
            String: borsh::BorshDeserialize,
            u16: borsh::BorshDeserialize,
            bool: borsh::BorshDeserialize,
            bool: borsh::BorshDeserialize,
            Option<u8>: borsh::BorshDeserialize,
            Option<TokenStandard>: borsh::BorshDeserialize,
            Option<Collection>: borsh::BorshDeserialize,
            Option<Uses>: borsh::BorshDeserialize,
            TokenProgramVersion: borsh::BorshDeserialize,
            Vec<Creator>: borsh::BorshDeserialize,
        {
            fn deserialize(
                buf: &mut &[u8],
            ) -> ::core::result::Result<Self, borsh::maybestd::io::Error> {
                Ok(Self {
                    name: borsh::BorshDeserialize::deserialize(buf)?,
                    symbol: borsh::BorshDeserialize::deserialize(buf)?,
                    uri: borsh::BorshDeserialize::deserialize(buf)?,
                    seller_fee_basis_points: borsh::BorshDeserialize::deserialize(buf)?,
                    primary_sale_happened: borsh::BorshDeserialize::deserialize(buf)?,
                    is_mutable: borsh::BorshDeserialize::deserialize(buf)?,
                    edition_nonce: borsh::BorshDeserialize::deserialize(buf)?,
                    token_standard: borsh::BorshDeserialize::deserialize(buf)?,
                    collection: borsh::BorshDeserialize::deserialize(buf)?,
                    uses: borsh::BorshDeserialize::deserialize(buf)?,
                    token_program_version: borsh::BorshDeserialize::deserialize(buf)?,
                    creators: borsh::BorshDeserialize::deserialize(buf)?,
                })
            }
        }
        impl ::core::marker::StructuralPartialEq for MetadataArgs {}
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::core::cmp::PartialEq for MetadataArgs {
            #[inline]
            fn eq(&self, other: &MetadataArgs) -> bool {
                match *other {
                    MetadataArgs {
                        name: ref __self_1_0,
                        symbol: ref __self_1_1,
                        uri: ref __self_1_2,
                        seller_fee_basis_points: ref __self_1_3,
                        primary_sale_happened: ref __self_1_4,
                        is_mutable: ref __self_1_5,
                        edition_nonce: ref __self_1_6,
                        token_standard: ref __self_1_7,
                        collection: ref __self_1_8,
                        uses: ref __self_1_9,
                        token_program_version: ref __self_1_10,
                        creators: ref __self_1_11,
                    } => match *self {
                        MetadataArgs {
                            name: ref __self_0_0,
                            symbol: ref __self_0_1,
                            uri: ref __self_0_2,
                            seller_fee_basis_points: ref __self_0_3,
                            primary_sale_happened: ref __self_0_4,
                            is_mutable: ref __self_0_5,
                            edition_nonce: ref __self_0_6,
                            token_standard: ref __self_0_7,
                            collection: ref __self_0_8,
                            uses: ref __self_0_9,
                            token_program_version: ref __self_0_10,
                            creators: ref __self_0_11,
                        } => {
                            (*__self_0_0) == (*__self_1_0)
                                && (*__self_0_1) == (*__self_1_1)
                                && (*__self_0_2) == (*__self_1_2)
                                && (*__self_0_3) == (*__self_1_3)
                                && (*__self_0_4) == (*__self_1_4)
                                && (*__self_0_5) == (*__self_1_5)
                                && (*__self_0_6) == (*__self_1_6)
                                && (*__self_0_7) == (*__self_1_7)
                                && (*__self_0_8) == (*__self_1_8)
                                && (*__self_0_9) == (*__self_1_9)
                                && (*__self_0_10) == (*__self_1_10)
                                && (*__self_0_11) == (*__self_1_11)
                        }
                    },
                }
            }
            #[inline]
            fn ne(&self, other: &MetadataArgs) -> bool {
                match *other {
                    MetadataArgs {
                        name: ref __self_1_0,
                        symbol: ref __self_1_1,
                        uri: ref __self_1_2,
                        seller_fee_basis_points: ref __self_1_3,
                        primary_sale_happened: ref __self_1_4,
                        is_mutable: ref __self_1_5,
                        edition_nonce: ref __self_1_6,
                        token_standard: ref __self_1_7,
                        collection: ref __self_1_8,
                        uses: ref __self_1_9,
                        token_program_version: ref __self_1_10,
                        creators: ref __self_1_11,
                    } => match *self {
                        MetadataArgs {
                            name: ref __self_0_0,
                            symbol: ref __self_0_1,
                            uri: ref __self_0_2,
                            seller_fee_basis_points: ref __self_0_3,
                            primary_sale_happened: ref __self_0_4,
                            is_mutable: ref __self_0_5,
                            edition_nonce: ref __self_0_6,
                            token_standard: ref __self_0_7,
                            collection: ref __self_0_8,
                            uses: ref __self_0_9,
                            token_program_version: ref __self_0_10,
                            creators: ref __self_0_11,
                        } => {
                            (*__self_0_0) != (*__self_1_0)
                                || (*__self_0_1) != (*__self_1_1)
                                || (*__self_0_2) != (*__self_1_2)
                                || (*__self_0_3) != (*__self_1_3)
                                || (*__self_0_4) != (*__self_1_4)
                                || (*__self_0_5) != (*__self_1_5)
                                || (*__self_0_6) != (*__self_1_6)
                                || (*__self_0_7) != (*__self_1_7)
                                || (*__self_0_8) != (*__self_1_8)
                                || (*__self_0_9) != (*__self_1_9)
                                || (*__self_0_10) != (*__self_1_10)
                                || (*__self_0_11) != (*__self_1_11)
                        }
                    },
                }
            }
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::core::clone::Clone for MetadataArgs {
            #[inline]
            fn clone(&self) -> MetadataArgs {
                match *self {
                    MetadataArgs {
                        name: ref __self_0_0,
                        symbol: ref __self_0_1,
                        uri: ref __self_0_2,
                        seller_fee_basis_points: ref __self_0_3,
                        primary_sale_happened: ref __self_0_4,
                        is_mutable: ref __self_0_5,
                        edition_nonce: ref __self_0_6,
                        token_standard: ref __self_0_7,
                        collection: ref __self_0_8,
                        uses: ref __self_0_9,
                        token_program_version: ref __self_0_10,
                        creators: ref __self_0_11,
                    } => MetadataArgs {
                        name: ::core::clone::Clone::clone(&(*__self_0_0)),
                        symbol: ::core::clone::Clone::clone(&(*__self_0_1)),
                        uri: ::core::clone::Clone::clone(&(*__self_0_2)),
                        seller_fee_basis_points: ::core::clone::Clone::clone(&(*__self_0_3)),
                        primary_sale_happened: ::core::clone::Clone::clone(&(*__self_0_4)),
                        is_mutable: ::core::clone::Clone::clone(&(*__self_0_5)),
                        edition_nonce: ::core::clone::Clone::clone(&(*__self_0_6)),
                        token_standard: ::core::clone::Clone::clone(&(*__self_0_7)),
                        collection: ::core::clone::Clone::clone(&(*__self_0_8)),
                        uses: ::core::clone::Clone::clone(&(*__self_0_9)),
                        token_program_version: ::core::clone::Clone::clone(&(*__self_0_10)),
                        creators: ::core::clone::Clone::clone(&(*__self_0_11)),
                    },
                }
            }
        }
    }
    pub mod metaplex_anchor {
        use anchor_lang::prelude::*;
        use anchor_lang::solana_program::pubkey::Pubkey;
        use mpl_token_metadata::{
            state::{MAX_MASTER_EDITION_LEN, MAX_METADATA_LEN},
            utils::try_from_slice_checked,
        };
        use std::ops::Deref;
        pub struct MasterEdition(mpl_token_metadata::state::MasterEditionV2);
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::core::clone::Clone for MasterEdition {
            #[inline]
            fn clone(&self) -> MasterEdition {
                match *self {
                    MasterEdition(ref __self_0_0) => {
                        MasterEdition(::core::clone::Clone::clone(&(*__self_0_0)))
                    }
                }
            }
        }
        impl borsh::de::BorshDeserialize for MasterEdition {
            fn deserialize(
                buf: &mut &[u8],
            ) -> ::core::result::Result<Self, borsh::maybestd::io::Error> {
                Ok(Self(borsh::BorshDeserialize::deserialize(buf)?))
            }
        }
        impl borsh::ser::BorshSerialize for MasterEdition {
            fn serialize<W: borsh::maybestd::io::Write>(
                &self,
                writer: &mut W,
            ) -> ::core::result::Result<(), borsh::maybestd::io::Error> {
                borsh::BorshSerialize::serialize(&self.0, writer)?;
                Ok(())
            }
        }
        impl anchor_lang::AccountDeserialize for MasterEdition {
            fn try_deserialize_unchecked(buf: &mut &[u8]) -> Result<Self> {
                try_from_slice_checked(
                    buf,
                    mpl_token_metadata::state::Key::MasterEditionV2,
                    MAX_MASTER_EDITION_LEN,
                )
                .map_err(Into::into)
            }
        }
        impl anchor_lang::AccountSerialize for MasterEdition {}
        impl anchor_lang::Owner for MasterEdition {
            fn owner() -> Pubkey {
                mpl_token_metadata::id()
            }
        }
        impl Deref for MasterEdition {
            type Target = mpl_token_metadata::state::MasterEditionV2;
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        pub struct TokenMetadata(mpl_token_metadata::state::Metadata);
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::core::clone::Clone for TokenMetadata {
            #[inline]
            fn clone(&self) -> TokenMetadata {
                match *self {
                    TokenMetadata(ref __self_0_0) => {
                        TokenMetadata(::core::clone::Clone::clone(&(*__self_0_0)))
                    }
                }
            }
        }
        impl borsh::de::BorshDeserialize for TokenMetadata {
            fn deserialize(
                buf: &mut &[u8],
            ) -> ::core::result::Result<Self, borsh::maybestd::io::Error> {
                Ok(Self(borsh::BorshDeserialize::deserialize(buf)?))
            }
        }
        impl borsh::ser::BorshSerialize for TokenMetadata {
            fn serialize<W: borsh::maybestd::io::Write>(
                &self,
                writer: &mut W,
            ) -> ::core::result::Result<(), borsh::maybestd::io::Error> {
                borsh::BorshSerialize::serialize(&self.0, writer)?;
                Ok(())
            }
        }
        impl anchor_lang::AccountDeserialize for TokenMetadata {
            fn try_deserialize_unchecked(buf: &mut &[u8]) -> Result<Self> {
                try_from_slice_checked(
                    buf,
                    mpl_token_metadata::state::Key::MetadataV1,
                    MAX_METADATA_LEN,
                )
                .map_err(Into::into)
            }
        }
        impl anchor_lang::AccountSerialize for TokenMetadata {}
        impl anchor_lang::Owner for TokenMetadata {
            fn owner() -> Pubkey {
                mpl_token_metadata::id()
            }
        }
        impl Deref for TokenMetadata {
            type Target = mpl_token_metadata::state::Metadata;
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        pub struct MplTokenMetadata;
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::core::clone::Clone for MplTokenMetadata {
            #[inline]
            fn clone(&self) -> MplTokenMetadata {
                match *self {
                    MplTokenMetadata => MplTokenMetadata,
                }
            }
        }
        impl anchor_lang::Id for MplTokenMetadata {
            fn id() -> Pubkey {
                mpl_token_metadata::id()
            }
        }
    }
    pub mod request {
        use crate::error::BubblegumError;
        use anchor_lang::prelude::*;
        pub const MINT_REQUEST_SIZE: usize = 48 + 8;
        pub struct MintRequest {
            pub mint_authority: Pubkey,
            pub num_mints_requested: u64,
            pub num_mints_approved: u64,
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::core::marker::Copy for MintRequest {}
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::core::fmt::Debug for MintRequest {
            fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                match *self {
                    MintRequest {
                        mint_authority: ref __self_0_0,
                        num_mints_requested: ref __self_0_1,
                        num_mints_approved: ref __self_0_2,
                    } => {
                        let debug_trait_builder =
                            &mut ::core::fmt::Formatter::debug_struct(f, "MintRequest");
                        let _ = ::core::fmt::DebugStruct::field(
                            debug_trait_builder,
                            "mint_authority",
                            &&(*__self_0_0),
                        );
                        let _ = ::core::fmt::DebugStruct::field(
                            debug_trait_builder,
                            "num_mints_requested",
                            &&(*__self_0_1),
                        );
                        let _ = ::core::fmt::DebugStruct::field(
                            debug_trait_builder,
                            "num_mints_approved",
                            &&(*__self_0_2),
                        );
                        ::core::fmt::DebugStruct::finish(debug_trait_builder)
                    }
                }
            }
        }
        impl borsh::ser::BorshSerialize for MintRequest
        where
            Pubkey: borsh::ser::BorshSerialize,
            u64: borsh::ser::BorshSerialize,
            u64: borsh::ser::BorshSerialize,
        {
            fn serialize<W: borsh::maybestd::io::Write>(
                &self,
                writer: &mut W,
            ) -> ::core::result::Result<(), borsh::maybestd::io::Error> {
                borsh::BorshSerialize::serialize(&self.mint_authority, writer)?;
                borsh::BorshSerialize::serialize(&self.num_mints_requested, writer)?;
                borsh::BorshSerialize::serialize(&self.num_mints_approved, writer)?;
                Ok(())
            }
        }
        impl borsh::de::BorshDeserialize for MintRequest
        where
            Pubkey: borsh::BorshDeserialize,
            u64: borsh::BorshDeserialize,
            u64: borsh::BorshDeserialize,
        {
            fn deserialize(
                buf: &mut &[u8],
            ) -> ::core::result::Result<Self, borsh::maybestd::io::Error> {
                Ok(Self {
                    mint_authority: borsh::BorshDeserialize::deserialize(buf)?,
                    num_mints_requested: borsh::BorshDeserialize::deserialize(buf)?,
                    num_mints_approved: borsh::BorshDeserialize::deserialize(buf)?,
                })
            }
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::core::clone::Clone for MintRequest {
            #[inline]
            fn clone(&self) -> MintRequest {
                match *self {
                    MintRequest {
                        mint_authority: ref __self_0_0,
                        num_mints_requested: ref __self_0_1,
                        num_mints_approved: ref __self_0_2,
                    } => MintRequest {
                        mint_authority: ::core::clone::Clone::clone(&(*__self_0_0)),
                        num_mints_requested: ::core::clone::Clone::clone(&(*__self_0_1)),
                        num_mints_approved: ::core::clone::Clone::clone(&(*__self_0_2)),
                    },
                }
            }
        }
        #[automatically_derived]
        impl anchor_lang::AccountSerialize for MintRequest {
            fn try_serialize<W: std::io::Write>(&self, writer: &mut W) -> anchor_lang::Result<()> {
                if writer
                    .write_all(&[60, 88, 16, 213, 180, 138, 14, 225])
                    .is_err()
                {
                    return Err(anchor_lang::error::ErrorCode::AccountDidNotSerialize.into());
                }
                if AnchorSerialize::serialize(self, writer).is_err() {
                    return Err(anchor_lang::error::ErrorCode::AccountDidNotSerialize.into());
                }
                Ok(())
            }
        }
        #[automatically_derived]
        impl anchor_lang::AccountDeserialize for MintRequest {
            fn try_deserialize(buf: &mut &[u8]) -> anchor_lang::Result<Self> {
                if buf.len() < [60, 88, 16, 213, 180, 138, 14, 225].len() {
                    return Err(anchor_lang::error::ErrorCode::AccountDiscriminatorNotFound.into());
                }
                let given_disc = &buf[..8];
                if &[60, 88, 16, 213, 180, 138, 14, 225] != given_disc {
                    return Err(
                        anchor_lang::error::Error::from(anchor_lang::error::AnchorError {
                            error_name: anchor_lang::error::ErrorCode::AccountDiscriminatorMismatch
                                .name(),
                            error_code_number:
                                anchor_lang::error::ErrorCode::AccountDiscriminatorMismatch.into(),
                            error_msg: anchor_lang::error::ErrorCode::AccountDiscriminatorMismatch
                                .to_string(),
                            error_origin: Some(anchor_lang::error::ErrorOrigin::Source(
                                anchor_lang::error::Source {
                                    filename: "src/state/request.rs",
                                    line: 6u32,
                                },
                            )),
                            compared_values: None,
                        })
                        .with_account_name("MintRequest"),
                    );
                }
                Self::try_deserialize_unchecked(buf)
            }
            fn try_deserialize_unchecked(buf: &mut &[u8]) -> anchor_lang::Result<Self> {
                let mut data: &[u8] = &buf[8..];
                AnchorDeserialize::deserialize(&mut data)
                    .map_err(|_| anchor_lang::error::ErrorCode::AccountDidNotDeserialize.into())
            }
        }
        #[automatically_derived]
        impl anchor_lang::Discriminator for MintRequest {
            fn discriminator() -> [u8; 8] {
                [60, 88, 16, 213, 180, 138, 14, 225]
            }
        }
        #[automatically_derived]
        impl anchor_lang::Owner for MintRequest {
            fn owner() -> Pubkey {
                crate::ID
            }
        }
        impl MintRequest {
            pub fn init(&mut self, mint_authority: &Pubkey, mint_capacity: u64) {
                self.mint_authority = *mint_authority;
                self.num_mints_requested = mint_capacity;
                self.num_mints_approved = 0;
            }
            pub fn decrement_approvals(&mut self) -> Result<()> {
                if self.num_mints_approved == 0 {
                    return Err(BubblegumError::MintRequestNotApproved.into());
                }
                self.num_mints_approved -= 1;
                Ok(())
            }
            pub fn is_initialized(&self) -> bool {
                self.mint_authority != Pubkey::default()
            }
            pub fn init_or_set(&mut self, auth: Pubkey, mint_capacity: u64) {
                if self.is_initialized() {
                    self.num_mints_requested = mint_capacity;
                } else {
                    self.init(&auth, mint_capacity);
                }
            }
            pub fn approve(&mut self, num_to_approve: u64) -> Result<()> {
                if num_to_approve > self.num_mints_requested {
                    ::solana_program::log::sol_log(
                        "Cannot approve more mints than the requested amount",
                    );
                    return Err(BubblegumError::MintRequestNotApproved.into());
                }
                self.num_mints_requested = self.num_mints_requested.saturating_sub(num_to_approve);
                self.num_mints_approved = self.num_mints_approved.saturating_add(num_to_approve);
                Ok(())
            }
            pub fn process_mint(&mut self) -> Result<()> {
                if self.num_mints_approved > 0 {
                    return Err(BubblegumError::MintRequestNotApproved.into());
                }
                self.num_mints_approved = self.num_mints_approved.saturating_sub(1);
                Ok(())
            }
            pub fn has_mint_capacity(&self, capacity: u64) -> bool {
                self.num_mints_approved >= capacity
            }
        }
    }
    use anchor_lang::prelude::*;
    use leaf_schema::LeafSchema;
    use leaf_schema::Version;
    use metaplex_adapter::MetadataArgs;
    pub const TREE_AUTHORITY_SIZE: usize = 88 + 8;
    pub const VOUCHER_SIZE: usize = 8 + 1 + 32 + 32 + 32 + 8 + 32 + 32 + 4 + 32;
    pub const VOUCHER_PREFIX: &str = "voucher";
    pub const ASSET_PREFIX: &str = "asset";
    pub struct TreeConfig {
        pub creator: Pubkey,
        pub delegate: Pubkey,
        pub total_mint_capacity: u64,
        pub num_mints_approved: u64,
        pub num_minted: u64,
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::marker::Copy for TreeConfig {}
    impl borsh::ser::BorshSerialize for TreeConfig
    where
        Pubkey: borsh::ser::BorshSerialize,
        Pubkey: borsh::ser::BorshSerialize,
        u64: borsh::ser::BorshSerialize,
        u64: borsh::ser::BorshSerialize,
        u64: borsh::ser::BorshSerialize,
    {
        fn serialize<W: borsh::maybestd::io::Write>(
            &self,
            writer: &mut W,
        ) -> ::core::result::Result<(), borsh::maybestd::io::Error> {
            borsh::BorshSerialize::serialize(&self.creator, writer)?;
            borsh::BorshSerialize::serialize(&self.delegate, writer)?;
            borsh::BorshSerialize::serialize(&self.total_mint_capacity, writer)?;
            borsh::BorshSerialize::serialize(&self.num_mints_approved, writer)?;
            borsh::BorshSerialize::serialize(&self.num_minted, writer)?;
            Ok(())
        }
    }
    impl borsh::de::BorshDeserialize for TreeConfig
    where
        Pubkey: borsh::BorshDeserialize,
        Pubkey: borsh::BorshDeserialize,
        u64: borsh::BorshDeserialize,
        u64: borsh::BorshDeserialize,
        u64: borsh::BorshDeserialize,
    {
        fn deserialize(
            buf: &mut &[u8],
        ) -> ::core::result::Result<Self, borsh::maybestd::io::Error> {
            Ok(Self {
                creator: borsh::BorshDeserialize::deserialize(buf)?,
                delegate: borsh::BorshDeserialize::deserialize(buf)?,
                total_mint_capacity: borsh::BorshDeserialize::deserialize(buf)?,
                num_mints_approved: borsh::BorshDeserialize::deserialize(buf)?,
                num_minted: borsh::BorshDeserialize::deserialize(buf)?,
            })
        }
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::clone::Clone for TreeConfig {
        #[inline]
        fn clone(&self) -> TreeConfig {
            match *self {
                TreeConfig {
                    creator: ref __self_0_0,
                    delegate: ref __self_0_1,
                    total_mint_capacity: ref __self_0_2,
                    num_mints_approved: ref __self_0_3,
                    num_minted: ref __self_0_4,
                } => TreeConfig {
                    creator: ::core::clone::Clone::clone(&(*__self_0_0)),
                    delegate: ::core::clone::Clone::clone(&(*__self_0_1)),
                    total_mint_capacity: ::core::clone::Clone::clone(&(*__self_0_2)),
                    num_mints_approved: ::core::clone::Clone::clone(&(*__self_0_3)),
                    num_minted: ::core::clone::Clone::clone(&(*__self_0_4)),
                },
            }
        }
    }
    #[automatically_derived]
    impl anchor_lang::AccountSerialize for TreeConfig {
        fn try_serialize<W: std::io::Write>(&self, writer: &mut W) -> anchor_lang::Result<()> {
            if writer
                .write_all(&[122, 245, 175, 248, 171, 34, 0, 207])
                .is_err()
            {
                return Err(anchor_lang::error::ErrorCode::AccountDidNotSerialize.into());
            }
            if AnchorSerialize::serialize(self, writer).is_err() {
                return Err(anchor_lang::error::ErrorCode::AccountDidNotSerialize.into());
            }
            Ok(())
        }
    }
    #[automatically_derived]
    impl anchor_lang::AccountDeserialize for TreeConfig {
        fn try_deserialize(buf: &mut &[u8]) -> anchor_lang::Result<Self> {
            if buf.len() < [122, 245, 175, 248, 171, 34, 0, 207].len() {
                return Err(anchor_lang::error::ErrorCode::AccountDiscriminatorNotFound.into());
            }
            let given_disc = &buf[..8];
            if &[122, 245, 175, 248, 171, 34, 0, 207] != given_disc {
                return Err(
                    anchor_lang::error::Error::from(anchor_lang::error::AnchorError {
                        error_name: anchor_lang::error::ErrorCode::AccountDiscriminatorMismatch
                            .name(),
                        error_code_number:
                            anchor_lang::error::ErrorCode::AccountDiscriminatorMismatch.into(),
                        error_msg: anchor_lang::error::ErrorCode::AccountDiscriminatorMismatch
                            .to_string(),
                        error_origin: Some(anchor_lang::error::ErrorOrigin::Source(
                            anchor_lang::error::Source {
                                filename: "src/state/mod.rs",
                                line: 15u32,
                            },
                        )),
                        compared_values: None,
                    })
                    .with_account_name("TreeConfig"),
                );
            }
            Self::try_deserialize_unchecked(buf)
        }
        fn try_deserialize_unchecked(buf: &mut &[u8]) -> anchor_lang::Result<Self> {
            let mut data: &[u8] = &buf[8..];
            AnchorDeserialize::deserialize(&mut data)
                .map_err(|_| anchor_lang::error::ErrorCode::AccountDidNotDeserialize.into())
        }
    }
    #[automatically_derived]
    impl anchor_lang::Discriminator for TreeConfig {
        fn discriminator() -> [u8; 8] {
            [122, 245, 175, 248, 171, 34, 0, 207]
        }
    }
    #[automatically_derived]
    impl anchor_lang::Owner for TreeConfig {
        fn owner() -> Pubkey {
            crate::ID
        }
    }
    impl TreeConfig {
        pub fn increment_mint_count(&mut self) {
            self.num_minted = self.num_minted.saturating_add(1);
        }
        pub fn approve_mint_capacity(&mut self, capacity: u64) {
            self.num_mints_approved = self.num_mints_approved.saturating_add(capacity);
        }
        pub fn contains_mint_capacity(&self, requested_capacity: u64) -> bool {
            let remaining_mints = self.total_mint_capacity.saturating_sub(self.num_minted);
            let remaining_mints_to_approve =
                remaining_mints.saturating_sub(self.num_mints_approved);
            requested_capacity <= remaining_mints_to_approve
        }
        pub fn restore_mint_capacity(&mut self, capacity: u64) {
            self.num_mints_approved = self.num_mints_approved.saturating_sub(capacity);
        }
    }
    pub struct Voucher {
        pub leaf_schema: LeafSchema,
        pub index: u32,
        pub merkle_slab: Pubkey,
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::marker::Copy for Voucher {}
    impl borsh::ser::BorshSerialize for Voucher
    where
        LeafSchema: borsh::ser::BorshSerialize,
        u32: borsh::ser::BorshSerialize,
        Pubkey: borsh::ser::BorshSerialize,
    {
        fn serialize<W: borsh::maybestd::io::Write>(
            &self,
            writer: &mut W,
        ) -> ::core::result::Result<(), borsh::maybestd::io::Error> {
            borsh::BorshSerialize::serialize(&self.leaf_schema, writer)?;
            borsh::BorshSerialize::serialize(&self.index, writer)?;
            borsh::BorshSerialize::serialize(&self.merkle_slab, writer)?;
            Ok(())
        }
    }
    impl borsh::de::BorshDeserialize for Voucher
    where
        LeafSchema: borsh::BorshDeserialize,
        u32: borsh::BorshDeserialize,
        Pubkey: borsh::BorshDeserialize,
    {
        fn deserialize(
            buf: &mut &[u8],
        ) -> ::core::result::Result<Self, borsh::maybestd::io::Error> {
            Ok(Self {
                leaf_schema: borsh::BorshDeserialize::deserialize(buf)?,
                index: borsh::BorshDeserialize::deserialize(buf)?,
                merkle_slab: borsh::BorshDeserialize::deserialize(buf)?,
            })
        }
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::clone::Clone for Voucher {
        #[inline]
        fn clone(&self) -> Voucher {
            match *self {
                Voucher {
                    leaf_schema: ref __self_0_0,
                    index: ref __self_0_1,
                    merkle_slab: ref __self_0_2,
                } => Voucher {
                    leaf_schema: ::core::clone::Clone::clone(&(*__self_0_0)),
                    index: ::core::clone::Clone::clone(&(*__self_0_1)),
                    merkle_slab: ::core::clone::Clone::clone(&(*__self_0_2)),
                },
            }
        }
    }
    #[automatically_derived]
    impl anchor_lang::AccountSerialize for Voucher {
        fn try_serialize<W: std::io::Write>(&self, writer: &mut W) -> anchor_lang::Result<()> {
            if writer
                .write_all(&[191, 204, 149, 234, 213, 165, 13, 65])
                .is_err()
            {
                return Err(anchor_lang::error::ErrorCode::AccountDidNotSerialize.into());
            }
            if AnchorSerialize::serialize(self, writer).is_err() {
                return Err(anchor_lang::error::ErrorCode::AccountDidNotSerialize.into());
            }
            Ok(())
        }
    }
    #[automatically_derived]
    impl anchor_lang::AccountDeserialize for Voucher {
        fn try_deserialize(buf: &mut &[u8]) -> anchor_lang::Result<Self> {
            if buf.len() < [191, 204, 149, 234, 213, 165, 13, 65].len() {
                return Err(anchor_lang::error::ErrorCode::AccountDiscriminatorNotFound.into());
            }
            let given_disc = &buf[..8];
            if &[191, 204, 149, 234, 213, 165, 13, 65] != given_disc {
                return Err(
                    anchor_lang::error::Error::from(anchor_lang::error::AnchorError {
                        error_name: anchor_lang::error::ErrorCode::AccountDiscriminatorMismatch
                            .name(),
                        error_code_number:
                            anchor_lang::error::ErrorCode::AccountDiscriminatorMismatch.into(),
                        error_msg: anchor_lang::error::ErrorCode::AccountDiscriminatorMismatch
                            .to_string(),
                        error_origin: Some(anchor_lang::error::ErrorOrigin::Source(
                            anchor_lang::error::Source {
                                filename: "src/state/mod.rs",
                                line: 45u32,
                            },
                        )),
                        compared_values: None,
                    })
                    .with_account_name("Voucher"),
                );
            }
            Self::try_deserialize_unchecked(buf)
        }
        fn try_deserialize_unchecked(buf: &mut &[u8]) -> anchor_lang::Result<Self> {
            let mut data: &[u8] = &buf[8..];
            AnchorDeserialize::deserialize(&mut data)
                .map_err(|_| anchor_lang::error::ErrorCode::AccountDidNotDeserialize.into())
        }
    }
    #[automatically_derived]
    impl anchor_lang::Discriminator for Voucher {
        fn discriminator() -> [u8; 8] {
            [191, 204, 149, 234, 213, 165, 13, 65]
        }
    }
    #[automatically_derived]
    impl anchor_lang::Owner for Voucher {
        fn owner() -> Pubkey {
            crate::ID
        }
    }
    impl Voucher {
        pub fn new(leaf_schema: LeafSchema, index: u32, merkle_slab: Pubkey) -> Self {
            Self {
                leaf_schema,
                index,
                merkle_slab,
            }
        }
    }
    pub struct NewNFTEvent {
        pub version: Version,
        pub metadata: MetadataArgs,
        pub nonce: u64,
    }
    impl borsh::ser::BorshSerialize for NewNFTEvent
    where
        Version: borsh::ser::BorshSerialize,
        MetadataArgs: borsh::ser::BorshSerialize,
        u64: borsh::ser::BorshSerialize,
    {
        fn serialize<W: borsh::maybestd::io::Write>(
            &self,
            writer: &mut W,
        ) -> ::core::result::Result<(), borsh::maybestd::io::Error> {
            borsh::BorshSerialize::serialize(&self.version, writer)?;
            borsh::BorshSerialize::serialize(&self.metadata, writer)?;
            borsh::BorshSerialize::serialize(&self.nonce, writer)?;
            Ok(())
        }
    }
    impl borsh::de::BorshDeserialize for NewNFTEvent
    where
        Version: borsh::BorshDeserialize,
        MetadataArgs: borsh::BorshDeserialize,
        u64: borsh::BorshDeserialize,
    {
        fn deserialize(
            buf: &mut &[u8],
        ) -> ::core::result::Result<Self, borsh::maybestd::io::Error> {
            Ok(Self {
                version: borsh::BorshDeserialize::deserialize(buf)?,
                metadata: borsh::BorshDeserialize::deserialize(buf)?,
                nonce: borsh::BorshDeserialize::deserialize(buf)?,
            })
        }
    }
    impl anchor_lang::Event for NewNFTEvent {
        fn data(&self) -> Vec<u8> {
            let mut d = [196, 35, 157, 194, 143, 50, 170, 171].to_vec();
            d.append(&mut self.try_to_vec().unwrap());
            d
        }
    }
    impl anchor_lang::Discriminator for NewNFTEvent {
        fn discriminator() -> [u8; 8] {
            [196, 35, 157, 194, 143, 50, 170, 171]
        }
    }
    pub struct NFTDecompressionEvent {
        pub version: Version,
        pub id: Pubkey,
        pub tree_id: Pubkey,
        pub nonce: u64,
    }
    impl borsh::ser::BorshSerialize for NFTDecompressionEvent
    where
        Version: borsh::ser::BorshSerialize,
        Pubkey: borsh::ser::BorshSerialize,
        Pubkey: borsh::ser::BorshSerialize,
        u64: borsh::ser::BorshSerialize,
    {
        fn serialize<W: borsh::maybestd::io::Write>(
            &self,
            writer: &mut W,
        ) -> ::core::result::Result<(), borsh::maybestd::io::Error> {
            borsh::BorshSerialize::serialize(&self.version, writer)?;
            borsh::BorshSerialize::serialize(&self.id, writer)?;
            borsh::BorshSerialize::serialize(&self.tree_id, writer)?;
            borsh::BorshSerialize::serialize(&self.nonce, writer)?;
            Ok(())
        }
    }
    impl borsh::de::BorshDeserialize for NFTDecompressionEvent
    where
        Version: borsh::BorshDeserialize,
        Pubkey: borsh::BorshDeserialize,
        Pubkey: borsh::BorshDeserialize,
        u64: borsh::BorshDeserialize,
    {
        fn deserialize(
            buf: &mut &[u8],
        ) -> ::core::result::Result<Self, borsh::maybestd::io::Error> {
            Ok(Self {
                version: borsh::BorshDeserialize::deserialize(buf)?,
                id: borsh::BorshDeserialize::deserialize(buf)?,
                tree_id: borsh::BorshDeserialize::deserialize(buf)?,
                nonce: borsh::BorshDeserialize::deserialize(buf)?,
            })
        }
    }
    impl anchor_lang::Event for NFTDecompressionEvent {
        fn data(&self) -> Vec<u8> {
            let mut d = [255, 254, 123, 106, 237, 80, 198, 107].to_vec();
            d.append(&mut self.try_to_vec().unwrap());
            d
        }
    }
    impl anchor_lang::Discriminator for NFTDecompressionEvent {
        fn discriminator() -> [u8; 8] {
            [255, 254, 123, 106, 237, 80, 198, 107]
        }
    }
}
pub mod utils {
    use {
        crate::error::BubblegumError,
        crate::state::metaplex_adapter::MetadataArgs,
        crate::ASSET_PREFIX,
        anchor_lang::{
            prelude::*, solana_program::program_memory::sol_memcmp,
            solana_program::pubkey::PUBKEY_BYTES,
        },
        gummyroll::Node,
    };
    /// Assert that the provided MetadataArgs are compatible with MPL `Data`
    pub fn assert_metadata_is_mpl_compatible(metadata: &MetadataArgs) -> Result<()> {
        if metadata.name.len() > mpl_token_metadata::state::MAX_NAME_LENGTH {
            return Err(BubblegumError::MetadataNameTooLong.into());
        }
        if metadata.symbol.len() > mpl_token_metadata::state::MAX_SYMBOL_LENGTH {
            return Err(BubblegumError::MetadataSymbolTooLong.into());
        }
        if metadata.uri.len() > mpl_token_metadata::state::MAX_URI_LENGTH {
            return Err(BubblegumError::MetadataUriTooLong.into());
        }
        if metadata.seller_fee_basis_points > 10000 {
            return Err(BubblegumError::MetadataBasisPointsTooHigh.into());
        }
        if metadata.creators.len() > 0 {
            if metadata.creators.len() > mpl_token_metadata::state::MAX_CREATOR_LIMIT - 1 {
                return Err(BubblegumError::CreatorsTooLong.into());
            }
            let mut total: u8 = 0;
            for i in 0..metadata.creators.len() {
                let creator = metadata.creators[i];
                for iter in metadata.creators.iter().skip(i + 1) {
                    if iter.address == creator.address {
                        return Err(BubblegumError::DuplicateCreatorAddress.into());
                    }
                }
                total = total
                    .checked_add(creator.share)
                    .ok_or(BubblegumError::CreatorShareTotalMustBe100)?;
            }
            if total != 100 {
                return Err(BubblegumError::CreatorShareTotalMustBe100.into());
            }
        }
        Ok(())
    }
    pub fn replace_leaf<'info>(
        seed: &Pubkey,
        bump: u8,
        gummyroll_program: &AccountInfo<'info>,
        authority: &AccountInfo<'info>,
        merkle_roll: &AccountInfo<'info>,
        candy_wrapper: &AccountInfo<'info>,
        remaining_accounts: &[AccountInfo<'info>],
        root_node: Node,
        previous_leaf: Node,
        new_leaf: Node,
        index: u32,
    ) -> Result<()> {
        let seeds = &[seed.as_ref(), &[bump]];
        let authority_pda_signer = &[&seeds[..]];
        let cpi_ctx = CpiContext::new_with_signer(
            gummyroll_program.clone(),
            gummyroll::cpi::accounts::Modify {
                authority: authority.clone(),
                merkle_roll: merkle_roll.clone(),
                candy_wrapper: candy_wrapper.clone(),
            },
            authority_pda_signer,
        )
        .with_remaining_accounts(remaining_accounts.to_vec());
        gummyroll::cpi::replace_leaf(cpi_ctx, root_node, previous_leaf, new_leaf, index)
    }
    pub fn append_leaf<'info>(
        seed: &Pubkey,
        bump: u8,
        gummyroll_program: &AccountInfo<'info>,
        authority: &AccountInfo<'info>,
        merkle_roll: &AccountInfo<'info>,
        candy_wrapper: &AccountInfo<'info>,
        leaf_node: Node,
    ) -> Result<()> {
        let seeds = &[seed.as_ref(), &[bump]];
        let authority_pda_signer = &[&seeds[..]];
        let cpi_ctx = CpiContext::new_with_signer(
            gummyroll_program.clone(),
            gummyroll::cpi::accounts::Modify {
                authority: authority.clone(),
                merkle_roll: merkle_roll.clone(),
                candy_wrapper: candy_wrapper.clone(),
            },
            authority_pda_signer,
        );
        gummyroll::cpi::append(cpi_ctx, leaf_node)
    }
    pub fn cmp_pubkeys(a: &Pubkey, b: &Pubkey) -> bool {
        sol_memcmp(a.as_ref(), b.as_ref(), PUBKEY_BYTES) == 0
    }
    pub fn cmp_bytes(a: &[u8], b: &[u8], size: usize) -> bool {
        sol_memcmp(a.as_ref(), b.as_ref(), size) == 0
    }
    pub fn assert_pubkey_equal(
        a: &Pubkey,
        b: &Pubkey,
        error: Option<anchor_lang::error::Error>,
    ) -> Result<()> {
        if !cmp_pubkeys(a, b) {
            if error.is_some() {
                let err = error.unwrap();
                return Err(err);
            }
            return Err(BubblegumError::PublicKeyMismatch.into());
        } else {
            Ok(())
        }
    }
    pub fn assert_derivation(
        program_id: &Pubkey,
        account: &AccountInfo,
        path: &[&[u8]],
        error: Option<error::Error>,
    ) -> Result<u8> {
        let (key, bump) = Pubkey::find_program_address(&path, program_id);
        if !cmp_pubkeys(&key, account.key) {
            if error.is_some() {
                let err = error.unwrap();
                ::solana_program::log::sol_log(&{
                    let res = ::alloc::fmt::format(::core::fmt::Arguments::new_v1(
                        &["Derivation "],
                        &[::core::fmt::ArgumentV1::new_debug(&err)],
                    ));
                    res
                });
                return Err(err.into());
            }
            ::solana_program::log::sol_log("DerivedKeyInvalid");
            return Err(ProgramError::InvalidInstructionData.into());
        }
        Ok(bump)
    }
    pub fn assert_owned_by(account: &AccountInfo, owner: &Pubkey) -> Result<()> {
        if !cmp_pubkeys(account.owner, owner) {
            Err(ProgramError::IllegalOwner.into())
        } else {
            Ok(())
        }
    }
    pub fn get_asset_id(tree_id: &Pubkey, nonce: u64) -> Pubkey {
        Pubkey::find_program_address(
            &[
                ASSET_PREFIX.as_ref(),
                tree_id.as_ref(),
                &nonce.to_le_bytes(),
            ],
            &crate::id(),
        )
        .0
    }
}
/// The static program ID
pub static ID: anchor_lang::solana_program::pubkey::Pubkey =
    anchor_lang::solana_program::pubkey::Pubkey::new_from_array([
        152u8, 139u8, 128u8, 235u8, 121u8, 53u8, 40u8, 105u8, 178u8, 36u8, 116u8, 95u8, 89u8,
        221u8, 191u8, 138u8, 38u8, 88u8, 202u8, 19u8, 220u8, 104u8, 129u8, 33u8, 38u8, 53u8, 28u8,
        174u8, 7u8, 193u8, 165u8, 165u8,
    ]);
/// Confirms that a given pubkey is equivalent to the program ID
pub fn check_id(id: &anchor_lang::solana_program::pubkey::Pubkey) -> bool {
    id == &ID
}
/// Returns the program ID
pub fn id() -> anchor_lang::solana_program::pubkey::Pubkey {
    ID
}
pub struct CreateTree<'info> {
    # [account (init , seeds = [merkle_slab . key () . as_ref ()] , payer = payer , space = TREE_AUTHORITY_SIZE , bump ,)]
    pub authority: Account<'info, TreeConfig>,
    #[account(mut)]
    pub payer: Signer<'info>,
    pub tree_creator: Signer<'info>,
    pub candy_wrapper: Program<'info, CandyWrapper>,
    pub system_program: Program<'info, System>,
    pub gummyroll_program: Program<'info, Gummyroll>,
    #[account(zero)]
    /// CHECK: This account must be all zeros
    pub merkle_slab: UncheckedAccount<'info>,
}
#[automatically_derived]
impl<'info> anchor_lang::Accounts<'info> for CreateTree<'info>
where
    'info: 'info,
{
    #[inline(never)]
    fn try_accounts(
        program_id: &anchor_lang::solana_program::pubkey::Pubkey,
        accounts: &mut &[anchor_lang::solana_program::account_info::AccountInfo<'info>],
        ix_data: &[u8],
        __bumps: &mut std::collections::BTreeMap<String, u8>,
        __reallocs: &mut std::collections::BTreeSet<anchor_lang::solana_program::pubkey::Pubkey>,
    ) -> anchor_lang::Result<Self> {
        if accounts.is_empty() {
            return Err(anchor_lang::error::ErrorCode::AccountNotEnoughKeys.into());
        }
        let authority = &accounts[0];
        *accounts = &accounts[1..];
        let payer: Signer =
            anchor_lang::Accounts::try_accounts(program_id, accounts, ix_data, __bumps, __reallocs)
                .map_err(|e| e.with_account_name("payer"))?;
        let tree_creator: Signer =
            anchor_lang::Accounts::try_accounts(program_id, accounts, ix_data, __bumps, __reallocs)
                .map_err(|e| e.with_account_name("tree_creator"))?;
        let candy_wrapper: anchor_lang::accounts::program::Program<CandyWrapper> =
            anchor_lang::Accounts::try_accounts(program_id, accounts, ix_data, __bumps, __reallocs)
                .map_err(|e| e.with_account_name("candy_wrapper"))?;
        let system_program: anchor_lang::accounts::program::Program<System> =
            anchor_lang::Accounts::try_accounts(program_id, accounts, ix_data, __bumps, __reallocs)
                .map_err(|e| e.with_account_name("system_program"))?;
        let gummyroll_program: anchor_lang::accounts::program::Program<Gummyroll> =
            anchor_lang::Accounts::try_accounts(program_id, accounts, ix_data, __bumps, __reallocs)
                .map_err(|e| e.with_account_name("gummyroll_program"))?;
        if accounts.is_empty() {
            return Err(anchor_lang::error::ErrorCode::AccountNotEnoughKeys.into());
        }
        let merkle_slab = &accounts[0];
        *accounts = &accounts[1..];
        let __anchor_rent = Rent::get()?;
        let (__pda_address, __bump) =
            Pubkey::find_program_address(&[merkle_slab.key().as_ref()], program_id);
        __bumps.insert("authority".to_string(), __bump);
        let authority = {
            let actual_field = authority.to_account_info();
            let actual_owner = actual_field.owner;
            let space = TREE_AUTHORITY_SIZE;
            let pa: anchor_lang::accounts::account::Account<TreeConfig> =
                if !false || actual_owner == &anchor_lang::solana_program::system_program::ID {
                    let payer = payer.to_account_info();
                    let __current_lamports = authority.lamports();
                    if __current_lamports == 0 {
                        let lamports = __anchor_rent.minimum_balance(space);
                        let cpi_accounts = anchor_lang::system_program::CreateAccount {
                            from: payer.to_account_info(),
                            to: authority.to_account_info(),
                        };
                        let cpi_context = anchor_lang::context::CpiContext::new(
                            system_program.to_account_info(),
                            cpi_accounts,
                        );
                        anchor_lang::system_program::create_account(
                            cpi_context
                                .with_signer(&[&[merkle_slab.key().as_ref(), &[__bump][..]][..]]),
                            lamports,
                            space as u64,
                            program_id,
                        )?;
                    } else {
                        let required_lamports = __anchor_rent
                            .minimum_balance(space)
                            .max(1)
                            .saturating_sub(__current_lamports);
                        if required_lamports > 0 {
                            let cpi_accounts = anchor_lang::system_program::Transfer {
                                from: payer.to_account_info(),
                                to: authority.to_account_info(),
                            };
                            let cpi_context = anchor_lang::context::CpiContext::new(
                                system_program.to_account_info(),
                                cpi_accounts,
                            );
                            anchor_lang::system_program::transfer(cpi_context, required_lamports)?;
                        }
                        let cpi_accounts = anchor_lang::system_program::Allocate {
                            account_to_allocate: authority.to_account_info(),
                        };
                        let cpi_context = anchor_lang::context::CpiContext::new(
                            system_program.to_account_info(),
                            cpi_accounts,
                        );
                        anchor_lang::system_program::allocate(
                            cpi_context
                                .with_signer(&[&[merkle_slab.key().as_ref(), &[__bump][..]][..]]),
                            space as u64,
                        )?;
                        let cpi_accounts = anchor_lang::system_program::Assign {
                            account_to_assign: authority.to_account_info(),
                        };
                        let cpi_context = anchor_lang::context::CpiContext::new(
                            system_program.to_account_info(),
                            cpi_accounts,
                        );
                        anchor_lang::system_program::assign(
                            cpi_context
                                .with_signer(&[&[merkle_slab.key().as_ref(), &[__bump][..]][..]]),
                            program_id,
                        )?;
                    }
                    anchor_lang::accounts::account::Account::try_from_unchecked(&authority)
                        .map_err(|e| e.with_account_name("authority"))?
                } else {
                    anchor_lang::accounts::account::Account::try_from(&authority)
                        .map_err(|e| e.with_account_name("authority"))?
                };
            if false {
                if space != actual_field.data_len() {
                    return Err(anchor_lang::error::Error::from(
                        anchor_lang::error::ErrorCode::ConstraintSpace,
                    )
                    .with_account_name("authority")
                    .with_values((space, actual_field.data_len())));
                }
                if actual_owner != program_id {
                    return Err(anchor_lang::error::Error::from(
                        anchor_lang::error::ErrorCode::ConstraintOwner,
                    )
                    .with_account_name("authority")
                    .with_pubkeys((*actual_owner, *program_id)));
                }
                {
                    let required_lamports = __anchor_rent.minimum_balance(space);
                    if pa.to_account_info().lamports() < required_lamports {
                        return Err(anchor_lang::error::Error::from(
                            anchor_lang::error::ErrorCode::ConstraintRentExempt,
                        )
                        .with_account_name("authority"));
                    }
                }
            }
            pa
        };
        if authority.key() != __pda_address {
            return Err(anchor_lang::error::Error::from(
                anchor_lang::error::ErrorCode::ConstraintSeeds,
            )
            .with_account_name("authority")
            .with_pubkeys((authority.key(), __pda_address)));
        }
        if !authority.to_account_info().is_writable {
            return Err(anchor_lang::error::Error::from(
                anchor_lang::error::ErrorCode::ConstraintMut,
            )
            .with_account_name("authority"));
        }
        if !__anchor_rent.is_exempt(
            authority.to_account_info().lamports(),
            authority.to_account_info().try_data_len()?,
        ) {
            return Err(anchor_lang::error::Error::from(
                anchor_lang::error::ErrorCode::ConstraintRentExempt,
            )
            .with_account_name("authority"));
        }
        if !payer.to_account_info().is_writable {
            return Err(anchor_lang::error::Error::from(
                anchor_lang::error::ErrorCode::ConstraintMut,
            )
            .with_account_name("payer"));
        }
        let __anchor_rent = Rent::get()?;
        let merkle_slab: UncheckedAccount = {
            let mut __data: &[u8] = &merkle_slab.try_borrow_data()?;
            let mut __disc_bytes = [0u8; 8];
            __disc_bytes.copy_from_slice(&__data[..8]);
            let __discriminator = u64::from_le_bytes(__disc_bytes);
            if __discriminator != 0 {
                return Err(anchor_lang::error::Error::from(
                    anchor_lang::error::ErrorCode::ConstraintZero,
                )
                .with_account_name("merkle_slab"));
            }
            UncheckedAccount::try_from(merkle_slab.to_account_info())
        };
        if !merkle_slab.to_account_info().is_writable {
            return Err(anchor_lang::error::Error::from(
                anchor_lang::error::ErrorCode::ConstraintMut,
            )
            .with_account_name("merkle_slab"));
        }
        if !__anchor_rent.is_exempt(
            merkle_slab.to_account_info().lamports(),
            merkle_slab.to_account_info().try_data_len()?,
        ) {
            return Err(anchor_lang::error::Error::from(
                anchor_lang::error::ErrorCode::ConstraintRentExempt,
            )
            .with_account_name("merkle_slab"));
        }
        Ok(CreateTree {
            authority,
            payer,
            tree_creator,
            candy_wrapper,
            system_program,
            gummyroll_program,
            merkle_slab,
        })
    }
}
#[automatically_derived]
impl<'info> anchor_lang::ToAccountInfos<'info> for CreateTree<'info>
where
    'info: 'info,
{
    fn to_account_infos(
        &self,
    ) -> Vec<anchor_lang::solana_program::account_info::AccountInfo<'info>> {
        let mut account_infos = ::alloc::vec::Vec::new();
        account_infos.extend(self.authority.to_account_infos());
        account_infos.extend(self.payer.to_account_infos());
        account_infos.extend(self.tree_creator.to_account_infos());
        account_infos.extend(self.candy_wrapper.to_account_infos());
        account_infos.extend(self.system_program.to_account_infos());
        account_infos.extend(self.gummyroll_program.to_account_infos());
        account_infos.extend(self.merkle_slab.to_account_infos());
        account_infos
    }
}
#[automatically_derived]
impl<'info> anchor_lang::ToAccountMetas for CreateTree<'info> {
    fn to_account_metas(
        &self,
        is_signer: Option<bool>,
    ) -> Vec<anchor_lang::solana_program::instruction::AccountMeta> {
        let mut account_metas = ::alloc::vec::Vec::new();
        account_metas.extend(self.authority.to_account_metas(None));
        account_metas.extend(self.payer.to_account_metas(None));
        account_metas.extend(self.tree_creator.to_account_metas(None));
        account_metas.extend(self.candy_wrapper.to_account_metas(None));
        account_metas.extend(self.system_program.to_account_metas(None));
        account_metas.extend(self.gummyroll_program.to_account_metas(None));
        account_metas.extend(self.merkle_slab.to_account_metas(None));
        account_metas
    }
}
#[automatically_derived]
impl<'info> anchor_lang::AccountsExit<'info> for CreateTree<'info>
where
    'info: 'info,
{
    fn exit(
        &self,
        program_id: &anchor_lang::solana_program::pubkey::Pubkey,
    ) -> anchor_lang::Result<()> {
        anchor_lang::AccountsExit::exit(&self.authority, program_id)
            .map_err(|e| e.with_account_name("authority"))?;
        anchor_lang::AccountsExit::exit(&self.payer, program_id)
            .map_err(|e| e.with_account_name("payer"))?;
        anchor_lang::AccountsExit::exit(&self.merkle_slab, program_id)
            .map_err(|e| e.with_account_name("merkle_slab"))?;
        Ok(())
    }
}
/// An internal, Anchor generated module. This is used (as an
/// implementation detail), to generate a struct for a given
/// `#[derive(Accounts)]` implementation, where each field is a Pubkey,
/// instead of an `AccountInfo`. This is useful for clients that want
/// to generate a list of accounts, without explicitly knowing the
/// order all the fields should be in.
///
/// To access the struct in this module, one should use the sibling
/// `accounts` module (also generated), which re-exports this.
pub(crate) mod __client_accounts_create_tree {
    use super::*;
    use anchor_lang::prelude::borsh;
    /// Generated client accounts for [`CreateTree`].
    pub struct CreateTree {
        pub authority: anchor_lang::solana_program::pubkey::Pubkey,
        pub payer: anchor_lang::solana_program::pubkey::Pubkey,
        pub tree_creator: anchor_lang::solana_program::pubkey::Pubkey,
        pub candy_wrapper: anchor_lang::solana_program::pubkey::Pubkey,
        pub system_program: anchor_lang::solana_program::pubkey::Pubkey,
        pub gummyroll_program: anchor_lang::solana_program::pubkey::Pubkey,
        pub merkle_slab: anchor_lang::solana_program::pubkey::Pubkey,
    }
    impl borsh::ser::BorshSerialize for CreateTree
    where
        anchor_lang::solana_program::pubkey::Pubkey: borsh::ser::BorshSerialize,
        anchor_lang::solana_program::pubkey::Pubkey: borsh::ser::BorshSerialize,
        anchor_lang::solana_program::pubkey::Pubkey: borsh::ser::BorshSerialize,
        anchor_lang::solana_program::pubkey::Pubkey: borsh::ser::BorshSerialize,
        anchor_lang::solana_program::pubkey::Pubkey: borsh::ser::BorshSerialize,
        anchor_lang::solana_program::pubkey::Pubkey: borsh::ser::BorshSerialize,
        anchor_lang::solana_program::pubkey::Pubkey: borsh::ser::BorshSerialize,
    {
        fn serialize<W: borsh::maybestd::io::Write>(
            &self,
            writer: &mut W,
        ) -> ::core::result::Result<(), borsh::maybestd::io::Error> {
            borsh::BorshSerialize::serialize(&self.authority, writer)?;
            borsh::BorshSerialize::serialize(&self.payer, writer)?;
            borsh::BorshSerialize::serialize(&self.tree_creator, writer)?;
            borsh::BorshSerialize::serialize(&self.candy_wrapper, writer)?;
            borsh::BorshSerialize::serialize(&self.system_program, writer)?;
            borsh::BorshSerialize::serialize(&self.gummyroll_program, writer)?;
            borsh::BorshSerialize::serialize(&self.merkle_slab, writer)?;
            Ok(())
        }
    }
    #[automatically_derived]
    impl anchor_lang::ToAccountMetas for CreateTree {
        fn to_account_metas(
            &self,
            is_signer: Option<bool>,
        ) -> Vec<anchor_lang::solana_program::instruction::AccountMeta> {
            let mut account_metas = ::alloc::vec::Vec::new();
            account_metas.push(anchor_lang::solana_program::instruction::AccountMeta::new(
                self.authority,
                false,
            ));
            account_metas.push(anchor_lang::solana_program::instruction::AccountMeta::new(
                self.payer, true,
            ));
            account_metas.push(
                anchor_lang::solana_program::instruction::AccountMeta::new_readonly(
                    self.tree_creator,
                    true,
                ),
            );
            account_metas.push(
                anchor_lang::solana_program::instruction::AccountMeta::new_readonly(
                    self.candy_wrapper,
                    false,
                ),
            );
            account_metas.push(
                anchor_lang::solana_program::instruction::AccountMeta::new_readonly(
                    self.system_program,
                    false,
                ),
            );
            account_metas.push(
                anchor_lang::solana_program::instruction::AccountMeta::new_readonly(
                    self.gummyroll_program,
                    false,
                ),
            );
            account_metas.push(anchor_lang::solana_program::instruction::AccountMeta::new(
                self.merkle_slab,
                false,
            ));
            account_metas
        }
    }
}
/// An internal, Anchor generated module. This is used (as an
/// implementation detail), to generate a CPI struct for a given
/// `#[derive(Accounts)]` implementation, where each field is an
/// AccountInfo.
///
/// To access the struct in this module, one should use the sibling
/// [`cpi::accounts`] module (also generated), which re-exports this.
pub(crate) mod __cpi_client_accounts_create_tree {
    use super::*;
    /// Generated CPI struct of the accounts for [`CreateTree`].
    pub struct CreateTree<'info> {
        pub authority: anchor_lang::solana_program::account_info::AccountInfo<'info>,
        pub payer: anchor_lang::solana_program::account_info::AccountInfo<'info>,
        pub tree_creator: anchor_lang::solana_program::account_info::AccountInfo<'info>,
        pub candy_wrapper: anchor_lang::solana_program::account_info::AccountInfo<'info>,
        pub system_program: anchor_lang::solana_program::account_info::AccountInfo<'info>,
        pub gummyroll_program: anchor_lang::solana_program::account_info::AccountInfo<'info>,
        pub merkle_slab: anchor_lang::solana_program::account_info::AccountInfo<'info>,
    }
    #[automatically_derived]
    impl<'info> anchor_lang::ToAccountMetas for CreateTree<'info> {
        fn to_account_metas(
            &self,
            is_signer: Option<bool>,
        ) -> Vec<anchor_lang::solana_program::instruction::AccountMeta> {
            let mut account_metas = ::alloc::vec::Vec::new();
            account_metas.push(anchor_lang::solana_program::instruction::AccountMeta::new(
                anchor_lang::Key::key(&self.authority),
                false,
            ));
            account_metas.push(anchor_lang::solana_program::instruction::AccountMeta::new(
                anchor_lang::Key::key(&self.payer),
                true,
            ));
            account_metas.push(
                anchor_lang::solana_program::instruction::AccountMeta::new_readonly(
                    anchor_lang::Key::key(&self.tree_creator),
                    true,
                ),
            );
            account_metas.push(
                anchor_lang::solana_program::instruction::AccountMeta::new_readonly(
                    anchor_lang::Key::key(&self.candy_wrapper),
                    false,
                ),
            );
            account_metas.push(
                anchor_lang::solana_program::instruction::AccountMeta::new_readonly(
                    anchor_lang::Key::key(&self.system_program),
                    false,
                ),
            );
            account_metas.push(
                anchor_lang::solana_program::instruction::AccountMeta::new_readonly(
                    anchor_lang::Key::key(&self.gummyroll_program),
                    false,
                ),
            );
            account_metas.push(anchor_lang::solana_program::instruction::AccountMeta::new(
                anchor_lang::Key::key(&self.merkle_slab),
                false,
            ));
            account_metas
        }
    }
    #[automatically_derived]
    impl<'info> anchor_lang::ToAccountInfos<'info> for CreateTree<'info> {
        fn to_account_infos(
            &self,
        ) -> Vec<anchor_lang::solana_program::account_info::AccountInfo<'info>> {
            let mut account_infos = ::alloc::vec::Vec::new();
            account_infos.push(anchor_lang::ToAccountInfo::to_account_info(&self.authority));
            account_infos.push(anchor_lang::ToAccountInfo::to_account_info(&self.payer));
            account_infos.push(anchor_lang::ToAccountInfo::to_account_info(
                &self.tree_creator,
            ));
            account_infos.push(anchor_lang::ToAccountInfo::to_account_info(
                &self.candy_wrapper,
            ));
            account_infos.push(anchor_lang::ToAccountInfo::to_account_info(
                &self.system_program,
            ));
            account_infos.push(anchor_lang::ToAccountInfo::to_account_info(
                &self.gummyroll_program,
            ));
            account_infos.push(anchor_lang::ToAccountInfo::to_account_info(
                &self.merkle_slab,
            ));
            account_infos
        }
    }
}
pub struct MintV1<'info> {
    /// CHECK: This is checked in the instruction. Must be signer if it is not equal to the `authority`
    pub mint_authority: AccountInfo<'info>,
    # [account (mut , seeds = [merkle_slab . key () . as_ref ()] , bump ,)]
    pub authority: Account<'info, TreeConfig>,
    pub candy_wrapper: Program<'info, CandyWrapper>,
    pub gummyroll_program: Program<'info, Gummyroll>,
    /// CHECK: This account is neither written to nor read from.
    pub owner: AccountInfo<'info>,
    /// CHECK: This account is neither written to nor read from.
    pub delegate: AccountInfo<'info>,
    # [account (mut , seeds = [merkle_slab . key () . as_ref () , mint_authority . key () . as_ref ()] , bump ,)]
    pub mint_authority_request: Account<'info, MintRequest>,
    #[account(mut)]
    /// CHECK: unsafe
    pub merkle_slab: UncheckedAccount<'info>,
}
#[automatically_derived]
impl<'info> anchor_lang::Accounts<'info> for MintV1<'info>
where
    'info: 'info,
{
    #[inline(never)]
    fn try_accounts(
        program_id: &anchor_lang::solana_program::pubkey::Pubkey,
        accounts: &mut &[anchor_lang::solana_program::account_info::AccountInfo<'info>],
        ix_data: &[u8],
        __bumps: &mut std::collections::BTreeMap<String, u8>,
        __reallocs: &mut std::collections::BTreeSet<anchor_lang::solana_program::pubkey::Pubkey>,
    ) -> anchor_lang::Result<Self> {
        let mint_authority: AccountInfo =
            anchor_lang::Accounts::try_accounts(program_id, accounts, ix_data, __bumps, __reallocs)
                .map_err(|e| e.with_account_name("mint_authority"))?;
        let authority: anchor_lang::accounts::account::Account<TreeConfig> =
            anchor_lang::Accounts::try_accounts(program_id, accounts, ix_data, __bumps, __reallocs)
                .map_err(|e| e.with_account_name("authority"))?;
        let candy_wrapper: anchor_lang::accounts::program::Program<CandyWrapper> =
            anchor_lang::Accounts::try_accounts(program_id, accounts, ix_data, __bumps, __reallocs)
                .map_err(|e| e.with_account_name("candy_wrapper"))?;
        let gummyroll_program: anchor_lang::accounts::program::Program<Gummyroll> =
            anchor_lang::Accounts::try_accounts(program_id, accounts, ix_data, __bumps, __reallocs)
                .map_err(|e| e.with_account_name("gummyroll_program"))?;
        let owner: AccountInfo =
            anchor_lang::Accounts::try_accounts(program_id, accounts, ix_data, __bumps, __reallocs)
                .map_err(|e| e.with_account_name("owner"))?;
        let delegate: AccountInfo =
            anchor_lang::Accounts::try_accounts(program_id, accounts, ix_data, __bumps, __reallocs)
                .map_err(|e| e.with_account_name("delegate"))?;
        let mint_authority_request: anchor_lang::accounts::account::Account<MintRequest> =
            anchor_lang::Accounts::try_accounts(program_id, accounts, ix_data, __bumps, __reallocs)
                .map_err(|e| e.with_account_name("mint_authority_request"))?;
        let merkle_slab: UncheckedAccount =
            anchor_lang::Accounts::try_accounts(program_id, accounts, ix_data, __bumps, __reallocs)
                .map_err(|e| e.with_account_name("merkle_slab"))?;
        let (__pda_address, __bump) =
            Pubkey::find_program_address(&[merkle_slab.key().as_ref()], &program_id);
        __bumps.insert("authority".to_string(), __bump);
        if authority.key() != __pda_address {
            return Err(anchor_lang::error::Error::from(
                anchor_lang::error::ErrorCode::ConstraintSeeds,
            )
            .with_account_name("authority")
            .with_pubkeys((authority.key(), __pda_address)));
        }
        if !authority.to_account_info().is_writable {
            return Err(anchor_lang::error::Error::from(
                anchor_lang::error::ErrorCode::ConstraintMut,
            )
            .with_account_name("authority"));
        }
        let (__pda_address, __bump) = Pubkey::find_program_address(
            &[merkle_slab.key().as_ref(), mint_authority.key().as_ref()],
            &program_id,
        );
        __bumps.insert("mint_authority_request".to_string(), __bump);
        if mint_authority_request.key() != __pda_address {
            return Err(anchor_lang::error::Error::from(
                anchor_lang::error::ErrorCode::ConstraintSeeds,
            )
            .with_account_name("mint_authority_request")
            .with_pubkeys((mint_authority_request.key(), __pda_address)));
        }
        if !mint_authority_request.to_account_info().is_writable {
            return Err(anchor_lang::error::Error::from(
                anchor_lang::error::ErrorCode::ConstraintMut,
            )
            .with_account_name("mint_authority_request"));
        }
        if !merkle_slab.to_account_info().is_writable {
            return Err(anchor_lang::error::Error::from(
                anchor_lang::error::ErrorCode::ConstraintMut,
            )
            .with_account_name("merkle_slab"));
        }
        Ok(MintV1 {
            mint_authority,
            authority,
            candy_wrapper,
            gummyroll_program,
            owner,
            delegate,
            mint_authority_request,
            merkle_slab,
        })
    }
}
#[automatically_derived]
impl<'info> anchor_lang::ToAccountInfos<'info> for MintV1<'info>
where
    'info: 'info,
{
    fn to_account_infos(
        &self,
    ) -> Vec<anchor_lang::solana_program::account_info::AccountInfo<'info>> {
        let mut account_infos = ::alloc::vec::Vec::new();
        account_infos.extend(self.mint_authority.to_account_infos());
        account_infos.extend(self.authority.to_account_infos());
        account_infos.extend(self.candy_wrapper.to_account_infos());
        account_infos.extend(self.gummyroll_program.to_account_infos());
        account_infos.extend(self.owner.to_account_infos());
        account_infos.extend(self.delegate.to_account_infos());
        account_infos.extend(self.mint_authority_request.to_account_infos());
        account_infos.extend(self.merkle_slab.to_account_infos());
        account_infos
    }
}
#[automatically_derived]
impl<'info> anchor_lang::ToAccountMetas for MintV1<'info> {
    fn to_account_metas(
        &self,
        is_signer: Option<bool>,
    ) -> Vec<anchor_lang::solana_program::instruction::AccountMeta> {
        let mut account_metas = ::alloc::vec::Vec::new();
        account_metas.extend(self.mint_authority.to_account_metas(None));
        account_metas.extend(self.authority.to_account_metas(None));
        account_metas.extend(self.candy_wrapper.to_account_metas(None));
        account_metas.extend(self.gummyroll_program.to_account_metas(None));
        account_metas.extend(self.owner.to_account_metas(None));
        account_metas.extend(self.delegate.to_account_metas(None));
        account_metas.extend(self.mint_authority_request.to_account_metas(None));
        account_metas.extend(self.merkle_slab.to_account_metas(None));
        account_metas
    }
}
#[automatically_derived]
impl<'info> anchor_lang::AccountsExit<'info> for MintV1<'info>
where
    'info: 'info,
{
    fn exit(
        &self,
        program_id: &anchor_lang::solana_program::pubkey::Pubkey,
    ) -> anchor_lang::Result<()> {
        anchor_lang::AccountsExit::exit(&self.authority, program_id)
            .map_err(|e| e.with_account_name("authority"))?;
        anchor_lang::AccountsExit::exit(&self.mint_authority_request, program_id)
            .map_err(|e| e.with_account_name("mint_authority_request"))?;
        anchor_lang::AccountsExit::exit(&self.merkle_slab, program_id)
            .map_err(|e| e.with_account_name("merkle_slab"))?;
        Ok(())
    }
}
/// An internal, Anchor generated module. This is used (as an
/// implementation detail), to generate a struct for a given
/// `#[derive(Accounts)]` implementation, where each field is a Pubkey,
/// instead of an `AccountInfo`. This is useful for clients that want
/// to generate a list of accounts, without explicitly knowing the
/// order all the fields should be in.
///
/// To access the struct in this module, one should use the sibling
/// `accounts` module (also generated), which re-exports this.
pub(crate) mod __client_accounts_mint_v1 {
    use super::*;
    use anchor_lang::prelude::borsh;
    /// Generated client accounts for [`MintV1`].
    pub struct MintV1 {
        pub mint_authority: anchor_lang::solana_program::pubkey::Pubkey,
        pub authority: anchor_lang::solana_program::pubkey::Pubkey,
        pub candy_wrapper: anchor_lang::solana_program::pubkey::Pubkey,
        pub gummyroll_program: anchor_lang::solana_program::pubkey::Pubkey,
        pub owner: anchor_lang::solana_program::pubkey::Pubkey,
        pub delegate: anchor_lang::solana_program::pubkey::Pubkey,
        pub mint_authority_request: anchor_lang::solana_program::pubkey::Pubkey,
        pub merkle_slab: anchor_lang::solana_program::pubkey::Pubkey,
    }
    impl borsh::ser::BorshSerialize for MintV1
    where
        anchor_lang::solana_program::pubkey::Pubkey: borsh::ser::BorshSerialize,
        anchor_lang::solana_program::pubkey::Pubkey: borsh::ser::BorshSerialize,
        anchor_lang::solana_program::pubkey::Pubkey: borsh::ser::BorshSerialize,
        anchor_lang::solana_program::pubkey::Pubkey: borsh::ser::BorshSerialize,
        anchor_lang::solana_program::pubkey::Pubkey: borsh::ser::BorshSerialize,
        anchor_lang::solana_program::pubkey::Pubkey: borsh::ser::BorshSerialize,
        anchor_lang::solana_program::pubkey::Pubkey: borsh::ser::BorshSerialize,
        anchor_lang::solana_program::pubkey::Pubkey: borsh::ser::BorshSerialize,
    {
        fn serialize<W: borsh::maybestd::io::Write>(
            &self,
            writer: &mut W,
        ) -> ::core::result::Result<(), borsh::maybestd::io::Error> {
            borsh::BorshSerialize::serialize(&self.mint_authority, writer)?;
            borsh::BorshSerialize::serialize(&self.authority, writer)?;
            borsh::BorshSerialize::serialize(&self.candy_wrapper, writer)?;
            borsh::BorshSerialize::serialize(&self.gummyroll_program, writer)?;
            borsh::BorshSerialize::serialize(&self.owner, writer)?;
            borsh::BorshSerialize::serialize(&self.delegate, writer)?;
            borsh::BorshSerialize::serialize(&self.mint_authority_request, writer)?;
            borsh::BorshSerialize::serialize(&self.merkle_slab, writer)?;
            Ok(())
        }
    }
    #[automatically_derived]
    impl anchor_lang::ToAccountMetas for MintV1 {
        fn to_account_metas(
            &self,
            is_signer: Option<bool>,
        ) -> Vec<anchor_lang::solana_program::instruction::AccountMeta> {
            let mut account_metas = ::alloc::vec::Vec::new();
            account_metas.push(
                anchor_lang::solana_program::instruction::AccountMeta::new_readonly(
                    self.mint_authority,
                    false,
                ),
            );
            account_metas.push(anchor_lang::solana_program::instruction::AccountMeta::new(
                self.authority,
                false,
            ));
            account_metas.push(
                anchor_lang::solana_program::instruction::AccountMeta::new_readonly(
                    self.candy_wrapper,
                    false,
                ),
            );
            account_metas.push(
                anchor_lang::solana_program::instruction::AccountMeta::new_readonly(
                    self.gummyroll_program,
                    false,
                ),
            );
            account_metas.push(
                anchor_lang::solana_program::instruction::AccountMeta::new_readonly(
                    self.owner, false,
                ),
            );
            account_metas.push(
                anchor_lang::solana_program::instruction::AccountMeta::new_readonly(
                    self.delegate,
                    false,
                ),
            );
            account_metas.push(anchor_lang::solana_program::instruction::AccountMeta::new(
                self.mint_authority_request,
                false,
            ));
            account_metas.push(anchor_lang::solana_program::instruction::AccountMeta::new(
                self.merkle_slab,
                false,
            ));
            account_metas
        }
    }
}
/// An internal, Anchor generated module. This is used (as an
/// implementation detail), to generate a CPI struct for a given
/// `#[derive(Accounts)]` implementation, where each field is an
/// AccountInfo.
///
/// To access the struct in this module, one should use the sibling
/// [`cpi::accounts`] module (also generated), which re-exports this.
pub(crate) mod __cpi_client_accounts_mint_v1 {
    use super::*;
    /// Generated CPI struct of the accounts for [`MintV1`].
    pub struct MintV1<'info> {
        pub mint_authority: anchor_lang::solana_program::account_info::AccountInfo<'info>,
        pub authority: anchor_lang::solana_program::account_info::AccountInfo<'info>,
        pub candy_wrapper: anchor_lang::solana_program::account_info::AccountInfo<'info>,
        pub gummyroll_program: anchor_lang::solana_program::account_info::AccountInfo<'info>,
        pub owner: anchor_lang::solana_program::account_info::AccountInfo<'info>,
        pub delegate: anchor_lang::solana_program::account_info::AccountInfo<'info>,
        pub mint_authority_request: anchor_lang::solana_program::account_info::AccountInfo<'info>,
        pub merkle_slab: anchor_lang::solana_program::account_info::AccountInfo<'info>,
    }
    #[automatically_derived]
    impl<'info> anchor_lang::ToAccountMetas for MintV1<'info> {
        fn to_account_metas(
            &self,
            is_signer: Option<bool>,
        ) -> Vec<anchor_lang::solana_program::instruction::AccountMeta> {
            let mut account_metas = ::alloc::vec::Vec::new();
            account_metas.push(
                anchor_lang::solana_program::instruction::AccountMeta::new_readonly(
                    anchor_lang::Key::key(&self.mint_authority),
                    false,
                ),
            );
            account_metas.push(anchor_lang::solana_program::instruction::AccountMeta::new(
                anchor_lang::Key::key(&self.authority),
                false,
            ));
            account_metas.push(
                anchor_lang::solana_program::instruction::AccountMeta::new_readonly(
                    anchor_lang::Key::key(&self.candy_wrapper),
                    false,
                ),
            );
            account_metas.push(
                anchor_lang::solana_program::instruction::AccountMeta::new_readonly(
                    anchor_lang::Key::key(&self.gummyroll_program),
                    false,
                ),
            );
            account_metas.push(
                anchor_lang::solana_program::instruction::AccountMeta::new_readonly(
                    anchor_lang::Key::key(&self.owner),
                    false,
                ),
            );
            account_metas.push(
                anchor_lang::solana_program::instruction::AccountMeta::new_readonly(
                    anchor_lang::Key::key(&self.delegate),
                    false,
                ),
            );
            account_metas.push(anchor_lang::solana_program::instruction::AccountMeta::new(
                anchor_lang::Key::key(&self.mint_authority_request),
                false,
            ));
            account_metas.push(anchor_lang::solana_program::instruction::AccountMeta::new(
                anchor_lang::Key::key(&self.merkle_slab),
                false,
            ));
            account_metas
        }
    }
    #[automatically_derived]
    impl<'info> anchor_lang::ToAccountInfos<'info> for MintV1<'info> {
        fn to_account_infos(
            &self,
        ) -> Vec<anchor_lang::solana_program::account_info::AccountInfo<'info>> {
            let mut account_infos = ::alloc::vec::Vec::new();
            account_infos.push(anchor_lang::ToAccountInfo::to_account_info(
                &self.mint_authority,
            ));
            account_infos.push(anchor_lang::ToAccountInfo::to_account_info(&self.authority));
            account_infos.push(anchor_lang::ToAccountInfo::to_account_info(
                &self.candy_wrapper,
            ));
            account_infos.push(anchor_lang::ToAccountInfo::to_account_info(
                &self.gummyroll_program,
            ));
            account_infos.push(anchor_lang::ToAccountInfo::to_account_info(&self.owner));
            account_infos.push(anchor_lang::ToAccountInfo::to_account_info(&self.delegate));
            account_infos.push(anchor_lang::ToAccountInfo::to_account_info(
                &self.mint_authority_request,
            ));
            account_infos.push(anchor_lang::ToAccountInfo::to_account_info(
                &self.merkle_slab,
            ));
            account_infos
        }
    }
}
pub struct Burn<'info> {
    # [account (seeds = [merkle_slab . key () . as_ref ()] , bump ,)]
    pub authority: Account<'info, TreeConfig>,
    pub candy_wrapper: Program<'info, CandyWrapper>,
    pub gummyroll_program: Program<'info, Gummyroll>,
    /// CHECK: This account is checked in the instruction
    pub owner: UncheckedAccount<'info>,
    /// CHECK: This account is checked in the instruction
    pub delegate: UncheckedAccount<'info>,
    #[account(mut)]
    /// CHECK: This account is modified in the downstream program
    pub merkle_slab: UncheckedAccount<'info>,
}
#[automatically_derived]
impl<'info> anchor_lang::Accounts<'info> for Burn<'info>
where
    'info: 'info,
{
    #[inline(never)]
    fn try_accounts(
        program_id: &anchor_lang::solana_program::pubkey::Pubkey,
        accounts: &mut &[anchor_lang::solana_program::account_info::AccountInfo<'info>],
        ix_data: &[u8],
        __bumps: &mut std::collections::BTreeMap<String, u8>,
        __reallocs: &mut std::collections::BTreeSet<anchor_lang::solana_program::pubkey::Pubkey>,
    ) -> anchor_lang::Result<Self> {
        let authority: anchor_lang::accounts::account::Account<TreeConfig> =
            anchor_lang::Accounts::try_accounts(program_id, accounts, ix_data, __bumps, __reallocs)
                .map_err(|e| e.with_account_name("authority"))?;
        let candy_wrapper: anchor_lang::accounts::program::Program<CandyWrapper> =
            anchor_lang::Accounts::try_accounts(program_id, accounts, ix_data, __bumps, __reallocs)
                .map_err(|e| e.with_account_name("candy_wrapper"))?;
        let gummyroll_program: anchor_lang::accounts::program::Program<Gummyroll> =
            anchor_lang::Accounts::try_accounts(program_id, accounts, ix_data, __bumps, __reallocs)
                .map_err(|e| e.with_account_name("gummyroll_program"))?;
        let owner: UncheckedAccount =
            anchor_lang::Accounts::try_accounts(program_id, accounts, ix_data, __bumps, __reallocs)
                .map_err(|e| e.with_account_name("owner"))?;
        let delegate: UncheckedAccount =
            anchor_lang::Accounts::try_accounts(program_id, accounts, ix_data, __bumps, __reallocs)
                .map_err(|e| e.with_account_name("delegate"))?;
        let merkle_slab: UncheckedAccount =
            anchor_lang::Accounts::try_accounts(program_id, accounts, ix_data, __bumps, __reallocs)
                .map_err(|e| e.with_account_name("merkle_slab"))?;
        let (__pda_address, __bump) =
            Pubkey::find_program_address(&[merkle_slab.key().as_ref()], &program_id);
        __bumps.insert("authority".to_string(), __bump);
        if authority.key() != __pda_address {
            return Err(anchor_lang::error::Error::from(
                anchor_lang::error::ErrorCode::ConstraintSeeds,
            )
            .with_account_name("authority")
            .with_pubkeys((authority.key(), __pda_address)));
        }
        if !merkle_slab.to_account_info().is_writable {
            return Err(anchor_lang::error::Error::from(
                anchor_lang::error::ErrorCode::ConstraintMut,
            )
            .with_account_name("merkle_slab"));
        }
        Ok(Burn {
            authority,
            candy_wrapper,
            gummyroll_program,
            owner,
            delegate,
            merkle_slab,
        })
    }
}
#[automatically_derived]
impl<'info> anchor_lang::ToAccountInfos<'info> for Burn<'info>
where
    'info: 'info,
{
    fn to_account_infos(
        &self,
    ) -> Vec<anchor_lang::solana_program::account_info::AccountInfo<'info>> {
        let mut account_infos = ::alloc::vec::Vec::new();
        account_infos.extend(self.authority.to_account_infos());
        account_infos.extend(self.candy_wrapper.to_account_infos());
        account_infos.extend(self.gummyroll_program.to_account_infos());
        account_infos.extend(self.owner.to_account_infos());
        account_infos.extend(self.delegate.to_account_infos());
        account_infos.extend(self.merkle_slab.to_account_infos());
        account_infos
    }
}
#[automatically_derived]
impl<'info> anchor_lang::ToAccountMetas for Burn<'info> {
    fn to_account_metas(
        &self,
        is_signer: Option<bool>,
    ) -> Vec<anchor_lang::solana_program::instruction::AccountMeta> {
        let mut account_metas = ::alloc::vec::Vec::new();
        account_metas.extend(self.authority.to_account_metas(None));
        account_metas.extend(self.candy_wrapper.to_account_metas(None));
        account_metas.extend(self.gummyroll_program.to_account_metas(None));
        account_metas.extend(self.owner.to_account_metas(None));
        account_metas.extend(self.delegate.to_account_metas(None));
        account_metas.extend(self.merkle_slab.to_account_metas(None));
        account_metas
    }
}
#[automatically_derived]
impl<'info> anchor_lang::AccountsExit<'info> for Burn<'info>
where
    'info: 'info,
{
    fn exit(
        &self,
        program_id: &anchor_lang::solana_program::pubkey::Pubkey,
    ) -> anchor_lang::Result<()> {
        anchor_lang::AccountsExit::exit(&self.merkle_slab, program_id)
            .map_err(|e| e.with_account_name("merkle_slab"))?;
        Ok(())
    }
}
/// An internal, Anchor generated module. This is used (as an
/// implementation detail), to generate a struct for a given
/// `#[derive(Accounts)]` implementation, where each field is a Pubkey,
/// instead of an `AccountInfo`. This is useful for clients that want
/// to generate a list of accounts, without explicitly knowing the
/// order all the fields should be in.
///
/// To access the struct in this module, one should use the sibling
/// `accounts` module (also generated), which re-exports this.
pub(crate) mod __client_accounts_burn {
    use super::*;
    use anchor_lang::prelude::borsh;
    /// Generated client accounts for [`Burn`].
    pub struct Burn {
        pub authority: anchor_lang::solana_program::pubkey::Pubkey,
        pub candy_wrapper: anchor_lang::solana_program::pubkey::Pubkey,
        pub gummyroll_program: anchor_lang::solana_program::pubkey::Pubkey,
        pub owner: anchor_lang::solana_program::pubkey::Pubkey,
        pub delegate: anchor_lang::solana_program::pubkey::Pubkey,
        pub merkle_slab: anchor_lang::solana_program::pubkey::Pubkey,
    }
    impl borsh::ser::BorshSerialize for Burn
    where
        anchor_lang::solana_program::pubkey::Pubkey: borsh::ser::BorshSerialize,
        anchor_lang::solana_program::pubkey::Pubkey: borsh::ser::BorshSerialize,
        anchor_lang::solana_program::pubkey::Pubkey: borsh::ser::BorshSerialize,
        anchor_lang::solana_program::pubkey::Pubkey: borsh::ser::BorshSerialize,
        anchor_lang::solana_program::pubkey::Pubkey: borsh::ser::BorshSerialize,
        anchor_lang::solana_program::pubkey::Pubkey: borsh::ser::BorshSerialize,
    {
        fn serialize<W: borsh::maybestd::io::Write>(
            &self,
            writer: &mut W,
        ) -> ::core::result::Result<(), borsh::maybestd::io::Error> {
            borsh::BorshSerialize::serialize(&self.authority, writer)?;
            borsh::BorshSerialize::serialize(&self.candy_wrapper, writer)?;
            borsh::BorshSerialize::serialize(&self.gummyroll_program, writer)?;
            borsh::BorshSerialize::serialize(&self.owner, writer)?;
            borsh::BorshSerialize::serialize(&self.delegate, writer)?;
            borsh::BorshSerialize::serialize(&self.merkle_slab, writer)?;
            Ok(())
        }
    }
    #[automatically_derived]
    impl anchor_lang::ToAccountMetas for Burn {
        fn to_account_metas(
            &self,
            is_signer: Option<bool>,
        ) -> Vec<anchor_lang::solana_program::instruction::AccountMeta> {
            let mut account_metas = ::alloc::vec::Vec::new();
            account_metas.push(
                anchor_lang::solana_program::instruction::AccountMeta::new_readonly(
                    self.authority,
                    false,
                ),
            );
            account_metas.push(
                anchor_lang::solana_program::instruction::AccountMeta::new_readonly(
                    self.candy_wrapper,
                    false,
                ),
            );
            account_metas.push(
                anchor_lang::solana_program::instruction::AccountMeta::new_readonly(
                    self.gummyroll_program,
                    false,
                ),
            );
            account_metas.push(
                anchor_lang::solana_program::instruction::AccountMeta::new_readonly(
                    self.owner, false,
                ),
            );
            account_metas.push(
                anchor_lang::solana_program::instruction::AccountMeta::new_readonly(
                    self.delegate,
                    false,
                ),
            );
            account_metas.push(anchor_lang::solana_program::instruction::AccountMeta::new(
                self.merkle_slab,
                false,
            ));
            account_metas
        }
    }
}
/// An internal, Anchor generated module. This is used (as an
/// implementation detail), to generate a CPI struct for a given
/// `#[derive(Accounts)]` implementation, where each field is an
/// AccountInfo.
///
/// To access the struct in this module, one should use the sibling
/// [`cpi::accounts`] module (also generated), which re-exports this.
pub(crate) mod __cpi_client_accounts_burn {
    use super::*;
    /// Generated CPI struct of the accounts for [`Burn`].
    pub struct Burn<'info> {
        pub authority: anchor_lang::solana_program::account_info::AccountInfo<'info>,
        pub candy_wrapper: anchor_lang::solana_program::account_info::AccountInfo<'info>,
        pub gummyroll_program: anchor_lang::solana_program::account_info::AccountInfo<'info>,
        pub owner: anchor_lang::solana_program::account_info::AccountInfo<'info>,
        pub delegate: anchor_lang::solana_program::account_info::AccountInfo<'info>,
        pub merkle_slab: anchor_lang::solana_program::account_info::AccountInfo<'info>,
    }
    #[automatically_derived]
    impl<'info> anchor_lang::ToAccountMetas for Burn<'info> {
        fn to_account_metas(
            &self,
            is_signer: Option<bool>,
        ) -> Vec<anchor_lang::solana_program::instruction::AccountMeta> {
            let mut account_metas = ::alloc::vec::Vec::new();
            account_metas.push(
                anchor_lang::solana_program::instruction::AccountMeta::new_readonly(
                    anchor_lang::Key::key(&self.authority),
                    false,
                ),
            );
            account_metas.push(
                anchor_lang::solana_program::instruction::AccountMeta::new_readonly(
                    anchor_lang::Key::key(&self.candy_wrapper),
                    false,
                ),
            );
            account_metas.push(
                anchor_lang::solana_program::instruction::AccountMeta::new_readonly(
                    anchor_lang::Key::key(&self.gummyroll_program),
                    false,
                ),
            );
            account_metas.push(
                anchor_lang::solana_program::instruction::AccountMeta::new_readonly(
                    anchor_lang::Key::key(&self.owner),
                    false,
                ),
            );
            account_metas.push(
                anchor_lang::solana_program::instruction::AccountMeta::new_readonly(
                    anchor_lang::Key::key(&self.delegate),
                    false,
                ),
            );
            account_metas.push(anchor_lang::solana_program::instruction::AccountMeta::new(
                anchor_lang::Key::key(&self.merkle_slab),
                false,
            ));
            account_metas
        }
    }
    #[automatically_derived]
    impl<'info> anchor_lang::ToAccountInfos<'info> for Burn<'info> {
        fn to_account_infos(
            &self,
        ) -> Vec<anchor_lang::solana_program::account_info::AccountInfo<'info>> {
            let mut account_infos = ::alloc::vec::Vec::new();
            account_infos.push(anchor_lang::ToAccountInfo::to_account_info(&self.authority));
            account_infos.push(anchor_lang::ToAccountInfo::to_account_info(
                &self.candy_wrapper,
            ));
            account_infos.push(anchor_lang::ToAccountInfo::to_account_info(
                &self.gummyroll_program,
            ));
            account_infos.push(anchor_lang::ToAccountInfo::to_account_info(&self.owner));
            account_infos.push(anchor_lang::ToAccountInfo::to_account_info(&self.delegate));
            account_infos.push(anchor_lang::ToAccountInfo::to_account_info(
                &self.merkle_slab,
            ));
            account_infos
        }
    }
}
pub struct CreatorVerification<'info> {
    # [account (seeds = [merkle_slab . key () . as_ref ()] , bump ,)]
    pub authority: Account<'info, TreeConfig>,
    /// CHECK: This account is checked in the instruction
    pub owner: UncheckedAccount<'info>,
    /// CHECK: This account is chekced in the instruction
    pub delegate: UncheckedAccount<'info>,
    pub creator: Signer<'info>,
    pub candy_wrapper: Program<'info, CandyWrapper>,
    pub gummyroll_program: Program<'info, Gummyroll>,
    #[account(mut)]
    /// CHECK: This account is modified in the downstream program
    pub merkle_slab: UncheckedAccount<'info>,
}
#[automatically_derived]
impl<'info> anchor_lang::Accounts<'info> for CreatorVerification<'info>
where
    'info: 'info,
{
    #[inline(never)]
    fn try_accounts(
        program_id: &anchor_lang::solana_program::pubkey::Pubkey,
        accounts: &mut &[anchor_lang::solana_program::account_info::AccountInfo<'info>],
        ix_data: &[u8],
        __bumps: &mut std::collections::BTreeMap<String, u8>,
        __reallocs: &mut std::collections::BTreeSet<anchor_lang::solana_program::pubkey::Pubkey>,
    ) -> anchor_lang::Result<Self> {
        let authority: anchor_lang::accounts::account::Account<TreeConfig> =
            anchor_lang::Accounts::try_accounts(program_id, accounts, ix_data, __bumps, __reallocs)
                .map_err(|e| e.with_account_name("authority"))?;
        let owner: UncheckedAccount =
            anchor_lang::Accounts::try_accounts(program_id, accounts, ix_data, __bumps, __reallocs)
                .map_err(|e| e.with_account_name("owner"))?;
        let delegate: UncheckedAccount =
            anchor_lang::Accounts::try_accounts(program_id, accounts, ix_data, __bumps, __reallocs)
                .map_err(|e| e.with_account_name("delegate"))?;
        let creator: Signer =
            anchor_lang::Accounts::try_accounts(program_id, accounts, ix_data, __bumps, __reallocs)
                .map_err(|e| e.with_account_name("creator"))?;
        let candy_wrapper: anchor_lang::accounts::program::Program<CandyWrapper> =
            anchor_lang::Accounts::try_accounts(program_id, accounts, ix_data, __bumps, __reallocs)
                .map_err(|e| e.with_account_name("candy_wrapper"))?;
        let gummyroll_program: anchor_lang::accounts::program::Program<Gummyroll> =
            anchor_lang::Accounts::try_accounts(program_id, accounts, ix_data, __bumps, __reallocs)
                .map_err(|e| e.with_account_name("gummyroll_program"))?;
        let merkle_slab: UncheckedAccount =
            anchor_lang::Accounts::try_accounts(program_id, accounts, ix_data, __bumps, __reallocs)
                .map_err(|e| e.with_account_name("merkle_slab"))?;
        let (__pda_address, __bump) =
            Pubkey::find_program_address(&[merkle_slab.key().as_ref()], &program_id);
        __bumps.insert("authority".to_string(), __bump);
        if authority.key() != __pda_address {
            return Err(anchor_lang::error::Error::from(
                anchor_lang::error::ErrorCode::ConstraintSeeds,
            )
            .with_account_name("authority")
            .with_pubkeys((authority.key(), __pda_address)));
        }
        if !merkle_slab.to_account_info().is_writable {
            return Err(anchor_lang::error::Error::from(
                anchor_lang::error::ErrorCode::ConstraintMut,
            )
            .with_account_name("merkle_slab"));
        }
        Ok(CreatorVerification {
            authority,
            owner,
            delegate,
            creator,
            candy_wrapper,
            gummyroll_program,
            merkle_slab,
        })
    }
}
#[automatically_derived]
impl<'info> anchor_lang::ToAccountInfos<'info> for CreatorVerification<'info>
where
    'info: 'info,
{
    fn to_account_infos(
        &self,
    ) -> Vec<anchor_lang::solana_program::account_info::AccountInfo<'info>> {
        let mut account_infos = ::alloc::vec::Vec::new();
        account_infos.extend(self.authority.to_account_infos());
        account_infos.extend(self.owner.to_account_infos());
        account_infos.extend(self.delegate.to_account_infos());
        account_infos.extend(self.creator.to_account_infos());
        account_infos.extend(self.candy_wrapper.to_account_infos());
        account_infos.extend(self.gummyroll_program.to_account_infos());
        account_infos.extend(self.merkle_slab.to_account_infos());
        account_infos
    }
}
#[automatically_derived]
impl<'info> anchor_lang::ToAccountMetas for CreatorVerification<'info> {
    fn to_account_metas(
        &self,
        is_signer: Option<bool>,
    ) -> Vec<anchor_lang::solana_program::instruction::AccountMeta> {
        let mut account_metas = ::alloc::vec::Vec::new();
        account_metas.extend(self.authority.to_account_metas(None));
        account_metas.extend(self.owner.to_account_metas(None));
        account_metas.extend(self.delegate.to_account_metas(None));
        account_metas.extend(self.creator.to_account_metas(None));
        account_metas.extend(self.candy_wrapper.to_account_metas(None));
        account_metas.extend(self.gummyroll_program.to_account_metas(None));
        account_metas.extend(self.merkle_slab.to_account_metas(None));
        account_metas
    }
}
#[automatically_derived]
impl<'info> anchor_lang::AccountsExit<'info> for CreatorVerification<'info>
where
    'info: 'info,
{
    fn exit(
        &self,
        program_id: &anchor_lang::solana_program::pubkey::Pubkey,
    ) -> anchor_lang::Result<()> {
        anchor_lang::AccountsExit::exit(&self.merkle_slab, program_id)
            .map_err(|e| e.with_account_name("merkle_slab"))?;
        Ok(())
    }
}
/// An internal, Anchor generated module. This is used (as an
/// implementation detail), to generate a struct for a given
/// `#[derive(Accounts)]` implementation, where each field is a Pubkey,
/// instead of an `AccountInfo`. This is useful for clients that want
/// to generate a list of accounts, without explicitly knowing the
/// order all the fields should be in.
///
/// To access the struct in this module, one should use the sibling
/// `accounts` module (also generated), which re-exports this.
pub(crate) mod __client_accounts_creator_verification {
    use super::*;
    use anchor_lang::prelude::borsh;
    /// Generated client accounts for [`CreatorVerification`].
    pub struct CreatorVerification {
        pub authority: anchor_lang::solana_program::pubkey::Pubkey,
        pub owner: anchor_lang::solana_program::pubkey::Pubkey,
        pub delegate: anchor_lang::solana_program::pubkey::Pubkey,
        pub creator: anchor_lang::solana_program::pubkey::Pubkey,
        pub candy_wrapper: anchor_lang::solana_program::pubkey::Pubkey,
        pub gummyroll_program: anchor_lang::solana_program::pubkey::Pubkey,
        pub merkle_slab: anchor_lang::solana_program::pubkey::Pubkey,
    }
    impl borsh::ser::BorshSerialize for CreatorVerification
    where
        anchor_lang::solana_program::pubkey::Pubkey: borsh::ser::BorshSerialize,
        anchor_lang::solana_program::pubkey::Pubkey: borsh::ser::BorshSerialize,
        anchor_lang::solana_program::pubkey::Pubkey: borsh::ser::BorshSerialize,
        anchor_lang::solana_program::pubkey::Pubkey: borsh::ser::BorshSerialize,
        anchor_lang::solana_program::pubkey::Pubkey: borsh::ser::BorshSerialize,
        anchor_lang::solana_program::pubkey::Pubkey: borsh::ser::BorshSerialize,
        anchor_lang::solana_program::pubkey::Pubkey: borsh::ser::BorshSerialize,
    {
        fn serialize<W: borsh::maybestd::io::Write>(
            &self,
            writer: &mut W,
        ) -> ::core::result::Result<(), borsh::maybestd::io::Error> {
            borsh::BorshSerialize::serialize(&self.authority, writer)?;
            borsh::BorshSerialize::serialize(&self.owner, writer)?;
            borsh::BorshSerialize::serialize(&self.delegate, writer)?;
            borsh::BorshSerialize::serialize(&self.creator, writer)?;
            borsh::BorshSerialize::serialize(&self.candy_wrapper, writer)?;
            borsh::BorshSerialize::serialize(&self.gummyroll_program, writer)?;
            borsh::BorshSerialize::serialize(&self.merkle_slab, writer)?;
            Ok(())
        }
    }
    #[automatically_derived]
    impl anchor_lang::ToAccountMetas for CreatorVerification {
        fn to_account_metas(
            &self,
            is_signer: Option<bool>,
        ) -> Vec<anchor_lang::solana_program::instruction::AccountMeta> {
            let mut account_metas = ::alloc::vec::Vec::new();
            account_metas.push(
                anchor_lang::solana_program::instruction::AccountMeta::new_readonly(
                    self.authority,
                    false,
                ),
            );
            account_metas.push(
                anchor_lang::solana_program::instruction::AccountMeta::new_readonly(
                    self.owner, false,
                ),
            );
            account_metas.push(
                anchor_lang::solana_program::instruction::AccountMeta::new_readonly(
                    self.delegate,
                    false,
                ),
            );
            account_metas.push(
                anchor_lang::solana_program::instruction::AccountMeta::new_readonly(
                    self.creator,
                    true,
                ),
            );
            account_metas.push(
                anchor_lang::solana_program::instruction::AccountMeta::new_readonly(
                    self.candy_wrapper,
                    false,
                ),
            );
            account_metas.push(
                anchor_lang::solana_program::instruction::AccountMeta::new_readonly(
                    self.gummyroll_program,
                    false,
                ),
            );
            account_metas.push(anchor_lang::solana_program::instruction::AccountMeta::new(
                self.merkle_slab,
                false,
            ));
            account_metas
        }
    }
}
/// An internal, Anchor generated module. This is used (as an
/// implementation detail), to generate a CPI struct for a given
/// `#[derive(Accounts)]` implementation, where each field is an
/// AccountInfo.
///
/// To access the struct in this module, one should use the sibling
/// [`cpi::accounts`] module (also generated), which re-exports this.
pub(crate) mod __cpi_client_accounts_creator_verification {
    use super::*;
    /// Generated CPI struct of the accounts for [`CreatorVerification`].
    pub struct CreatorVerification<'info> {
        pub authority: anchor_lang::solana_program::account_info::AccountInfo<'info>,
        pub owner: anchor_lang::solana_program::account_info::AccountInfo<'info>,
        pub delegate: anchor_lang::solana_program::account_info::AccountInfo<'info>,
        pub creator: anchor_lang::solana_program::account_info::AccountInfo<'info>,
        pub candy_wrapper: anchor_lang::solana_program::account_info::AccountInfo<'info>,
        pub gummyroll_program: anchor_lang::solana_program::account_info::AccountInfo<'info>,
        pub merkle_slab: anchor_lang::solana_program::account_info::AccountInfo<'info>,
    }
    #[automatically_derived]
    impl<'info> anchor_lang::ToAccountMetas for CreatorVerification<'info> {
        fn to_account_metas(
            &self,
            is_signer: Option<bool>,
        ) -> Vec<anchor_lang::solana_program::instruction::AccountMeta> {
            let mut account_metas = ::alloc::vec::Vec::new();
            account_metas.push(
                anchor_lang::solana_program::instruction::AccountMeta::new_readonly(
                    anchor_lang::Key::key(&self.authority),
                    false,
                ),
            );
            account_metas.push(
                anchor_lang::solana_program::instruction::AccountMeta::new_readonly(
                    anchor_lang::Key::key(&self.owner),
                    false,
                ),
            );
            account_metas.push(
                anchor_lang::solana_program::instruction::AccountMeta::new_readonly(
                    anchor_lang::Key::key(&self.delegate),
                    false,
                ),
            );
            account_metas.push(
                anchor_lang::solana_program::instruction::AccountMeta::new_readonly(
                    anchor_lang::Key::key(&self.creator),
                    true,
                ),
            );
            account_metas.push(
                anchor_lang::solana_program::instruction::AccountMeta::new_readonly(
                    anchor_lang::Key::key(&self.candy_wrapper),
                    false,
                ),
            );
            account_metas.push(
                anchor_lang::solana_program::instruction::AccountMeta::new_readonly(
                    anchor_lang::Key::key(&self.gummyroll_program),
                    false,
                ),
            );
            account_metas.push(anchor_lang::solana_program::instruction::AccountMeta::new(
                anchor_lang::Key::key(&self.merkle_slab),
                false,
            ));
            account_metas
        }
    }
    #[automatically_derived]
    impl<'info> anchor_lang::ToAccountInfos<'info> for CreatorVerification<'info> {
        fn to_account_infos(
            &self,
        ) -> Vec<anchor_lang::solana_program::account_info::AccountInfo<'info>> {
            let mut account_infos = ::alloc::vec::Vec::new();
            account_infos.push(anchor_lang::ToAccountInfo::to_account_info(&self.authority));
            account_infos.push(anchor_lang::ToAccountInfo::to_account_info(&self.owner));
            account_infos.push(anchor_lang::ToAccountInfo::to_account_info(&self.delegate));
            account_infos.push(anchor_lang::ToAccountInfo::to_account_info(&self.creator));
            account_infos.push(anchor_lang::ToAccountInfo::to_account_info(
                &self.candy_wrapper,
            ));
            account_infos.push(anchor_lang::ToAccountInfo::to_account_info(
                &self.gummyroll_program,
            ));
            account_infos.push(anchor_lang::ToAccountInfo::to_account_info(
                &self.merkle_slab,
            ));
            account_infos
        }
    }
}
pub struct Transfer<'info> {
    # [account (seeds = [merkle_slab . key () . as_ref ()] , bump ,)]
    /// CHECK: This account is neither written to nor read from.
    pub authority: Account<'info, TreeConfig>,
    /// CHECK: This account is checked in the instruction
    pub owner: UncheckedAccount<'info>,
    /// CHECK: This account is chekced in the instruction
    pub delegate: UncheckedAccount<'info>,
    /// CHECK: This account is neither written to nor read from.
    pub new_owner: UncheckedAccount<'info>,
    pub candy_wrapper: Program<'info, CandyWrapper>,
    pub gummyroll_program: Program<'info, Gummyroll>,
    #[account(mut)]
    /// CHECK: This account is modified in the downstream program
    pub merkle_slab: UncheckedAccount<'info>,
}
#[automatically_derived]
impl<'info> anchor_lang::Accounts<'info> for Transfer<'info>
where
    'info: 'info,
{
    #[inline(never)]
    fn try_accounts(
        program_id: &anchor_lang::solana_program::pubkey::Pubkey,
        accounts: &mut &[anchor_lang::solana_program::account_info::AccountInfo<'info>],
        ix_data: &[u8],
        __bumps: &mut std::collections::BTreeMap<String, u8>,
        __reallocs: &mut std::collections::BTreeSet<anchor_lang::solana_program::pubkey::Pubkey>,
    ) -> anchor_lang::Result<Self> {
        let authority: anchor_lang::accounts::account::Account<TreeConfig> =
            anchor_lang::Accounts::try_accounts(program_id, accounts, ix_data, __bumps, __reallocs)
                .map_err(|e| e.with_account_name("authority"))?;
        let owner: UncheckedAccount =
            anchor_lang::Accounts::try_accounts(program_id, accounts, ix_data, __bumps, __reallocs)
                .map_err(|e| e.with_account_name("owner"))?;
        let delegate: UncheckedAccount =
            anchor_lang::Accounts::try_accounts(program_id, accounts, ix_data, __bumps, __reallocs)
                .map_err(|e| e.with_account_name("delegate"))?;
        let new_owner: UncheckedAccount =
            anchor_lang::Accounts::try_accounts(program_id, accounts, ix_data, __bumps, __reallocs)
                .map_err(|e| e.with_account_name("new_owner"))?;
        let candy_wrapper: anchor_lang::accounts::program::Program<CandyWrapper> =
            anchor_lang::Accounts::try_accounts(program_id, accounts, ix_data, __bumps, __reallocs)
                .map_err(|e| e.with_account_name("candy_wrapper"))?;
        let gummyroll_program: anchor_lang::accounts::program::Program<Gummyroll> =
            anchor_lang::Accounts::try_accounts(program_id, accounts, ix_data, __bumps, __reallocs)
                .map_err(|e| e.with_account_name("gummyroll_program"))?;
        let merkle_slab: UncheckedAccount =
            anchor_lang::Accounts::try_accounts(program_id, accounts, ix_data, __bumps, __reallocs)
                .map_err(|e| e.with_account_name("merkle_slab"))?;
        let (__pda_address, __bump) =
            Pubkey::find_program_address(&[merkle_slab.key().as_ref()], &program_id);
        __bumps.insert("authority".to_string(), __bump);
        if authority.key() != __pda_address {
            return Err(anchor_lang::error::Error::from(
                anchor_lang::error::ErrorCode::ConstraintSeeds,
            )
            .with_account_name("authority")
            .with_pubkeys((authority.key(), __pda_address)));
        }
        if !merkle_slab.to_account_info().is_writable {
            return Err(anchor_lang::error::Error::from(
                anchor_lang::error::ErrorCode::ConstraintMut,
            )
            .with_account_name("merkle_slab"));
        }
        Ok(Transfer {
            authority,
            owner,
            delegate,
            new_owner,
            candy_wrapper,
            gummyroll_program,
            merkle_slab,
        })
    }
}
#[automatically_derived]
impl<'info> anchor_lang::ToAccountInfos<'info> for Transfer<'info>
where
    'info: 'info,
{
    fn to_account_infos(
        &self,
    ) -> Vec<anchor_lang::solana_program::account_info::AccountInfo<'info>> {
        let mut account_infos = ::alloc::vec::Vec::new();
        account_infos.extend(self.authority.to_account_infos());
        account_infos.extend(self.owner.to_account_infos());
        account_infos.extend(self.delegate.to_account_infos());
        account_infos.extend(self.new_owner.to_account_infos());
        account_infos.extend(self.candy_wrapper.to_account_infos());
        account_infos.extend(self.gummyroll_program.to_account_infos());
        account_infos.extend(self.merkle_slab.to_account_infos());
        account_infos
    }
}
#[automatically_derived]
impl<'info> anchor_lang::ToAccountMetas for Transfer<'info> {
    fn to_account_metas(
        &self,
        is_signer: Option<bool>,
    ) -> Vec<anchor_lang::solana_program::instruction::AccountMeta> {
        let mut account_metas = ::alloc::vec::Vec::new();
        account_metas.extend(self.authority.to_account_metas(None));
        account_metas.extend(self.owner.to_account_metas(None));
        account_metas.extend(self.delegate.to_account_metas(None));
        account_metas.extend(self.new_owner.to_account_metas(None));
        account_metas.extend(self.candy_wrapper.to_account_metas(None));
        account_metas.extend(self.gummyroll_program.to_account_metas(None));
        account_metas.extend(self.merkle_slab.to_account_metas(None));
        account_metas
    }
}
#[automatically_derived]
impl<'info> anchor_lang::AccountsExit<'info> for Transfer<'info>
where
    'info: 'info,
{
    fn exit(
        &self,
        program_id: &anchor_lang::solana_program::pubkey::Pubkey,
    ) -> anchor_lang::Result<()> {
        anchor_lang::AccountsExit::exit(&self.merkle_slab, program_id)
            .map_err(|e| e.with_account_name("merkle_slab"))?;
        Ok(())
    }
}
/// An internal, Anchor generated module. This is used (as an
/// implementation detail), to generate a struct for a given
/// `#[derive(Accounts)]` implementation, where each field is a Pubkey,
/// instead of an `AccountInfo`. This is useful for clients that want
/// to generate a list of accounts, without explicitly knowing the
/// order all the fields should be in.
///
/// To access the struct in this module, one should use the sibling
/// `accounts` module (also generated), which re-exports this.
pub(crate) mod __client_accounts_transfer {
    use super::*;
    use anchor_lang::prelude::borsh;
    /// Generated client accounts for [`Transfer`].
    pub struct Transfer {
        pub authority: anchor_lang::solana_program::pubkey::Pubkey,
        pub owner: anchor_lang::solana_program::pubkey::Pubkey,
        pub delegate: anchor_lang::solana_program::pubkey::Pubkey,
        pub new_owner: anchor_lang::solana_program::pubkey::Pubkey,
        pub candy_wrapper: anchor_lang::solana_program::pubkey::Pubkey,
        pub gummyroll_program: anchor_lang::solana_program::pubkey::Pubkey,
        pub merkle_slab: anchor_lang::solana_program::pubkey::Pubkey,
    }
    impl borsh::ser::BorshSerialize for Transfer
    where
        anchor_lang::solana_program::pubkey::Pubkey: borsh::ser::BorshSerialize,
        anchor_lang::solana_program::pubkey::Pubkey: borsh::ser::BorshSerialize,
        anchor_lang::solana_program::pubkey::Pubkey: borsh::ser::BorshSerialize,
        anchor_lang::solana_program::pubkey::Pubkey: borsh::ser::BorshSerialize,
        anchor_lang::solana_program::pubkey::Pubkey: borsh::ser::BorshSerialize,
        anchor_lang::solana_program::pubkey::Pubkey: borsh::ser::BorshSerialize,
        anchor_lang::solana_program::pubkey::Pubkey: borsh::ser::BorshSerialize,
    {
        fn serialize<W: borsh::maybestd::io::Write>(
            &self,
            writer: &mut W,
        ) -> ::core::result::Result<(), borsh::maybestd::io::Error> {
            borsh::BorshSerialize::serialize(&self.authority, writer)?;
            borsh::BorshSerialize::serialize(&self.owner, writer)?;
            borsh::BorshSerialize::serialize(&self.delegate, writer)?;
            borsh::BorshSerialize::serialize(&self.new_owner, writer)?;
            borsh::BorshSerialize::serialize(&self.candy_wrapper, writer)?;
            borsh::BorshSerialize::serialize(&self.gummyroll_program, writer)?;
            borsh::BorshSerialize::serialize(&self.merkle_slab, writer)?;
            Ok(())
        }
    }
    #[automatically_derived]
    impl anchor_lang::ToAccountMetas for Transfer {
        fn to_account_metas(
            &self,
            is_signer: Option<bool>,
        ) -> Vec<anchor_lang::solana_program::instruction::AccountMeta> {
            let mut account_metas = ::alloc::vec::Vec::new();
            account_metas.push(
                anchor_lang::solana_program::instruction::AccountMeta::new_readonly(
                    self.authority,
                    false,
                ),
            );
            account_metas.push(
                anchor_lang::solana_program::instruction::AccountMeta::new_readonly(
                    self.owner, false,
                ),
            );
            account_metas.push(
                anchor_lang::solana_program::instruction::AccountMeta::new_readonly(
                    self.delegate,
                    false,
                ),
            );
            account_metas.push(
                anchor_lang::solana_program::instruction::AccountMeta::new_readonly(
                    self.new_owner,
                    false,
                ),
            );
            account_metas.push(
                anchor_lang::solana_program::instruction::AccountMeta::new_readonly(
                    self.candy_wrapper,
                    false,
                ),
            );
            account_metas.push(
                anchor_lang::solana_program::instruction::AccountMeta::new_readonly(
                    self.gummyroll_program,
                    false,
                ),
            );
            account_metas.push(anchor_lang::solana_program::instruction::AccountMeta::new(
                self.merkle_slab,
                false,
            ));
            account_metas
        }
    }
}
/// An internal, Anchor generated module. This is used (as an
/// implementation detail), to generate a CPI struct for a given
/// `#[derive(Accounts)]` implementation, where each field is an
/// AccountInfo.
///
/// To access the struct in this module, one should use the sibling
/// [`cpi::accounts`] module (also generated), which re-exports this.
pub(crate) mod __cpi_client_accounts_transfer {
    use super::*;
    /// Generated CPI struct of the accounts for [`Transfer`].
    pub struct Transfer<'info> {
        pub authority: anchor_lang::solana_program::account_info::AccountInfo<'info>,
        pub owner: anchor_lang::solana_program::account_info::AccountInfo<'info>,
        pub delegate: anchor_lang::solana_program::account_info::AccountInfo<'info>,
        pub new_owner: anchor_lang::solana_program::account_info::AccountInfo<'info>,
        pub candy_wrapper: anchor_lang::solana_program::account_info::AccountInfo<'info>,
        pub gummyroll_program: anchor_lang::solana_program::account_info::AccountInfo<'info>,
        pub merkle_slab: anchor_lang::solana_program::account_info::AccountInfo<'info>,
    }
    #[automatically_derived]
    impl<'info> anchor_lang::ToAccountMetas for Transfer<'info> {
        fn to_account_metas(
            &self,
            is_signer: Option<bool>,
        ) -> Vec<anchor_lang::solana_program::instruction::AccountMeta> {
            let mut account_metas = ::alloc::vec::Vec::new();
            account_metas.push(
                anchor_lang::solana_program::instruction::AccountMeta::new_readonly(
                    anchor_lang::Key::key(&self.authority),
                    false,
                ),
            );
            account_metas.push(
                anchor_lang::solana_program::instruction::AccountMeta::new_readonly(
                    anchor_lang::Key::key(&self.owner),
                    false,
                ),
            );
            account_metas.push(
                anchor_lang::solana_program::instruction::AccountMeta::new_readonly(
                    anchor_lang::Key::key(&self.delegate),
                    false,
                ),
            );
            account_metas.push(
                anchor_lang::solana_program::instruction::AccountMeta::new_readonly(
                    anchor_lang::Key::key(&self.new_owner),
                    false,
                ),
            );
            account_metas.push(
                anchor_lang::solana_program::instruction::AccountMeta::new_readonly(
                    anchor_lang::Key::key(&self.candy_wrapper),
                    false,
                ),
            );
            account_metas.push(
                anchor_lang::solana_program::instruction::AccountMeta::new_readonly(
                    anchor_lang::Key::key(&self.gummyroll_program),
                    false,
                ),
            );
            account_metas.push(anchor_lang::solana_program::instruction::AccountMeta::new(
                anchor_lang::Key::key(&self.merkle_slab),
                false,
            ));
            account_metas
        }
    }
    #[automatically_derived]
    impl<'info> anchor_lang::ToAccountInfos<'info> for Transfer<'info> {
        fn to_account_infos(
            &self,
        ) -> Vec<anchor_lang::solana_program::account_info::AccountInfo<'info>> {
            let mut account_infos = ::alloc::vec::Vec::new();
            account_infos.push(anchor_lang::ToAccountInfo::to_account_info(&self.authority));
            account_infos.push(anchor_lang::ToAccountInfo::to_account_info(&self.owner));
            account_infos.push(anchor_lang::ToAccountInfo::to_account_info(&self.delegate));
            account_infos.push(anchor_lang::ToAccountInfo::to_account_info(&self.new_owner));
            account_infos.push(anchor_lang::ToAccountInfo::to_account_info(
                &self.candy_wrapper,
            ));
            account_infos.push(anchor_lang::ToAccountInfo::to_account_info(
                &self.gummyroll_program,
            ));
            account_infos.push(anchor_lang::ToAccountInfo::to_account_info(
                &self.merkle_slab,
            ));
            account_infos
        }
    }
}
pub struct Delegate<'info> {
    # [account (seeds = [merkle_slab . key () . as_ref ()] , bump ,)]
    /// CHECK: This account is neither written to nor read from.
    pub authority: Account<'info, TreeConfig>,
    pub owner: Signer<'info>,
    /// CHECK: This account is neither written to nor read from.
    pub previous_delegate: UncheckedAccount<'info>,
    /// CHECK: This account is neither written to nor read from.
    pub new_delegate: UncheckedAccount<'info>,
    pub candy_wrapper: Program<'info, CandyWrapper>,
    pub gummyroll_program: Program<'info, Gummyroll>,
    #[account(mut)]
    /// CHECK: This account is modified in the downstream program
    pub merkle_slab: UncheckedAccount<'info>,
}
#[automatically_derived]
impl<'info> anchor_lang::Accounts<'info> for Delegate<'info>
where
    'info: 'info,
{
    #[inline(never)]
    fn try_accounts(
        program_id: &anchor_lang::solana_program::pubkey::Pubkey,
        accounts: &mut &[anchor_lang::solana_program::account_info::AccountInfo<'info>],
        ix_data: &[u8],
        __bumps: &mut std::collections::BTreeMap<String, u8>,
        __reallocs: &mut std::collections::BTreeSet<anchor_lang::solana_program::pubkey::Pubkey>,
    ) -> anchor_lang::Result<Self> {
        let authority: anchor_lang::accounts::account::Account<TreeConfig> =
            anchor_lang::Accounts::try_accounts(program_id, accounts, ix_data, __bumps, __reallocs)
                .map_err(|e| e.with_account_name("authority"))?;
        let owner: Signer =
            anchor_lang::Accounts::try_accounts(program_id, accounts, ix_data, __bumps, __reallocs)
                .map_err(|e| e.with_account_name("owner"))?;
        let previous_delegate: UncheckedAccount =
            anchor_lang::Accounts::try_accounts(program_id, accounts, ix_data, __bumps, __reallocs)
                .map_err(|e| e.with_account_name("previous_delegate"))?;
        let new_delegate: UncheckedAccount =
            anchor_lang::Accounts::try_accounts(program_id, accounts, ix_data, __bumps, __reallocs)
                .map_err(|e| e.with_account_name("new_delegate"))?;
        let candy_wrapper: anchor_lang::accounts::program::Program<CandyWrapper> =
            anchor_lang::Accounts::try_accounts(program_id, accounts, ix_data, __bumps, __reallocs)
                .map_err(|e| e.with_account_name("candy_wrapper"))?;
        let gummyroll_program: anchor_lang::accounts::program::Program<Gummyroll> =
            anchor_lang::Accounts::try_accounts(program_id, accounts, ix_data, __bumps, __reallocs)
                .map_err(|e| e.with_account_name("gummyroll_program"))?;
        let merkle_slab: UncheckedAccount =
            anchor_lang::Accounts::try_accounts(program_id, accounts, ix_data, __bumps, __reallocs)
                .map_err(|e| e.with_account_name("merkle_slab"))?;
        let (__pda_address, __bump) =
            Pubkey::find_program_address(&[merkle_slab.key().as_ref()], &program_id);
        __bumps.insert("authority".to_string(), __bump);
        if authority.key() != __pda_address {
            return Err(anchor_lang::error::Error::from(
                anchor_lang::error::ErrorCode::ConstraintSeeds,
            )
            .with_account_name("authority")
            .with_pubkeys((authority.key(), __pda_address)));
        }
        if !merkle_slab.to_account_info().is_writable {
            return Err(anchor_lang::error::Error::from(
                anchor_lang::error::ErrorCode::ConstraintMut,
            )
            .with_account_name("merkle_slab"));
        }
        Ok(Delegate {
            authority,
            owner,
            previous_delegate,
            new_delegate,
            candy_wrapper,
            gummyroll_program,
            merkle_slab,
        })
    }
}
#[automatically_derived]
impl<'info> anchor_lang::ToAccountInfos<'info> for Delegate<'info>
where
    'info: 'info,
{
    fn to_account_infos(
        &self,
    ) -> Vec<anchor_lang::solana_program::account_info::AccountInfo<'info>> {
        let mut account_infos = ::alloc::vec::Vec::new();
        account_infos.extend(self.authority.to_account_infos());
        account_infos.extend(self.owner.to_account_infos());
        account_infos.extend(self.previous_delegate.to_account_infos());
        account_infos.extend(self.new_delegate.to_account_infos());
        account_infos.extend(self.candy_wrapper.to_account_infos());
        account_infos.extend(self.gummyroll_program.to_account_infos());
        account_infos.extend(self.merkle_slab.to_account_infos());
        account_infos
    }
}
#[automatically_derived]
impl<'info> anchor_lang::ToAccountMetas for Delegate<'info> {
    fn to_account_metas(
        &self,
        is_signer: Option<bool>,
    ) -> Vec<anchor_lang::solana_program::instruction::AccountMeta> {
        let mut account_metas = ::alloc::vec::Vec::new();
        account_metas.extend(self.authority.to_account_metas(None));
        account_metas.extend(self.owner.to_account_metas(None));
        account_metas.extend(self.previous_delegate.to_account_metas(None));
        account_metas.extend(self.new_delegate.to_account_metas(None));
        account_metas.extend(self.candy_wrapper.to_account_metas(None));
        account_metas.extend(self.gummyroll_program.to_account_metas(None));
        account_metas.extend(self.merkle_slab.to_account_metas(None));
        account_metas
    }
}
#[automatically_derived]
impl<'info> anchor_lang::AccountsExit<'info> for Delegate<'info>
where
    'info: 'info,
{
    fn exit(
        &self,
        program_id: &anchor_lang::solana_program::pubkey::Pubkey,
    ) -> anchor_lang::Result<()> {
        anchor_lang::AccountsExit::exit(&self.merkle_slab, program_id)
            .map_err(|e| e.with_account_name("merkle_slab"))?;
        Ok(())
    }
}
/// An internal, Anchor generated module. This is used (as an
/// implementation detail), to generate a struct for a given
/// `#[derive(Accounts)]` implementation, where each field is a Pubkey,
/// instead of an `AccountInfo`. This is useful for clients that want
/// to generate a list of accounts, without explicitly knowing the
/// order all the fields should be in.
///
/// To access the struct in this module, one should use the sibling
/// `accounts` module (also generated), which re-exports this.
pub(crate) mod __client_accounts_delegate {
    use super::*;
    use anchor_lang::prelude::borsh;
    /// Generated client accounts for [`Delegate`].
    pub struct Delegate {
        pub authority: anchor_lang::solana_program::pubkey::Pubkey,
        pub owner: anchor_lang::solana_program::pubkey::Pubkey,
        pub previous_delegate: anchor_lang::solana_program::pubkey::Pubkey,
        pub new_delegate: anchor_lang::solana_program::pubkey::Pubkey,
        pub candy_wrapper: anchor_lang::solana_program::pubkey::Pubkey,
        pub gummyroll_program: anchor_lang::solana_program::pubkey::Pubkey,
        pub merkle_slab: anchor_lang::solana_program::pubkey::Pubkey,
    }
    impl borsh::ser::BorshSerialize for Delegate
    where
        anchor_lang::solana_program::pubkey::Pubkey: borsh::ser::BorshSerialize,
        anchor_lang::solana_program::pubkey::Pubkey: borsh::ser::BorshSerialize,
        anchor_lang::solana_program::pubkey::Pubkey: borsh::ser::BorshSerialize,
        anchor_lang::solana_program::pubkey::Pubkey: borsh::ser::BorshSerialize,
        anchor_lang::solana_program::pubkey::Pubkey: borsh::ser::BorshSerialize,
        anchor_lang::solana_program::pubkey::Pubkey: borsh::ser::BorshSerialize,
        anchor_lang::solana_program::pubkey::Pubkey: borsh::ser::BorshSerialize,
    {
        fn serialize<W: borsh::maybestd::io::Write>(
            &self,
            writer: &mut W,
        ) -> ::core::result::Result<(), borsh::maybestd::io::Error> {
            borsh::BorshSerialize::serialize(&self.authority, writer)?;
            borsh::BorshSerialize::serialize(&self.owner, writer)?;
            borsh::BorshSerialize::serialize(&self.previous_delegate, writer)?;
            borsh::BorshSerialize::serialize(&self.new_delegate, writer)?;
            borsh::BorshSerialize::serialize(&self.candy_wrapper, writer)?;
            borsh::BorshSerialize::serialize(&self.gummyroll_program, writer)?;
            borsh::BorshSerialize::serialize(&self.merkle_slab, writer)?;
            Ok(())
        }
    }
    #[automatically_derived]
    impl anchor_lang::ToAccountMetas for Delegate {
        fn to_account_metas(
            &self,
            is_signer: Option<bool>,
        ) -> Vec<anchor_lang::solana_program::instruction::AccountMeta> {
            let mut account_metas = ::alloc::vec::Vec::new();
            account_metas.push(
                anchor_lang::solana_program::instruction::AccountMeta::new_readonly(
                    self.authority,
                    false,
                ),
            );
            account_metas.push(
                anchor_lang::solana_program::instruction::AccountMeta::new_readonly(
                    self.owner, true,
                ),
            );
            account_metas.push(
                anchor_lang::solana_program::instruction::AccountMeta::new_readonly(
                    self.previous_delegate,
                    false,
                ),
            );
            account_metas.push(
                anchor_lang::solana_program::instruction::AccountMeta::new_readonly(
                    self.new_delegate,
                    false,
                ),
            );
            account_metas.push(
                anchor_lang::solana_program::instruction::AccountMeta::new_readonly(
                    self.candy_wrapper,
                    false,
                ),
            );
            account_metas.push(
                anchor_lang::solana_program::instruction::AccountMeta::new_readonly(
                    self.gummyroll_program,
                    false,
                ),
            );
            account_metas.push(anchor_lang::solana_program::instruction::AccountMeta::new(
                self.merkle_slab,
                false,
            ));
            account_metas
        }
    }
}
/// An internal, Anchor generated module. This is used (as an
/// implementation detail), to generate a CPI struct for a given
/// `#[derive(Accounts)]` implementation, where each field is an
/// AccountInfo.
///
/// To access the struct in this module, one should use the sibling
/// [`cpi::accounts`] module (also generated), which re-exports this.
pub(crate) mod __cpi_client_accounts_delegate {
    use super::*;
    /// Generated CPI struct of the accounts for [`Delegate`].
    pub struct Delegate<'info> {
        pub authority: anchor_lang::solana_program::account_info::AccountInfo<'info>,
        pub owner: anchor_lang::solana_program::account_info::AccountInfo<'info>,
        pub previous_delegate: anchor_lang::solana_program::account_info::AccountInfo<'info>,
        pub new_delegate: anchor_lang::solana_program::account_info::AccountInfo<'info>,
        pub candy_wrapper: anchor_lang::solana_program::account_info::AccountInfo<'info>,
        pub gummyroll_program: anchor_lang::solana_program::account_info::AccountInfo<'info>,
        pub merkle_slab: anchor_lang::solana_program::account_info::AccountInfo<'info>,
    }
    #[automatically_derived]
    impl<'info> anchor_lang::ToAccountMetas for Delegate<'info> {
        fn to_account_metas(
            &self,
            is_signer: Option<bool>,
        ) -> Vec<anchor_lang::solana_program::instruction::AccountMeta> {
            let mut account_metas = ::alloc::vec::Vec::new();
            account_metas.push(
                anchor_lang::solana_program::instruction::AccountMeta::new_readonly(
                    anchor_lang::Key::key(&self.authority),
                    false,
                ),
            );
            account_metas.push(
                anchor_lang::solana_program::instruction::AccountMeta::new_readonly(
                    anchor_lang::Key::key(&self.owner),
                    true,
                ),
            );
            account_metas.push(
                anchor_lang::solana_program::instruction::AccountMeta::new_readonly(
                    anchor_lang::Key::key(&self.previous_delegate),
                    false,
                ),
            );
            account_metas.push(
                anchor_lang::solana_program::instruction::AccountMeta::new_readonly(
                    anchor_lang::Key::key(&self.new_delegate),
                    false,
                ),
            );
            account_metas.push(
                anchor_lang::solana_program::instruction::AccountMeta::new_readonly(
                    anchor_lang::Key::key(&self.candy_wrapper),
                    false,
                ),
            );
            account_metas.push(
                anchor_lang::solana_program::instruction::AccountMeta::new_readonly(
                    anchor_lang::Key::key(&self.gummyroll_program),
                    false,
                ),
            );
            account_metas.push(anchor_lang::solana_program::instruction::AccountMeta::new(
                anchor_lang::Key::key(&self.merkle_slab),
                false,
            ));
            account_metas
        }
    }
    #[automatically_derived]
    impl<'info> anchor_lang::ToAccountInfos<'info> for Delegate<'info> {
        fn to_account_infos(
            &self,
        ) -> Vec<anchor_lang::solana_program::account_info::AccountInfo<'info>> {
            let mut account_infos = ::alloc::vec::Vec::new();
            account_infos.push(anchor_lang::ToAccountInfo::to_account_info(&self.authority));
            account_infos.push(anchor_lang::ToAccountInfo::to_account_info(&self.owner));
            account_infos.push(anchor_lang::ToAccountInfo::to_account_info(
                &self.previous_delegate,
            ));
            account_infos.push(anchor_lang::ToAccountInfo::to_account_info(
                &self.new_delegate,
            ));
            account_infos.push(anchor_lang::ToAccountInfo::to_account_info(
                &self.candy_wrapper,
            ));
            account_infos.push(anchor_lang::ToAccountInfo::to_account_info(
                &self.gummyroll_program,
            ));
            account_infos.push(anchor_lang::ToAccountInfo::to_account_info(
                &self.merkle_slab,
            ));
            account_infos
        }
    }
}
# [instruction (_root : [u8 ; 32] , _data_hash : [u8 ; 32] , _creator_hash : [u8 ; 32] , nonce : u64 , _index : u32 ,)]
pub struct Redeem<'info> {
    # [account (seeds = [merkle_slab . key () . as_ref ()] , bump ,)]
    /// CHECK: This account is neither written to nor read from.
    pub authority: Account<'info, TreeConfig>,
    pub candy_wrapper: Program<'info, CandyWrapper>,
    pub gummyroll_program: Program<'info, Gummyroll>,
    #[account(mut)]
    pub owner: Signer<'info>,
    /// CHECK: This account is chekced in the instruction
    pub delegate: UncheckedAccount<'info>,
    #[account(mut)]
    /// CHECK: checked in cpi
    pub merkle_slab: UncheckedAccount<'info>,
    # [account (init , seeds = [VOUCHER_PREFIX . as_ref () , merkle_slab . key () . as_ref () , & nonce . to_le_bytes ()] , payer = owner , space = VOUCHER_SIZE , bump)]
    pub voucher: Account<'info, Voucher>,
    pub system_program: Program<'info, System>,
}
#[automatically_derived]
impl<'info> anchor_lang::Accounts<'info> for Redeem<'info>
where
    'info: 'info,
{
    #[inline(never)]
    fn try_accounts(
        program_id: &anchor_lang::solana_program::pubkey::Pubkey,
        accounts: &mut &[anchor_lang::solana_program::account_info::AccountInfo<'info>],
        ix_data: &[u8],
        __bumps: &mut std::collections::BTreeMap<String, u8>,
        __reallocs: &mut std::collections::BTreeSet<anchor_lang::solana_program::pubkey::Pubkey>,
    ) -> anchor_lang::Result<Self> {
        let mut ix_data = ix_data;
        struct __Args {
            _root: [u8; 32],
            _data_hash: [u8; 32],
            _creator_hash: [u8; 32],
            nonce: u64,
            _index: u32,
        }
        impl borsh::ser::BorshSerialize for __Args
        where
            [u8; 32]: borsh::ser::BorshSerialize,
            [u8; 32]: borsh::ser::BorshSerialize,
            [u8; 32]: borsh::ser::BorshSerialize,
            u64: borsh::ser::BorshSerialize,
            u32: borsh::ser::BorshSerialize,
        {
            fn serialize<W: borsh::maybestd::io::Write>(
                &self,
                writer: &mut W,
            ) -> ::core::result::Result<(), borsh::maybestd::io::Error> {
                borsh::BorshSerialize::serialize(&self._root, writer)?;
                borsh::BorshSerialize::serialize(&self._data_hash, writer)?;
                borsh::BorshSerialize::serialize(&self._creator_hash, writer)?;
                borsh::BorshSerialize::serialize(&self.nonce, writer)?;
                borsh::BorshSerialize::serialize(&self._index, writer)?;
                Ok(())
            }
        }
        impl borsh::de::BorshDeserialize for __Args
        where
            [u8; 32]: borsh::BorshDeserialize,
            [u8; 32]: borsh::BorshDeserialize,
            [u8; 32]: borsh::BorshDeserialize,
            u64: borsh::BorshDeserialize,
            u32: borsh::BorshDeserialize,
        {
            fn deserialize(
                buf: &mut &[u8],
            ) -> ::core::result::Result<Self, borsh::maybestd::io::Error> {
                Ok(Self {
                    _root: borsh::BorshDeserialize::deserialize(buf)?,
                    _data_hash: borsh::BorshDeserialize::deserialize(buf)?,
                    _creator_hash: borsh::BorshDeserialize::deserialize(buf)?,
                    nonce: borsh::BorshDeserialize::deserialize(buf)?,
                    _index: borsh::BorshDeserialize::deserialize(buf)?,
                })
            }
        }
        let __Args {
            _root,
            _data_hash,
            _creator_hash,
            nonce,
            _index,
        } = __Args::deserialize(&mut ix_data)
            .map_err(|_| anchor_lang::error::ErrorCode::InstructionDidNotDeserialize)?;
        let authority: anchor_lang::accounts::account::Account<TreeConfig> =
            anchor_lang::Accounts::try_accounts(program_id, accounts, ix_data, __bumps, __reallocs)
                .map_err(|e| e.with_account_name("authority"))?;
        let candy_wrapper: anchor_lang::accounts::program::Program<CandyWrapper> =
            anchor_lang::Accounts::try_accounts(program_id, accounts, ix_data, __bumps, __reallocs)
                .map_err(|e| e.with_account_name("candy_wrapper"))?;
        let gummyroll_program: anchor_lang::accounts::program::Program<Gummyroll> =
            anchor_lang::Accounts::try_accounts(program_id, accounts, ix_data, __bumps, __reallocs)
                .map_err(|e| e.with_account_name("gummyroll_program"))?;
        let owner: Signer =
            anchor_lang::Accounts::try_accounts(program_id, accounts, ix_data, __bumps, __reallocs)
                .map_err(|e| e.with_account_name("owner"))?;
        let delegate: UncheckedAccount =
            anchor_lang::Accounts::try_accounts(program_id, accounts, ix_data, __bumps, __reallocs)
                .map_err(|e| e.with_account_name("delegate"))?;
        let merkle_slab: UncheckedAccount =
            anchor_lang::Accounts::try_accounts(program_id, accounts, ix_data, __bumps, __reallocs)
                .map_err(|e| e.with_account_name("merkle_slab"))?;
        if accounts.is_empty() {
            return Err(anchor_lang::error::ErrorCode::AccountNotEnoughKeys.into());
        }
        let voucher = &accounts[0];
        *accounts = &accounts[1..];
        let system_program: anchor_lang::accounts::program::Program<System> =
            anchor_lang::Accounts::try_accounts(program_id, accounts, ix_data, __bumps, __reallocs)
                .map_err(|e| e.with_account_name("system_program"))?;
        let __anchor_rent = Rent::get()?;
        let (__pda_address, __bump) = Pubkey::find_program_address(
            &[
                VOUCHER_PREFIX.as_ref(),
                merkle_slab.key().as_ref(),
                &nonce.to_le_bytes(),
            ],
            program_id,
        );
        __bumps.insert("voucher".to_string(), __bump);
        let voucher = {
            let actual_field = voucher.to_account_info();
            let actual_owner = actual_field.owner;
            let space = VOUCHER_SIZE;
            let pa: anchor_lang::accounts::account::Account<Voucher> =
                if !false || actual_owner == &anchor_lang::solana_program::system_program::ID {
                    let payer = owner.to_account_info();
                    let __current_lamports = voucher.lamports();
                    if __current_lamports == 0 {
                        let lamports = __anchor_rent.minimum_balance(space);
                        let cpi_accounts = anchor_lang::system_program::CreateAccount {
                            from: payer.to_account_info(),
                            to: voucher.to_account_info(),
                        };
                        let cpi_context = anchor_lang::context::CpiContext::new(
                            system_program.to_account_info(),
                            cpi_accounts,
                        );
                        anchor_lang::system_program::create_account(
                            cpi_context.with_signer(&[&[
                                VOUCHER_PREFIX.as_ref(),
                                merkle_slab.key().as_ref(),
                                &nonce.to_le_bytes(),
                                &[__bump][..],
                            ][..]]),
                            lamports,
                            space as u64,
                            program_id,
                        )?;
                    } else {
                        let required_lamports = __anchor_rent
                            .minimum_balance(space)
                            .max(1)
                            .saturating_sub(__current_lamports);
                        if required_lamports > 0 {
                            let cpi_accounts = anchor_lang::system_program::Transfer {
                                from: payer.to_account_info(),
                                to: voucher.to_account_info(),
                            };
                            let cpi_context = anchor_lang::context::CpiContext::new(
                                system_program.to_account_info(),
                                cpi_accounts,
                            );
                            anchor_lang::system_program::transfer(cpi_context, required_lamports)?;
                        }
                        let cpi_accounts = anchor_lang::system_program::Allocate {
                            account_to_allocate: voucher.to_account_info(),
                        };
                        let cpi_context = anchor_lang::context::CpiContext::new(
                            system_program.to_account_info(),
                            cpi_accounts,
                        );
                        anchor_lang::system_program::allocate(
                            cpi_context.with_signer(&[&[
                                VOUCHER_PREFIX.as_ref(),
                                merkle_slab.key().as_ref(),
                                &nonce.to_le_bytes(),
                                &[__bump][..],
                            ][..]]),
                            space as u64,
                        )?;
                        let cpi_accounts = anchor_lang::system_program::Assign {
                            account_to_assign: voucher.to_account_info(),
                        };
                        let cpi_context = anchor_lang::context::CpiContext::new(
                            system_program.to_account_info(),
                            cpi_accounts,
                        );
                        anchor_lang::system_program::assign(
                            cpi_context.with_signer(&[&[
                                VOUCHER_PREFIX.as_ref(),
                                merkle_slab.key().as_ref(),
                                &nonce.to_le_bytes(),
                                &[__bump][..],
                            ][..]]),
                            program_id,
                        )?;
                    }
                    anchor_lang::accounts::account::Account::try_from_unchecked(&voucher)
                        .map_err(|e| e.with_account_name("voucher"))?
                } else {
                    anchor_lang::accounts::account::Account::try_from(&voucher)
                        .map_err(|e| e.with_account_name("voucher"))?
                };
            if false {
                if space != actual_field.data_len() {
                    return Err(anchor_lang::error::Error::from(
                        anchor_lang::error::ErrorCode::ConstraintSpace,
                    )
                    .with_account_name("voucher")
                    .with_values((space, actual_field.data_len())));
                }
                if actual_owner != program_id {
                    return Err(anchor_lang::error::Error::from(
                        anchor_lang::error::ErrorCode::ConstraintOwner,
                    )
                    .with_account_name("voucher")
                    .with_pubkeys((*actual_owner, *program_id)));
                }
                {
                    let required_lamports = __anchor_rent.minimum_balance(space);
                    if pa.to_account_info().lamports() < required_lamports {
                        return Err(anchor_lang::error::Error::from(
                            anchor_lang::error::ErrorCode::ConstraintRentExempt,
                        )
                        .with_account_name("voucher"));
                    }
                }
            }
            pa
        };
        if voucher.key() != __pda_address {
            return Err(anchor_lang::error::Error::from(
                anchor_lang::error::ErrorCode::ConstraintSeeds,
            )
            .with_account_name("voucher")
            .with_pubkeys((voucher.key(), __pda_address)));
        }
        if !voucher.to_account_info().is_writable {
            return Err(anchor_lang::error::Error::from(
                anchor_lang::error::ErrorCode::ConstraintMut,
            )
            .with_account_name("voucher"));
        }
        if !__anchor_rent.is_exempt(
            voucher.to_account_info().lamports(),
            voucher.to_account_info().try_data_len()?,
        ) {
            return Err(anchor_lang::error::Error::from(
                anchor_lang::error::ErrorCode::ConstraintRentExempt,
            )
            .with_account_name("voucher"));
        }
        let (__pda_address, __bump) =
            Pubkey::find_program_address(&[merkle_slab.key().as_ref()], &program_id);
        __bumps.insert("authority".to_string(), __bump);
        if authority.key() != __pda_address {
            return Err(anchor_lang::error::Error::from(
                anchor_lang::error::ErrorCode::ConstraintSeeds,
            )
            .with_account_name("authority")
            .with_pubkeys((authority.key(), __pda_address)));
        }
        if !owner.to_account_info().is_writable {
            return Err(anchor_lang::error::Error::from(
                anchor_lang::error::ErrorCode::ConstraintMut,
            )
            .with_account_name("owner"));
        }
        if !merkle_slab.to_account_info().is_writable {
            return Err(anchor_lang::error::Error::from(
                anchor_lang::error::ErrorCode::ConstraintMut,
            )
            .with_account_name("merkle_slab"));
        }
        Ok(Redeem {
            authority,
            candy_wrapper,
            gummyroll_program,
            owner,
            delegate,
            merkle_slab,
            voucher,
            system_program,
        })
    }
}
#[automatically_derived]
impl<'info> anchor_lang::ToAccountInfos<'info> for Redeem<'info>
where
    'info: 'info,
{
    fn to_account_infos(
        &self,
    ) -> Vec<anchor_lang::solana_program::account_info::AccountInfo<'info>> {
        let mut account_infos = ::alloc::vec::Vec::new();
        account_infos.extend(self.authority.to_account_infos());
        account_infos.extend(self.candy_wrapper.to_account_infos());
        account_infos.extend(self.gummyroll_program.to_account_infos());
        account_infos.extend(self.owner.to_account_infos());
        account_infos.extend(self.delegate.to_account_infos());
        account_infos.extend(self.merkle_slab.to_account_infos());
        account_infos.extend(self.voucher.to_account_infos());
        account_infos.extend(self.system_program.to_account_infos());
        account_infos
    }
}
#[automatically_derived]
impl<'info> anchor_lang::ToAccountMetas for Redeem<'info> {
    fn to_account_metas(
        &self,
        is_signer: Option<bool>,
    ) -> Vec<anchor_lang::solana_program::instruction::AccountMeta> {
        let mut account_metas = ::alloc::vec::Vec::new();
        account_metas.extend(self.authority.to_account_metas(None));
        account_metas.extend(self.candy_wrapper.to_account_metas(None));
        account_metas.extend(self.gummyroll_program.to_account_metas(None));
        account_metas.extend(self.owner.to_account_metas(None));
        account_metas.extend(self.delegate.to_account_metas(None));
        account_metas.extend(self.merkle_slab.to_account_metas(None));
        account_metas.extend(self.voucher.to_account_metas(None));
        account_metas.extend(self.system_program.to_account_metas(None));
        account_metas
    }
}
#[automatically_derived]
impl<'info> anchor_lang::AccountsExit<'info> for Redeem<'info>
where
    'info: 'info,
{
    fn exit(
        &self,
        program_id: &anchor_lang::solana_program::pubkey::Pubkey,
    ) -> anchor_lang::Result<()> {
        anchor_lang::AccountsExit::exit(&self.owner, program_id)
            .map_err(|e| e.with_account_name("owner"))?;
        anchor_lang::AccountsExit::exit(&self.merkle_slab, program_id)
            .map_err(|e| e.with_account_name("merkle_slab"))?;
        anchor_lang::AccountsExit::exit(&self.voucher, program_id)
            .map_err(|e| e.with_account_name("voucher"))?;
        Ok(())
    }
}
/// An internal, Anchor generated module. This is used (as an
/// implementation detail), to generate a struct for a given
/// `#[derive(Accounts)]` implementation, where each field is a Pubkey,
/// instead of an `AccountInfo`. This is useful for clients that want
/// to generate a list of accounts, without explicitly knowing the
/// order all the fields should be in.
///
/// To access the struct in this module, one should use the sibling
/// `accounts` module (also generated), which re-exports this.
pub(crate) mod __client_accounts_redeem {
    use super::*;
    use anchor_lang::prelude::borsh;
    /// Generated client accounts for [`Redeem`].
    pub struct Redeem {
        pub authority: anchor_lang::solana_program::pubkey::Pubkey,
        pub candy_wrapper: anchor_lang::solana_program::pubkey::Pubkey,
        pub gummyroll_program: anchor_lang::solana_program::pubkey::Pubkey,
        pub owner: anchor_lang::solana_program::pubkey::Pubkey,
        pub delegate: anchor_lang::solana_program::pubkey::Pubkey,
        pub merkle_slab: anchor_lang::solana_program::pubkey::Pubkey,
        pub voucher: anchor_lang::solana_program::pubkey::Pubkey,
        pub system_program: anchor_lang::solana_program::pubkey::Pubkey,
    }
    impl borsh::ser::BorshSerialize for Redeem
    where
        anchor_lang::solana_program::pubkey::Pubkey: borsh::ser::BorshSerialize,
        anchor_lang::solana_program::pubkey::Pubkey: borsh::ser::BorshSerialize,
        anchor_lang::solana_program::pubkey::Pubkey: borsh::ser::BorshSerialize,
        anchor_lang::solana_program::pubkey::Pubkey: borsh::ser::BorshSerialize,
        anchor_lang::solana_program::pubkey::Pubkey: borsh::ser::BorshSerialize,
        anchor_lang::solana_program::pubkey::Pubkey: borsh::ser::BorshSerialize,
        anchor_lang::solana_program::pubkey::Pubkey: borsh::ser::BorshSerialize,
        anchor_lang::solana_program::pubkey::Pubkey: borsh::ser::BorshSerialize,
    {
        fn serialize<W: borsh::maybestd::io::Write>(
            &self,
            writer: &mut W,
        ) -> ::core::result::Result<(), borsh::maybestd::io::Error> {
            borsh::BorshSerialize::serialize(&self.authority, writer)?;
            borsh::BorshSerialize::serialize(&self.candy_wrapper, writer)?;
            borsh::BorshSerialize::serialize(&self.gummyroll_program, writer)?;
            borsh::BorshSerialize::serialize(&self.owner, writer)?;
            borsh::BorshSerialize::serialize(&self.delegate, writer)?;
            borsh::BorshSerialize::serialize(&self.merkle_slab, writer)?;
            borsh::BorshSerialize::serialize(&self.voucher, writer)?;
            borsh::BorshSerialize::serialize(&self.system_program, writer)?;
            Ok(())
        }
    }
    #[automatically_derived]
    impl anchor_lang::ToAccountMetas for Redeem {
        fn to_account_metas(
            &self,
            is_signer: Option<bool>,
        ) -> Vec<anchor_lang::solana_program::instruction::AccountMeta> {
            let mut account_metas = ::alloc::vec::Vec::new();
            account_metas.push(
                anchor_lang::solana_program::instruction::AccountMeta::new_readonly(
                    self.authority,
                    false,
                ),
            );
            account_metas.push(
                anchor_lang::solana_program::instruction::AccountMeta::new_readonly(
                    self.candy_wrapper,
                    false,
                ),
            );
            account_metas.push(
                anchor_lang::solana_program::instruction::AccountMeta::new_readonly(
                    self.gummyroll_program,
                    false,
                ),
            );
            account_metas.push(anchor_lang::solana_program::instruction::AccountMeta::new(
                self.owner, true,
            ));
            account_metas.push(
                anchor_lang::solana_program::instruction::AccountMeta::new_readonly(
                    self.delegate,
                    false,
                ),
            );
            account_metas.push(anchor_lang::solana_program::instruction::AccountMeta::new(
                self.merkle_slab,
                false,
            ));
            account_metas.push(anchor_lang::solana_program::instruction::AccountMeta::new(
                self.voucher,
                false,
            ));
            account_metas.push(
                anchor_lang::solana_program::instruction::AccountMeta::new_readonly(
                    self.system_program,
                    false,
                ),
            );
            account_metas
        }
    }
}
/// An internal, Anchor generated module. This is used (as an
/// implementation detail), to generate a CPI struct for a given
/// `#[derive(Accounts)]` implementation, where each field is an
/// AccountInfo.
///
/// To access the struct in this module, one should use the sibling
/// [`cpi::accounts`] module (also generated), which re-exports this.
pub(crate) mod __cpi_client_accounts_redeem {
    use super::*;
    /// Generated CPI struct of the accounts for [`Redeem`].
    pub struct Redeem<'info> {
        pub authority: anchor_lang::solana_program::account_info::AccountInfo<'info>,
        pub candy_wrapper: anchor_lang::solana_program::account_info::AccountInfo<'info>,
        pub gummyroll_program: anchor_lang::solana_program::account_info::AccountInfo<'info>,
        pub owner: anchor_lang::solana_program::account_info::AccountInfo<'info>,
        pub delegate: anchor_lang::solana_program::account_info::AccountInfo<'info>,
        pub merkle_slab: anchor_lang::solana_program::account_info::AccountInfo<'info>,
        pub voucher: anchor_lang::solana_program::account_info::AccountInfo<'info>,
        pub system_program: anchor_lang::solana_program::account_info::AccountInfo<'info>,
    }
    #[automatically_derived]
    impl<'info> anchor_lang::ToAccountMetas for Redeem<'info> {
        fn to_account_metas(
            &self,
            is_signer: Option<bool>,
        ) -> Vec<anchor_lang::solana_program::instruction::AccountMeta> {
            let mut account_metas = ::alloc::vec::Vec::new();
            account_metas.push(
                anchor_lang::solana_program::instruction::AccountMeta::new_readonly(
                    anchor_lang::Key::key(&self.authority),
                    false,
                ),
            );
            account_metas.push(
                anchor_lang::solana_program::instruction::AccountMeta::new_readonly(
                    anchor_lang::Key::key(&self.candy_wrapper),
                    false,
                ),
            );
            account_metas.push(
                anchor_lang::solana_program::instruction::AccountMeta::new_readonly(
                    anchor_lang::Key::key(&self.gummyroll_program),
                    false,
                ),
            );
            account_metas.push(anchor_lang::solana_program::instruction::AccountMeta::new(
                anchor_lang::Key::key(&self.owner),
                true,
            ));
            account_metas.push(
                anchor_lang::solana_program::instruction::AccountMeta::new_readonly(
                    anchor_lang::Key::key(&self.delegate),
                    false,
                ),
            );
            account_metas.push(anchor_lang::solana_program::instruction::AccountMeta::new(
                anchor_lang::Key::key(&self.merkle_slab),
                false,
            ));
            account_metas.push(anchor_lang::solana_program::instruction::AccountMeta::new(
                anchor_lang::Key::key(&self.voucher),
                false,
            ));
            account_metas.push(
                anchor_lang::solana_program::instruction::AccountMeta::new_readonly(
                    anchor_lang::Key::key(&self.system_program),
                    false,
                ),
            );
            account_metas
        }
    }
    #[automatically_derived]
    impl<'info> anchor_lang::ToAccountInfos<'info> for Redeem<'info> {
        fn to_account_infos(
            &self,
        ) -> Vec<anchor_lang::solana_program::account_info::AccountInfo<'info>> {
            let mut account_infos = ::alloc::vec::Vec::new();
            account_infos.push(anchor_lang::ToAccountInfo::to_account_info(&self.authority));
            account_infos.push(anchor_lang::ToAccountInfo::to_account_info(
                &self.candy_wrapper,
            ));
            account_infos.push(anchor_lang::ToAccountInfo::to_account_info(
                &self.gummyroll_program,
            ));
            account_infos.push(anchor_lang::ToAccountInfo::to_account_info(&self.owner));
            account_infos.push(anchor_lang::ToAccountInfo::to_account_info(&self.delegate));
            account_infos.push(anchor_lang::ToAccountInfo::to_account_info(
                &self.merkle_slab,
            ));
            account_infos.push(anchor_lang::ToAccountInfo::to_account_info(&self.voucher));
            account_infos.push(anchor_lang::ToAccountInfo::to_account_info(
                &self.system_program,
            ));
            account_infos
        }
    }
}
pub struct CancelRedeem<'info> {
    # [account (seeds = [merkle_slab . key () . as_ref ()] , bump ,)]
    /// CHECK: This account is neither written to nor read from.
    pub authority: Account<'info, TreeConfig>,
    pub candy_wrapper: Program<'info, CandyWrapper>,
    pub gummyroll_program: Program<'info, Gummyroll>,
    #[account(mut)]
    /// CHECK: unsafe
    pub merkle_slab: UncheckedAccount<'info>,
    # [account (mut , close = owner , seeds = [VOUCHER_PREFIX . as_ref () , merkle_slab . key () . as_ref () , & voucher . leaf_schema . nonce () . to_le_bytes ()] , bump)]
    pub voucher: Account<'info, Voucher>,
    #[account(mut)]
    pub owner: Signer<'info>,
}
#[automatically_derived]
impl<'info> anchor_lang::Accounts<'info> for CancelRedeem<'info>
where
    'info: 'info,
{
    #[inline(never)]
    fn try_accounts(
        program_id: &anchor_lang::solana_program::pubkey::Pubkey,
        accounts: &mut &[anchor_lang::solana_program::account_info::AccountInfo<'info>],
        ix_data: &[u8],
        __bumps: &mut std::collections::BTreeMap<String, u8>,
        __reallocs: &mut std::collections::BTreeSet<anchor_lang::solana_program::pubkey::Pubkey>,
    ) -> anchor_lang::Result<Self> {
        let authority: anchor_lang::accounts::account::Account<TreeConfig> =
            anchor_lang::Accounts::try_accounts(program_id, accounts, ix_data, __bumps, __reallocs)
                .map_err(|e| e.with_account_name("authority"))?;
        let candy_wrapper: anchor_lang::accounts::program::Program<CandyWrapper> =
            anchor_lang::Accounts::try_accounts(program_id, accounts, ix_data, __bumps, __reallocs)
                .map_err(|e| e.with_account_name("candy_wrapper"))?;
        let gummyroll_program: anchor_lang::accounts::program::Program<Gummyroll> =
            anchor_lang::Accounts::try_accounts(program_id, accounts, ix_data, __bumps, __reallocs)
                .map_err(|e| e.with_account_name("gummyroll_program"))?;
        let merkle_slab: UncheckedAccount =
            anchor_lang::Accounts::try_accounts(program_id, accounts, ix_data, __bumps, __reallocs)
                .map_err(|e| e.with_account_name("merkle_slab"))?;
        let voucher: anchor_lang::accounts::account::Account<Voucher> =
            anchor_lang::Accounts::try_accounts(program_id, accounts, ix_data, __bumps, __reallocs)
                .map_err(|e| e.with_account_name("voucher"))?;
        let owner: Signer =
            anchor_lang::Accounts::try_accounts(program_id, accounts, ix_data, __bumps, __reallocs)
                .map_err(|e| e.with_account_name("owner"))?;
        let (__pda_address, __bump) =
            Pubkey::find_program_address(&[merkle_slab.key().as_ref()], &program_id);
        __bumps.insert("authority".to_string(), __bump);
        if authority.key() != __pda_address {
            return Err(anchor_lang::error::Error::from(
                anchor_lang::error::ErrorCode::ConstraintSeeds,
            )
            .with_account_name("authority")
            .with_pubkeys((authority.key(), __pda_address)));
        }
        if !merkle_slab.to_account_info().is_writable {
            return Err(anchor_lang::error::Error::from(
                anchor_lang::error::ErrorCode::ConstraintMut,
            )
            .with_account_name("merkle_slab"));
        }
        let (__pda_address, __bump) = Pubkey::find_program_address(
            &[
                VOUCHER_PREFIX.as_ref(),
                merkle_slab.key().as_ref(),
                &voucher.leaf_schema.nonce().to_le_bytes(),
            ],
            &program_id,
        );
        __bumps.insert("voucher".to_string(), __bump);
        if voucher.key() != __pda_address {
            return Err(anchor_lang::error::Error::from(
                anchor_lang::error::ErrorCode::ConstraintSeeds,
            )
            .with_account_name("voucher")
            .with_pubkeys((voucher.key(), __pda_address)));
        }
        if !voucher.to_account_info().is_writable {
            return Err(anchor_lang::error::Error::from(
                anchor_lang::error::ErrorCode::ConstraintMut,
            )
            .with_account_name("voucher"));
        }
        if voucher.key() == owner.key() {
            return Err(anchor_lang::error::Error::from(
                anchor_lang::error::ErrorCode::ConstraintClose,
            )
            .with_account_name("voucher"));
        }
        if !owner.to_account_info().is_writable {
            return Err(anchor_lang::error::Error::from(
                anchor_lang::error::ErrorCode::ConstraintMut,
            )
            .with_account_name("owner"));
        }
        Ok(CancelRedeem {
            authority,
            candy_wrapper,
            gummyroll_program,
            merkle_slab,
            voucher,
            owner,
        })
    }
}
#[automatically_derived]
impl<'info> anchor_lang::ToAccountInfos<'info> for CancelRedeem<'info>
where
    'info: 'info,
{
    fn to_account_infos(
        &self,
    ) -> Vec<anchor_lang::solana_program::account_info::AccountInfo<'info>> {
        let mut account_infos = ::alloc::vec::Vec::new();
        account_infos.extend(self.authority.to_account_infos());
        account_infos.extend(self.candy_wrapper.to_account_infos());
        account_infos.extend(self.gummyroll_program.to_account_infos());
        account_infos.extend(self.merkle_slab.to_account_infos());
        account_infos.extend(self.voucher.to_account_infos());
        account_infos.extend(self.owner.to_account_infos());
        account_infos
    }
}
#[automatically_derived]
impl<'info> anchor_lang::ToAccountMetas for CancelRedeem<'info> {
    fn to_account_metas(
        &self,
        is_signer: Option<bool>,
    ) -> Vec<anchor_lang::solana_program::instruction::AccountMeta> {
        let mut account_metas = ::alloc::vec::Vec::new();
        account_metas.extend(self.authority.to_account_metas(None));
        account_metas.extend(self.candy_wrapper.to_account_metas(None));
        account_metas.extend(self.gummyroll_program.to_account_metas(None));
        account_metas.extend(self.merkle_slab.to_account_metas(None));
        account_metas.extend(self.voucher.to_account_metas(None));
        account_metas.extend(self.owner.to_account_metas(None));
        account_metas
    }
}
#[automatically_derived]
impl<'info> anchor_lang::AccountsExit<'info> for CancelRedeem<'info>
where
    'info: 'info,
{
    fn exit(
        &self,
        program_id: &anchor_lang::solana_program::pubkey::Pubkey,
    ) -> anchor_lang::Result<()> {
        anchor_lang::AccountsExit::exit(&self.merkle_slab, program_id)
            .map_err(|e| e.with_account_name("merkle_slab"))?;
        anchor_lang::AccountsClose::close(&self.voucher, self.owner.to_account_info())
            .map_err(|e| e.with_account_name("voucher"))?;
        anchor_lang::AccountsExit::exit(&self.owner, program_id)
            .map_err(|e| e.with_account_name("owner"))?;
        Ok(())
    }
}
/// An internal, Anchor generated module. This is used (as an
/// implementation detail), to generate a struct for a given
/// `#[derive(Accounts)]` implementation, where each field is a Pubkey,
/// instead of an `AccountInfo`. This is useful for clients that want
/// to generate a list of accounts, without explicitly knowing the
/// order all the fields should be in.
///
/// To access the struct in this module, one should use the sibling
/// `accounts` module (also generated), which re-exports this.
pub(crate) mod __client_accounts_cancel_redeem {
    use super::*;
    use anchor_lang::prelude::borsh;
    /// Generated client accounts for [`CancelRedeem`].
    pub struct CancelRedeem {
        pub authority: anchor_lang::solana_program::pubkey::Pubkey,
        pub candy_wrapper: anchor_lang::solana_program::pubkey::Pubkey,
        pub gummyroll_program: anchor_lang::solana_program::pubkey::Pubkey,
        pub merkle_slab: anchor_lang::solana_program::pubkey::Pubkey,
        pub voucher: anchor_lang::solana_program::pubkey::Pubkey,
        pub owner: anchor_lang::solana_program::pubkey::Pubkey,
    }
    impl borsh::ser::BorshSerialize for CancelRedeem
    where
        anchor_lang::solana_program::pubkey::Pubkey: borsh::ser::BorshSerialize,
        anchor_lang::solana_program::pubkey::Pubkey: borsh::ser::BorshSerialize,
        anchor_lang::solana_program::pubkey::Pubkey: borsh::ser::BorshSerialize,
        anchor_lang::solana_program::pubkey::Pubkey: borsh::ser::BorshSerialize,
        anchor_lang::solana_program::pubkey::Pubkey: borsh::ser::BorshSerialize,
        anchor_lang::solana_program::pubkey::Pubkey: borsh::ser::BorshSerialize,
    {
        fn serialize<W: borsh::maybestd::io::Write>(
            &self,
            writer: &mut W,
        ) -> ::core::result::Result<(), borsh::maybestd::io::Error> {
            borsh::BorshSerialize::serialize(&self.authority, writer)?;
            borsh::BorshSerialize::serialize(&self.candy_wrapper, writer)?;
            borsh::BorshSerialize::serialize(&self.gummyroll_program, writer)?;
            borsh::BorshSerialize::serialize(&self.merkle_slab, writer)?;
            borsh::BorshSerialize::serialize(&self.voucher, writer)?;
            borsh::BorshSerialize::serialize(&self.owner, writer)?;
            Ok(())
        }
    }
    #[automatically_derived]
    impl anchor_lang::ToAccountMetas for CancelRedeem {
        fn to_account_metas(
            &self,
            is_signer: Option<bool>,
        ) -> Vec<anchor_lang::solana_program::instruction::AccountMeta> {
            let mut account_metas = ::alloc::vec::Vec::new();
            account_metas.push(
                anchor_lang::solana_program::instruction::AccountMeta::new_readonly(
                    self.authority,
                    false,
                ),
            );
            account_metas.push(
                anchor_lang::solana_program::instruction::AccountMeta::new_readonly(
                    self.candy_wrapper,
                    false,
                ),
            );
            account_metas.push(
                anchor_lang::solana_program::instruction::AccountMeta::new_readonly(
                    self.gummyroll_program,
                    false,
                ),
            );
            account_metas.push(anchor_lang::solana_program::instruction::AccountMeta::new(
                self.merkle_slab,
                false,
            ));
            account_metas.push(anchor_lang::solana_program::instruction::AccountMeta::new(
                self.voucher,
                false,
            ));
            account_metas.push(anchor_lang::solana_program::instruction::AccountMeta::new(
                self.owner, true,
            ));
            account_metas
        }
    }
}
/// An internal, Anchor generated module. This is used (as an
/// implementation detail), to generate a CPI struct for a given
/// `#[derive(Accounts)]` implementation, where each field is an
/// AccountInfo.
///
/// To access the struct in this module, one should use the sibling
/// [`cpi::accounts`] module (also generated), which re-exports this.
pub(crate) mod __cpi_client_accounts_cancel_redeem {
    use super::*;
    /// Generated CPI struct of the accounts for [`CancelRedeem`].
    pub struct CancelRedeem<'info> {
        pub authority: anchor_lang::solana_program::account_info::AccountInfo<'info>,
        pub candy_wrapper: anchor_lang::solana_program::account_info::AccountInfo<'info>,
        pub gummyroll_program: anchor_lang::solana_program::account_info::AccountInfo<'info>,
        pub merkle_slab: anchor_lang::solana_program::account_info::AccountInfo<'info>,
        pub voucher: anchor_lang::solana_program::account_info::AccountInfo<'info>,
        pub owner: anchor_lang::solana_program::account_info::AccountInfo<'info>,
    }
    #[automatically_derived]
    impl<'info> anchor_lang::ToAccountMetas for CancelRedeem<'info> {
        fn to_account_metas(
            &self,
            is_signer: Option<bool>,
        ) -> Vec<anchor_lang::solana_program::instruction::AccountMeta> {
            let mut account_metas = ::alloc::vec::Vec::new();
            account_metas.push(
                anchor_lang::solana_program::instruction::AccountMeta::new_readonly(
                    anchor_lang::Key::key(&self.authority),
                    false,
                ),
            );
            account_metas.push(
                anchor_lang::solana_program::instruction::AccountMeta::new_readonly(
                    anchor_lang::Key::key(&self.candy_wrapper),
                    false,
                ),
            );
            account_metas.push(
                anchor_lang::solana_program::instruction::AccountMeta::new_readonly(
                    anchor_lang::Key::key(&self.gummyroll_program),
                    false,
                ),
            );
            account_metas.push(anchor_lang::solana_program::instruction::AccountMeta::new(
                anchor_lang::Key::key(&self.merkle_slab),
                false,
            ));
            account_metas.push(anchor_lang::solana_program::instruction::AccountMeta::new(
                anchor_lang::Key::key(&self.voucher),
                false,
            ));
            account_metas.push(anchor_lang::solana_program::instruction::AccountMeta::new(
                anchor_lang::Key::key(&self.owner),
                true,
            ));
            account_metas
        }
    }
    #[automatically_derived]
    impl<'info> anchor_lang::ToAccountInfos<'info> for CancelRedeem<'info> {
        fn to_account_infos(
            &self,
        ) -> Vec<anchor_lang::solana_program::account_info::AccountInfo<'info>> {
            let mut account_infos = ::alloc::vec::Vec::new();
            account_infos.push(anchor_lang::ToAccountInfo::to_account_info(&self.authority));
            account_infos.push(anchor_lang::ToAccountInfo::to_account_info(
                &self.candy_wrapper,
            ));
            account_infos.push(anchor_lang::ToAccountInfo::to_account_info(
                &self.gummyroll_program,
            ));
            account_infos.push(anchor_lang::ToAccountInfo::to_account_info(
                &self.merkle_slab,
            ));
            account_infos.push(anchor_lang::ToAccountInfo::to_account_info(&self.voucher));
            account_infos.push(anchor_lang::ToAccountInfo::to_account_info(&self.owner));
            account_infos
        }
    }
}
pub struct DecompressV1<'info> {
    # [account (mut , close = owner , seeds = [VOUCHER_PREFIX . as_ref () , voucher . merkle_slab . as_ref () , voucher . leaf_schema . nonce () . to_le_bytes () . as_ref ()] , bump)]
    pub voucher: Box<Account<'info, Voucher>>,
    #[account(mut)]
    pub owner: Signer<'info>,
    /// CHECK: versioning is handled in the instruction
    #[account(mut)]
    pub token_account: UncheckedAccount<'info>,
    /// CHECK: versioning is handled in the instruction
    # [account (mut , seeds = [ASSET_PREFIX . as_ref () , voucher . merkle_slab . as_ref () , voucher . leaf_schema . nonce () . to_le_bytes () . as_ref () ,] , bump)]
    pub mint: UncheckedAccount<'info>,
    /// CHECK:
    # [account (seeds = [mint . key () . as_ref ()] , bump ,)]
    pub mint_authority: UncheckedAccount<'info>,
    /// CHECK:
    #[account(mut)]
    pub metadata: UncheckedAccount<'info>,
    /// CHECK: Initialized in Token Metadata Program
    #[account(mut)]
    pub master_edition: UncheckedAccount<'info>,
    pub system_program: Program<'info, System>,
    pub sysvar_rent: Sysvar<'info, Rent>,
    /// CHECK:
    pub token_metadata_program: Program<'info, MplTokenMetadata>,
    /// CHECK: versioning is handled in the instruction
    pub token_program: UncheckedAccount<'info>,
    /// CHECK:
    pub associated_token_program: UncheckedAccount<'info>,
}
#[automatically_derived]
impl<'info> anchor_lang::Accounts<'info> for DecompressV1<'info>
where
    'info: 'info,
{
    #[inline(never)]
    fn try_accounts(
        program_id: &anchor_lang::solana_program::pubkey::Pubkey,
        accounts: &mut &[anchor_lang::solana_program::account_info::AccountInfo<'info>],
        ix_data: &[u8],
        __bumps: &mut std::collections::BTreeMap<String, u8>,
        __reallocs: &mut std::collections::BTreeSet<anchor_lang::solana_program::pubkey::Pubkey>,
    ) -> anchor_lang::Result<Self> {
        let voucher: Box<anchor_lang::accounts::account::Account<Voucher>> =
            anchor_lang::Accounts::try_accounts(program_id, accounts, ix_data, __bumps, __reallocs)
                .map_err(|e| e.with_account_name("voucher"))?;
        let owner: Signer =
            anchor_lang::Accounts::try_accounts(program_id, accounts, ix_data, __bumps, __reallocs)
                .map_err(|e| e.with_account_name("owner"))?;
        let token_account: UncheckedAccount =
            anchor_lang::Accounts::try_accounts(program_id, accounts, ix_data, __bumps, __reallocs)
                .map_err(|e| e.with_account_name("token_account"))?;
        let mint: UncheckedAccount =
            anchor_lang::Accounts::try_accounts(program_id, accounts, ix_data, __bumps, __reallocs)
                .map_err(|e| e.with_account_name("mint"))?;
        let mint_authority: UncheckedAccount =
            anchor_lang::Accounts::try_accounts(program_id, accounts, ix_data, __bumps, __reallocs)
                .map_err(|e| e.with_account_name("mint_authority"))?;
        let metadata: UncheckedAccount =
            anchor_lang::Accounts::try_accounts(program_id, accounts, ix_data, __bumps, __reallocs)
                .map_err(|e| e.with_account_name("metadata"))?;
        let master_edition: UncheckedAccount =
            anchor_lang::Accounts::try_accounts(program_id, accounts, ix_data, __bumps, __reallocs)
                .map_err(|e| e.with_account_name("master_edition"))?;
        let system_program: anchor_lang::accounts::program::Program<System> =
            anchor_lang::Accounts::try_accounts(program_id, accounts, ix_data, __bumps, __reallocs)
                .map_err(|e| e.with_account_name("system_program"))?;
        let sysvar_rent: Sysvar<Rent> =
            anchor_lang::Accounts::try_accounts(program_id, accounts, ix_data, __bumps, __reallocs)
                .map_err(|e| e.with_account_name("sysvar_rent"))?;
        let token_metadata_program: anchor_lang::accounts::program::Program<MplTokenMetadata> =
            anchor_lang::Accounts::try_accounts(program_id, accounts, ix_data, __bumps, __reallocs)
                .map_err(|e| e.with_account_name("token_metadata_program"))?;
        let token_program: UncheckedAccount =
            anchor_lang::Accounts::try_accounts(program_id, accounts, ix_data, __bumps, __reallocs)
                .map_err(|e| e.with_account_name("token_program"))?;
        let associated_token_program: UncheckedAccount =
            anchor_lang::Accounts::try_accounts(program_id, accounts, ix_data, __bumps, __reallocs)
                .map_err(|e| e.with_account_name("associated_token_program"))?;
        let (__pda_address, __bump) = Pubkey::find_program_address(
            &[
                VOUCHER_PREFIX.as_ref(),
                voucher.merkle_slab.as_ref(),
                voucher.leaf_schema.nonce().to_le_bytes().as_ref(),
            ],
            &program_id,
        );
        __bumps.insert("voucher".to_string(), __bump);
        if voucher.key() != __pda_address {
            return Err(anchor_lang::error::Error::from(
                anchor_lang::error::ErrorCode::ConstraintSeeds,
            )
            .with_account_name("voucher")
            .with_pubkeys((voucher.key(), __pda_address)));
        }
        if !voucher.to_account_info().is_writable {
            return Err(anchor_lang::error::Error::from(
                anchor_lang::error::ErrorCode::ConstraintMut,
            )
            .with_account_name("voucher"));
        }
        if voucher.key() == owner.key() {
            return Err(anchor_lang::error::Error::from(
                anchor_lang::error::ErrorCode::ConstraintClose,
            )
            .with_account_name("voucher"));
        }
        if !owner.to_account_info().is_writable {
            return Err(anchor_lang::error::Error::from(
                anchor_lang::error::ErrorCode::ConstraintMut,
            )
            .with_account_name("owner"));
        }
        if !token_account.to_account_info().is_writable {
            return Err(anchor_lang::error::Error::from(
                anchor_lang::error::ErrorCode::ConstraintMut,
            )
            .with_account_name("token_account"));
        }
        let (__pda_address, __bump) = Pubkey::find_program_address(
            &[
                ASSET_PREFIX.as_ref(),
                voucher.merkle_slab.as_ref(),
                voucher.leaf_schema.nonce().to_le_bytes().as_ref(),
            ],
            &program_id,
        );
        __bumps.insert("mint".to_string(), __bump);
        if mint.key() != __pda_address {
            return Err(anchor_lang::error::Error::from(
                anchor_lang::error::ErrorCode::ConstraintSeeds,
            )
            .with_account_name("mint")
            .with_pubkeys((mint.key(), __pda_address)));
        }
        if !mint.to_account_info().is_writable {
            return Err(anchor_lang::error::Error::from(
                anchor_lang::error::ErrorCode::ConstraintMut,
            )
            .with_account_name("mint"));
        }
        let (__pda_address, __bump) =
            Pubkey::find_program_address(&[mint.key().as_ref()], &program_id);
        __bumps.insert("mint_authority".to_string(), __bump);
        if mint_authority.key() != __pda_address {
            return Err(anchor_lang::error::Error::from(
                anchor_lang::error::ErrorCode::ConstraintSeeds,
            )
            .with_account_name("mint_authority")
            .with_pubkeys((mint_authority.key(), __pda_address)));
        }
        if !metadata.to_account_info().is_writable {
            return Err(anchor_lang::error::Error::from(
                anchor_lang::error::ErrorCode::ConstraintMut,
            )
            .with_account_name("metadata"));
        }
        if !master_edition.to_account_info().is_writable {
            return Err(anchor_lang::error::Error::from(
                anchor_lang::error::ErrorCode::ConstraintMut,
            )
            .with_account_name("master_edition"));
        }
        Ok(DecompressV1 {
            voucher,
            owner,
            token_account,
            mint,
            mint_authority,
            metadata,
            master_edition,
            system_program,
            sysvar_rent,
            token_metadata_program,
            token_program,
            associated_token_program,
        })
    }
}
#[automatically_derived]
impl<'info> anchor_lang::ToAccountInfos<'info> for DecompressV1<'info>
where
    'info: 'info,
{
    fn to_account_infos(
        &self,
    ) -> Vec<anchor_lang::solana_program::account_info::AccountInfo<'info>> {
        let mut account_infos = ::alloc::vec::Vec::new();
        account_infos.extend(self.voucher.to_account_infos());
        account_infos.extend(self.owner.to_account_infos());
        account_infos.extend(self.token_account.to_account_infos());
        account_infos.extend(self.mint.to_account_infos());
        account_infos.extend(self.mint_authority.to_account_infos());
        account_infos.extend(self.metadata.to_account_infos());
        account_infos.extend(self.master_edition.to_account_infos());
        account_infos.extend(self.system_program.to_account_infos());
        account_infos.extend(self.sysvar_rent.to_account_infos());
        account_infos.extend(self.token_metadata_program.to_account_infos());
        account_infos.extend(self.token_program.to_account_infos());
        account_infos.extend(self.associated_token_program.to_account_infos());
        account_infos
    }
}
#[automatically_derived]
impl<'info> anchor_lang::ToAccountMetas for DecompressV1<'info> {
    fn to_account_metas(
        &self,
        is_signer: Option<bool>,
    ) -> Vec<anchor_lang::solana_program::instruction::AccountMeta> {
        let mut account_metas = ::alloc::vec::Vec::new();
        account_metas.extend(self.voucher.to_account_metas(None));
        account_metas.extend(self.owner.to_account_metas(None));
        account_metas.extend(self.token_account.to_account_metas(None));
        account_metas.extend(self.mint.to_account_metas(None));
        account_metas.extend(self.mint_authority.to_account_metas(None));
        account_metas.extend(self.metadata.to_account_metas(None));
        account_metas.extend(self.master_edition.to_account_metas(None));
        account_metas.extend(self.system_program.to_account_metas(None));
        account_metas.extend(self.sysvar_rent.to_account_metas(None));
        account_metas.extend(self.token_metadata_program.to_account_metas(None));
        account_metas.extend(self.token_program.to_account_metas(None));
        account_metas.extend(self.associated_token_program.to_account_metas(None));
        account_metas
    }
}
#[automatically_derived]
impl<'info> anchor_lang::AccountsExit<'info> for DecompressV1<'info>
where
    'info: 'info,
{
    fn exit(
        &self,
        program_id: &anchor_lang::solana_program::pubkey::Pubkey,
    ) -> anchor_lang::Result<()> {
        anchor_lang::AccountsClose::close(&self.voucher, self.owner.to_account_info())
            .map_err(|e| e.with_account_name("voucher"))?;
        anchor_lang::AccountsExit::exit(&self.owner, program_id)
            .map_err(|e| e.with_account_name("owner"))?;
        anchor_lang::AccountsExit::exit(&self.token_account, program_id)
            .map_err(|e| e.with_account_name("token_account"))?;
        anchor_lang::AccountsExit::exit(&self.mint, program_id)
            .map_err(|e| e.with_account_name("mint"))?;
        anchor_lang::AccountsExit::exit(&self.metadata, program_id)
            .map_err(|e| e.with_account_name("metadata"))?;
        anchor_lang::AccountsExit::exit(&self.master_edition, program_id)
            .map_err(|e| e.with_account_name("master_edition"))?;
        Ok(())
    }
}
/// An internal, Anchor generated module. This is used (as an
/// implementation detail), to generate a struct for a given
/// `#[derive(Accounts)]` implementation, where each field is a Pubkey,
/// instead of an `AccountInfo`. This is useful for clients that want
/// to generate a list of accounts, without explicitly knowing the
/// order all the fields should be in.
///
/// To access the struct in this module, one should use the sibling
/// `accounts` module (also generated), which re-exports this.
pub(crate) mod __client_accounts_decompress_v1 {
    use super::*;
    use anchor_lang::prelude::borsh;
    /// Generated client accounts for [`DecompressV1`].
    pub struct DecompressV1 {
        pub voucher: anchor_lang::solana_program::pubkey::Pubkey,
        pub owner: anchor_lang::solana_program::pubkey::Pubkey,
        pub token_account: anchor_lang::solana_program::pubkey::Pubkey,
        pub mint: anchor_lang::solana_program::pubkey::Pubkey,
        pub mint_authority: anchor_lang::solana_program::pubkey::Pubkey,
        pub metadata: anchor_lang::solana_program::pubkey::Pubkey,
        pub master_edition: anchor_lang::solana_program::pubkey::Pubkey,
        pub system_program: anchor_lang::solana_program::pubkey::Pubkey,
        pub sysvar_rent: anchor_lang::solana_program::pubkey::Pubkey,
        pub token_metadata_program: anchor_lang::solana_program::pubkey::Pubkey,
        pub token_program: anchor_lang::solana_program::pubkey::Pubkey,
        pub associated_token_program: anchor_lang::solana_program::pubkey::Pubkey,
    }
    impl borsh::ser::BorshSerialize for DecompressV1
    where
        anchor_lang::solana_program::pubkey::Pubkey: borsh::ser::BorshSerialize,
        anchor_lang::solana_program::pubkey::Pubkey: borsh::ser::BorshSerialize,
        anchor_lang::solana_program::pubkey::Pubkey: borsh::ser::BorshSerialize,
        anchor_lang::solana_program::pubkey::Pubkey: borsh::ser::BorshSerialize,
        anchor_lang::solana_program::pubkey::Pubkey: borsh::ser::BorshSerialize,
        anchor_lang::solana_program::pubkey::Pubkey: borsh::ser::BorshSerialize,
        anchor_lang::solana_program::pubkey::Pubkey: borsh::ser::BorshSerialize,
        anchor_lang::solana_program::pubkey::Pubkey: borsh::ser::BorshSerialize,
        anchor_lang::solana_program::pubkey::Pubkey: borsh::ser::BorshSerialize,
        anchor_lang::solana_program::pubkey::Pubkey: borsh::ser::BorshSerialize,
        anchor_lang::solana_program::pubkey::Pubkey: borsh::ser::BorshSerialize,
        anchor_lang::solana_program::pubkey::Pubkey: borsh::ser::BorshSerialize,
    {
        fn serialize<W: borsh::maybestd::io::Write>(
            &self,
            writer: &mut W,
        ) -> ::core::result::Result<(), borsh::maybestd::io::Error> {
            borsh::BorshSerialize::serialize(&self.voucher, writer)?;
            borsh::BorshSerialize::serialize(&self.owner, writer)?;
            borsh::BorshSerialize::serialize(&self.token_account, writer)?;
            borsh::BorshSerialize::serialize(&self.mint, writer)?;
            borsh::BorshSerialize::serialize(&self.mint_authority, writer)?;
            borsh::BorshSerialize::serialize(&self.metadata, writer)?;
            borsh::BorshSerialize::serialize(&self.master_edition, writer)?;
            borsh::BorshSerialize::serialize(&self.system_program, writer)?;
            borsh::BorshSerialize::serialize(&self.sysvar_rent, writer)?;
            borsh::BorshSerialize::serialize(&self.token_metadata_program, writer)?;
            borsh::BorshSerialize::serialize(&self.token_program, writer)?;
            borsh::BorshSerialize::serialize(&self.associated_token_program, writer)?;
            Ok(())
        }
    }
    #[automatically_derived]
    impl anchor_lang::ToAccountMetas for DecompressV1 {
        fn to_account_metas(
            &self,
            is_signer: Option<bool>,
        ) -> Vec<anchor_lang::solana_program::instruction::AccountMeta> {
            let mut account_metas = ::alloc::vec::Vec::new();
            account_metas.push(anchor_lang::solana_program::instruction::AccountMeta::new(
                self.voucher,
                false,
            ));
            account_metas.push(anchor_lang::solana_program::instruction::AccountMeta::new(
                self.owner, true,
            ));
            account_metas.push(anchor_lang::solana_program::instruction::AccountMeta::new(
                self.token_account,
                false,
            ));
            account_metas.push(anchor_lang::solana_program::instruction::AccountMeta::new(
                self.mint, false,
            ));
            account_metas.push(
                anchor_lang::solana_program::instruction::AccountMeta::new_readonly(
                    self.mint_authority,
                    false,
                ),
            );
            account_metas.push(anchor_lang::solana_program::instruction::AccountMeta::new(
                self.metadata,
                false,
            ));
            account_metas.push(anchor_lang::solana_program::instruction::AccountMeta::new(
                self.master_edition,
                false,
            ));
            account_metas.push(
                anchor_lang::solana_program::instruction::AccountMeta::new_readonly(
                    self.system_program,
                    false,
                ),
            );
            account_metas.push(
                anchor_lang::solana_program::instruction::AccountMeta::new_readonly(
                    self.sysvar_rent,
                    false,
                ),
            );
            account_metas.push(
                anchor_lang::solana_program::instruction::AccountMeta::new_readonly(
                    self.token_metadata_program,
                    false,
                ),
            );
            account_metas.push(
                anchor_lang::solana_program::instruction::AccountMeta::new_readonly(
                    self.token_program,
                    false,
                ),
            );
            account_metas.push(
                anchor_lang::solana_program::instruction::AccountMeta::new_readonly(
                    self.associated_token_program,
                    false,
                ),
            );
            account_metas
        }
    }
}
/// An internal, Anchor generated module. This is used (as an
/// implementation detail), to generate a CPI struct for a given
/// `#[derive(Accounts)]` implementation, where each field is an
/// AccountInfo.
///
/// To access the struct in this module, one should use the sibling
/// [`cpi::accounts`] module (also generated), which re-exports this.
pub(crate) mod __cpi_client_accounts_decompress_v1 {
    use super::*;
    /// Generated CPI struct of the accounts for [`DecompressV1`].
    pub struct DecompressV1<'info> {
        pub voucher: anchor_lang::solana_program::account_info::AccountInfo<'info>,
        pub owner: anchor_lang::solana_program::account_info::AccountInfo<'info>,
        pub token_account: anchor_lang::solana_program::account_info::AccountInfo<'info>,
        pub mint: anchor_lang::solana_program::account_info::AccountInfo<'info>,
        pub mint_authority: anchor_lang::solana_program::account_info::AccountInfo<'info>,
        pub metadata: anchor_lang::solana_program::account_info::AccountInfo<'info>,
        pub master_edition: anchor_lang::solana_program::account_info::AccountInfo<'info>,
        pub system_program: anchor_lang::solana_program::account_info::AccountInfo<'info>,
        pub sysvar_rent: anchor_lang::solana_program::account_info::AccountInfo<'info>,
        pub token_metadata_program: anchor_lang::solana_program::account_info::AccountInfo<'info>,
        pub token_program: anchor_lang::solana_program::account_info::AccountInfo<'info>,
        pub associated_token_program: anchor_lang::solana_program::account_info::AccountInfo<'info>,
    }
    #[automatically_derived]
    impl<'info> anchor_lang::ToAccountMetas for DecompressV1<'info> {
        fn to_account_metas(
            &self,
            is_signer: Option<bool>,
        ) -> Vec<anchor_lang::solana_program::instruction::AccountMeta> {
            let mut account_metas = ::alloc::vec::Vec::new();
            account_metas.push(anchor_lang::solana_program::instruction::AccountMeta::new(
                anchor_lang::Key::key(&self.voucher),
                false,
            ));
            account_metas.push(anchor_lang::solana_program::instruction::AccountMeta::new(
                anchor_lang::Key::key(&self.owner),
                true,
            ));
            account_metas.push(anchor_lang::solana_program::instruction::AccountMeta::new(
                anchor_lang::Key::key(&self.token_account),
                false,
            ));
            account_metas.push(anchor_lang::solana_program::instruction::AccountMeta::new(
                anchor_lang::Key::key(&self.mint),
                false,
            ));
            account_metas.push(
                anchor_lang::solana_program::instruction::AccountMeta::new_readonly(
                    anchor_lang::Key::key(&self.mint_authority),
                    false,
                ),
            );
            account_metas.push(anchor_lang::solana_program::instruction::AccountMeta::new(
                anchor_lang::Key::key(&self.metadata),
                false,
            ));
            account_metas.push(anchor_lang::solana_program::instruction::AccountMeta::new(
                anchor_lang::Key::key(&self.master_edition),
                false,
            ));
            account_metas.push(
                anchor_lang::solana_program::instruction::AccountMeta::new_readonly(
                    anchor_lang::Key::key(&self.system_program),
                    false,
                ),
            );
            account_metas.push(
                anchor_lang::solana_program::instruction::AccountMeta::new_readonly(
                    anchor_lang::Key::key(&self.sysvar_rent),
                    false,
                ),
            );
            account_metas.push(
                anchor_lang::solana_program::instruction::AccountMeta::new_readonly(
                    anchor_lang::Key::key(&self.token_metadata_program),
                    false,
                ),
            );
            account_metas.push(
                anchor_lang::solana_program::instruction::AccountMeta::new_readonly(
                    anchor_lang::Key::key(&self.token_program),
                    false,
                ),
            );
            account_metas.push(
                anchor_lang::solana_program::instruction::AccountMeta::new_readonly(
                    anchor_lang::Key::key(&self.associated_token_program),
                    false,
                ),
            );
            account_metas
        }
    }
    #[automatically_derived]
    impl<'info> anchor_lang::ToAccountInfos<'info> for DecompressV1<'info> {
        fn to_account_infos(
            &self,
        ) -> Vec<anchor_lang::solana_program::account_info::AccountInfo<'info>> {
            let mut account_infos = ::alloc::vec::Vec::new();
            account_infos.push(anchor_lang::ToAccountInfo::to_account_info(&self.voucher));
            account_infos.push(anchor_lang::ToAccountInfo::to_account_info(&self.owner));
            account_infos.push(anchor_lang::ToAccountInfo::to_account_info(
                &self.token_account,
            ));
            account_infos.push(anchor_lang::ToAccountInfo::to_account_info(&self.mint));
            account_infos.push(anchor_lang::ToAccountInfo::to_account_info(
                &self.mint_authority,
            ));
            account_infos.push(anchor_lang::ToAccountInfo::to_account_info(&self.metadata));
            account_infos.push(anchor_lang::ToAccountInfo::to_account_info(
                &self.master_edition,
            ));
            account_infos.push(anchor_lang::ToAccountInfo::to_account_info(
                &self.system_program,
            ));
            account_infos.push(anchor_lang::ToAccountInfo::to_account_info(
                &self.sysvar_rent,
            ));
            account_infos.push(anchor_lang::ToAccountInfo::to_account_info(
                &self.token_metadata_program,
            ));
            account_infos.push(anchor_lang::ToAccountInfo::to_account_info(
                &self.token_program,
            ));
            account_infos.push(anchor_lang::ToAccountInfo::to_account_info(
                &self.associated_token_program,
            ));
            account_infos
        }
    }
}
pub struct Compress<'info> {
    # [account (seeds = [merkle_slab . key () . as_ref ()] , bump ,)]
    /// CHECK: This account is neither written to nor read from.
    pub authority: UncheckedAccount<'info>,
    /// CHECK: This account is not read
    pub merkle_slab: UncheckedAccount<'info>,
    /// CHECK: This account is checked in the instruction
    pub owner: Signer<'info>,
    /// CHECK: This account is chekced in the instruction
    pub delegate: UncheckedAccount<'info>,
    /// CHECK: versioning is handled in the instruction
    #[account(mut)]
    pub token_account: AccountInfo<'info>,
    /// CHECK: versioning is handled in the instruction
    #[account(mut)]
    pub mint: AccountInfo<'info>,
    #[account(mut)]
    pub metadata: Box<Account<'info, TokenMetadata>>,
    #[account(mut)]
    pub master_edition: Box<Account<'info, MasterEdition>>,
    #[account(mut)]
    pub payer: Signer<'info>,
    pub system_program: Program<'info, System>,
    /// CHECK:
    pub token_metadata_program: UncheckedAccount<'info>,
    /// CHECK:
    pub token_program: UncheckedAccount<'info>,
    pub candy_wrapper: Program<'info, CandyWrapper>,
    pub gummyroll_program: Program<'info, Gummyroll>,
}
#[automatically_derived]
impl<'info> anchor_lang::Accounts<'info> for Compress<'info>
where
    'info: 'info,
{
    #[inline(never)]
    fn try_accounts(
        program_id: &anchor_lang::solana_program::pubkey::Pubkey,
        accounts: &mut &[anchor_lang::solana_program::account_info::AccountInfo<'info>],
        ix_data: &[u8],
        __bumps: &mut std::collections::BTreeMap<String, u8>,
        __reallocs: &mut std::collections::BTreeSet<anchor_lang::solana_program::pubkey::Pubkey>,
    ) -> anchor_lang::Result<Self> {
        let authority: UncheckedAccount =
            anchor_lang::Accounts::try_accounts(program_id, accounts, ix_data, __bumps, __reallocs)
                .map_err(|e| e.with_account_name("authority"))?;
        let merkle_slab: UncheckedAccount =
            anchor_lang::Accounts::try_accounts(program_id, accounts, ix_data, __bumps, __reallocs)
                .map_err(|e| e.with_account_name("merkle_slab"))?;
        let owner: Signer =
            anchor_lang::Accounts::try_accounts(program_id, accounts, ix_data, __bumps, __reallocs)
                .map_err(|e| e.with_account_name("owner"))?;
        let delegate: UncheckedAccount =
            anchor_lang::Accounts::try_accounts(program_id, accounts, ix_data, __bumps, __reallocs)
                .map_err(|e| e.with_account_name("delegate"))?;
        let token_account: AccountInfo =
            anchor_lang::Accounts::try_accounts(program_id, accounts, ix_data, __bumps, __reallocs)
                .map_err(|e| e.with_account_name("token_account"))?;
        let mint: AccountInfo =
            anchor_lang::Accounts::try_accounts(program_id, accounts, ix_data, __bumps, __reallocs)
                .map_err(|e| e.with_account_name("mint"))?;
        let metadata: Box<anchor_lang::accounts::account::Account<TokenMetadata>> =
            anchor_lang::Accounts::try_accounts(program_id, accounts, ix_data, __bumps, __reallocs)
                .map_err(|e| e.with_account_name("metadata"))?;
        let master_edition: Box<anchor_lang::accounts::account::Account<MasterEdition>> =
            anchor_lang::Accounts::try_accounts(program_id, accounts, ix_data, __bumps, __reallocs)
                .map_err(|e| e.with_account_name("master_edition"))?;
        let payer: Signer =
            anchor_lang::Accounts::try_accounts(program_id, accounts, ix_data, __bumps, __reallocs)
                .map_err(|e| e.with_account_name("payer"))?;
        let system_program: anchor_lang::accounts::program::Program<System> =
            anchor_lang::Accounts::try_accounts(program_id, accounts, ix_data, __bumps, __reallocs)
                .map_err(|e| e.with_account_name("system_program"))?;
        let token_metadata_program: UncheckedAccount =
            anchor_lang::Accounts::try_accounts(program_id, accounts, ix_data, __bumps, __reallocs)
                .map_err(|e| e.with_account_name("token_metadata_program"))?;
        let token_program: UncheckedAccount =
            anchor_lang::Accounts::try_accounts(program_id, accounts, ix_data, __bumps, __reallocs)
                .map_err(|e| e.with_account_name("token_program"))?;
        let candy_wrapper: anchor_lang::accounts::program::Program<CandyWrapper> =
            anchor_lang::Accounts::try_accounts(program_id, accounts, ix_data, __bumps, __reallocs)
                .map_err(|e| e.with_account_name("candy_wrapper"))?;
        let gummyroll_program: anchor_lang::accounts::program::Program<Gummyroll> =
            anchor_lang::Accounts::try_accounts(program_id, accounts, ix_data, __bumps, __reallocs)
                .map_err(|e| e.with_account_name("gummyroll_program"))?;
        let (__pda_address, __bump) =
            Pubkey::find_program_address(&[merkle_slab.key().as_ref()], &program_id);
        __bumps.insert("authority".to_string(), __bump);
        if authority.key() != __pda_address {
            return Err(anchor_lang::error::Error::from(
                anchor_lang::error::ErrorCode::ConstraintSeeds,
            )
            .with_account_name("authority")
            .with_pubkeys((authority.key(), __pda_address)));
        }
        if !token_account.to_account_info().is_writable {
            return Err(anchor_lang::error::Error::from(
                anchor_lang::error::ErrorCode::ConstraintMut,
            )
            .with_account_name("token_account"));
        }
        if !mint.to_account_info().is_writable {
            return Err(anchor_lang::error::Error::from(
                anchor_lang::error::ErrorCode::ConstraintMut,
            )
            .with_account_name("mint"));
        }
        if !metadata.to_account_info().is_writable {
            return Err(anchor_lang::error::Error::from(
                anchor_lang::error::ErrorCode::ConstraintMut,
            )
            .with_account_name("metadata"));
        }
        if !master_edition.to_account_info().is_writable {
            return Err(anchor_lang::error::Error::from(
                anchor_lang::error::ErrorCode::ConstraintMut,
            )
            .with_account_name("master_edition"));
        }
        if !payer.to_account_info().is_writable {
            return Err(anchor_lang::error::Error::from(
                anchor_lang::error::ErrorCode::ConstraintMut,
            )
            .with_account_name("payer"));
        }
        Ok(Compress {
            authority,
            merkle_slab,
            owner,
            delegate,
            token_account,
            mint,
            metadata,
            master_edition,
            payer,
            system_program,
            token_metadata_program,
            token_program,
            candy_wrapper,
            gummyroll_program,
        })
    }
}
#[automatically_derived]
impl<'info> anchor_lang::ToAccountInfos<'info> for Compress<'info>
where
    'info: 'info,
{
    fn to_account_infos(
        &self,
    ) -> Vec<anchor_lang::solana_program::account_info::AccountInfo<'info>> {
        let mut account_infos = ::alloc::vec::Vec::new();
        account_infos.extend(self.authority.to_account_infos());
        account_infos.extend(self.merkle_slab.to_account_infos());
        account_infos.extend(self.owner.to_account_infos());
        account_infos.extend(self.delegate.to_account_infos());
        account_infos.extend(self.token_account.to_account_infos());
        account_infos.extend(self.mint.to_account_infos());
        account_infos.extend(self.metadata.to_account_infos());
        account_infos.extend(self.master_edition.to_account_infos());
        account_infos.extend(self.payer.to_account_infos());
        account_infos.extend(self.system_program.to_account_infos());
        account_infos.extend(self.token_metadata_program.to_account_infos());
        account_infos.extend(self.token_program.to_account_infos());
        account_infos.extend(self.candy_wrapper.to_account_infos());
        account_infos.extend(self.gummyroll_program.to_account_infos());
        account_infos
    }
}
#[automatically_derived]
impl<'info> anchor_lang::ToAccountMetas for Compress<'info> {
    fn to_account_metas(
        &self,
        is_signer: Option<bool>,
    ) -> Vec<anchor_lang::solana_program::instruction::AccountMeta> {
        let mut account_metas = ::alloc::vec::Vec::new();
        account_metas.extend(self.authority.to_account_metas(None));
        account_metas.extend(self.merkle_slab.to_account_metas(None));
        account_metas.extend(self.owner.to_account_metas(None));
        account_metas.extend(self.delegate.to_account_metas(None));
        account_metas.extend(self.token_account.to_account_metas(None));
        account_metas.extend(self.mint.to_account_metas(None));
        account_metas.extend(self.metadata.to_account_metas(None));
        account_metas.extend(self.master_edition.to_account_metas(None));
        account_metas.extend(self.payer.to_account_metas(None));
        account_metas.extend(self.system_program.to_account_metas(None));
        account_metas.extend(self.token_metadata_program.to_account_metas(None));
        account_metas.extend(self.token_program.to_account_metas(None));
        account_metas.extend(self.candy_wrapper.to_account_metas(None));
        account_metas.extend(self.gummyroll_program.to_account_metas(None));
        account_metas
    }
}
#[automatically_derived]
impl<'info> anchor_lang::AccountsExit<'info> for Compress<'info>
where
    'info: 'info,
{
    fn exit(
        &self,
        program_id: &anchor_lang::solana_program::pubkey::Pubkey,
    ) -> anchor_lang::Result<()> {
        anchor_lang::AccountsExit::exit(&self.token_account, program_id)
            .map_err(|e| e.with_account_name("token_account"))?;
        anchor_lang::AccountsExit::exit(&self.mint, program_id)
            .map_err(|e| e.with_account_name("mint"))?;
        anchor_lang::AccountsExit::exit(&self.metadata, program_id)
            .map_err(|e| e.with_account_name("metadata"))?;
        anchor_lang::AccountsExit::exit(&self.master_edition, program_id)
            .map_err(|e| e.with_account_name("master_edition"))?;
        anchor_lang::AccountsExit::exit(&self.payer, program_id)
            .map_err(|e| e.with_account_name("payer"))?;
        Ok(())
    }
}
/// An internal, Anchor generated module. This is used (as an
/// implementation detail), to generate a struct for a given
/// `#[derive(Accounts)]` implementation, where each field is a Pubkey,
/// instead of an `AccountInfo`. This is useful for clients that want
/// to generate a list of accounts, without explicitly knowing the
/// order all the fields should be in.
///
/// To access the struct in this module, one should use the sibling
/// `accounts` module (also generated), which re-exports this.
pub(crate) mod __client_accounts_compress {
    use super::*;
    use anchor_lang::prelude::borsh;
    /// Generated client accounts for [`Compress`].
    pub struct Compress {
        pub authority: anchor_lang::solana_program::pubkey::Pubkey,
        pub merkle_slab: anchor_lang::solana_program::pubkey::Pubkey,
        pub owner: anchor_lang::solana_program::pubkey::Pubkey,
        pub delegate: anchor_lang::solana_program::pubkey::Pubkey,
        pub token_account: anchor_lang::solana_program::pubkey::Pubkey,
        pub mint: anchor_lang::solana_program::pubkey::Pubkey,
        pub metadata: anchor_lang::solana_program::pubkey::Pubkey,
        pub master_edition: anchor_lang::solana_program::pubkey::Pubkey,
        pub payer: anchor_lang::solana_program::pubkey::Pubkey,
        pub system_program: anchor_lang::solana_program::pubkey::Pubkey,
        pub token_metadata_program: anchor_lang::solana_program::pubkey::Pubkey,
        pub token_program: anchor_lang::solana_program::pubkey::Pubkey,
        pub candy_wrapper: anchor_lang::solana_program::pubkey::Pubkey,
        pub gummyroll_program: anchor_lang::solana_program::pubkey::Pubkey,
    }
    impl borsh::ser::BorshSerialize for Compress
    where
        anchor_lang::solana_program::pubkey::Pubkey: borsh::ser::BorshSerialize,
        anchor_lang::solana_program::pubkey::Pubkey: borsh::ser::BorshSerialize,
        anchor_lang::solana_program::pubkey::Pubkey: borsh::ser::BorshSerialize,
        anchor_lang::solana_program::pubkey::Pubkey: borsh::ser::BorshSerialize,
        anchor_lang::solana_program::pubkey::Pubkey: borsh::ser::BorshSerialize,
        anchor_lang::solana_program::pubkey::Pubkey: borsh::ser::BorshSerialize,
        anchor_lang::solana_program::pubkey::Pubkey: borsh::ser::BorshSerialize,
        anchor_lang::solana_program::pubkey::Pubkey: borsh::ser::BorshSerialize,
        anchor_lang::solana_program::pubkey::Pubkey: borsh::ser::BorshSerialize,
        anchor_lang::solana_program::pubkey::Pubkey: borsh::ser::BorshSerialize,
        anchor_lang::solana_program::pubkey::Pubkey: borsh::ser::BorshSerialize,
        anchor_lang::solana_program::pubkey::Pubkey: borsh::ser::BorshSerialize,
        anchor_lang::solana_program::pubkey::Pubkey: borsh::ser::BorshSerialize,
        anchor_lang::solana_program::pubkey::Pubkey: borsh::ser::BorshSerialize,
    {
        fn serialize<W: borsh::maybestd::io::Write>(
            &self,
            writer: &mut W,
        ) -> ::core::result::Result<(), borsh::maybestd::io::Error> {
            borsh::BorshSerialize::serialize(&self.authority, writer)?;
            borsh::BorshSerialize::serialize(&self.merkle_slab, writer)?;
            borsh::BorshSerialize::serialize(&self.owner, writer)?;
            borsh::BorshSerialize::serialize(&self.delegate, writer)?;
            borsh::BorshSerialize::serialize(&self.token_account, writer)?;
            borsh::BorshSerialize::serialize(&self.mint, writer)?;
            borsh::BorshSerialize::serialize(&self.metadata, writer)?;
            borsh::BorshSerialize::serialize(&self.master_edition, writer)?;
            borsh::BorshSerialize::serialize(&self.payer, writer)?;
            borsh::BorshSerialize::serialize(&self.system_program, writer)?;
            borsh::BorshSerialize::serialize(&self.token_metadata_program, writer)?;
            borsh::BorshSerialize::serialize(&self.token_program, writer)?;
            borsh::BorshSerialize::serialize(&self.candy_wrapper, writer)?;
            borsh::BorshSerialize::serialize(&self.gummyroll_program, writer)?;
            Ok(())
        }
    }
    #[automatically_derived]
    impl anchor_lang::ToAccountMetas for Compress {
        fn to_account_metas(
            &self,
            is_signer: Option<bool>,
        ) -> Vec<anchor_lang::solana_program::instruction::AccountMeta> {
            let mut account_metas = ::alloc::vec::Vec::new();
            account_metas.push(
                anchor_lang::solana_program::instruction::AccountMeta::new_readonly(
                    self.authority,
                    false,
                ),
            );
            account_metas.push(
                anchor_lang::solana_program::instruction::AccountMeta::new_readonly(
                    self.merkle_slab,
                    false,
                ),
            );
            account_metas.push(
                anchor_lang::solana_program::instruction::AccountMeta::new_readonly(
                    self.owner, true,
                ),
            );
            account_metas.push(
                anchor_lang::solana_program::instruction::AccountMeta::new_readonly(
                    self.delegate,
                    false,
                ),
            );
            account_metas.push(anchor_lang::solana_program::instruction::AccountMeta::new(
                self.token_account,
                false,
            ));
            account_metas.push(anchor_lang::solana_program::instruction::AccountMeta::new(
                self.mint, false,
            ));
            account_metas.push(anchor_lang::solana_program::instruction::AccountMeta::new(
                self.metadata,
                false,
            ));
            account_metas.push(anchor_lang::solana_program::instruction::AccountMeta::new(
                self.master_edition,
                false,
            ));
            account_metas.push(anchor_lang::solana_program::instruction::AccountMeta::new(
                self.payer, true,
            ));
            account_metas.push(
                anchor_lang::solana_program::instruction::AccountMeta::new_readonly(
                    self.system_program,
                    false,
                ),
            );
            account_metas.push(
                anchor_lang::solana_program::instruction::AccountMeta::new_readonly(
                    self.token_metadata_program,
                    false,
                ),
            );
            account_metas.push(
                anchor_lang::solana_program::instruction::AccountMeta::new_readonly(
                    self.token_program,
                    false,
                ),
            );
            account_metas.push(
                anchor_lang::solana_program::instruction::AccountMeta::new_readonly(
                    self.candy_wrapper,
                    false,
                ),
            );
            account_metas.push(
                anchor_lang::solana_program::instruction::AccountMeta::new_readonly(
                    self.gummyroll_program,
                    false,
                ),
            );
            account_metas
        }
    }
}
/// An internal, Anchor generated module. This is used (as an
/// implementation detail), to generate a CPI struct for a given
/// `#[derive(Accounts)]` implementation, where each field is an
/// AccountInfo.
///
/// To access the struct in this module, one should use the sibling
/// [`cpi::accounts`] module (also generated), which re-exports this.
pub(crate) mod __cpi_client_accounts_compress {
    use super::*;
    /// Generated CPI struct of the accounts for [`Compress`].
    pub struct Compress<'info> {
        pub authority: anchor_lang::solana_program::account_info::AccountInfo<'info>,
        pub merkle_slab: anchor_lang::solana_program::account_info::AccountInfo<'info>,
        pub owner: anchor_lang::solana_program::account_info::AccountInfo<'info>,
        pub delegate: anchor_lang::solana_program::account_info::AccountInfo<'info>,
        pub token_account: anchor_lang::solana_program::account_info::AccountInfo<'info>,
        pub mint: anchor_lang::solana_program::account_info::AccountInfo<'info>,
        pub metadata: anchor_lang::solana_program::account_info::AccountInfo<'info>,
        pub master_edition: anchor_lang::solana_program::account_info::AccountInfo<'info>,
        pub payer: anchor_lang::solana_program::account_info::AccountInfo<'info>,
        pub system_program: anchor_lang::solana_program::account_info::AccountInfo<'info>,
        pub token_metadata_program: anchor_lang::solana_program::account_info::AccountInfo<'info>,
        pub token_program: anchor_lang::solana_program::account_info::AccountInfo<'info>,
        pub candy_wrapper: anchor_lang::solana_program::account_info::AccountInfo<'info>,
        pub gummyroll_program: anchor_lang::solana_program::account_info::AccountInfo<'info>,
    }
    #[automatically_derived]
    impl<'info> anchor_lang::ToAccountMetas for Compress<'info> {
        fn to_account_metas(
            &self,
            is_signer: Option<bool>,
        ) -> Vec<anchor_lang::solana_program::instruction::AccountMeta> {
            let mut account_metas = ::alloc::vec::Vec::new();
            account_metas.push(
                anchor_lang::solana_program::instruction::AccountMeta::new_readonly(
                    anchor_lang::Key::key(&self.authority),
                    false,
                ),
            );
            account_metas.push(
                anchor_lang::solana_program::instruction::AccountMeta::new_readonly(
                    anchor_lang::Key::key(&self.merkle_slab),
                    false,
                ),
            );
            account_metas.push(
                anchor_lang::solana_program::instruction::AccountMeta::new_readonly(
                    anchor_lang::Key::key(&self.owner),
                    true,
                ),
            );
            account_metas.push(
                anchor_lang::solana_program::instruction::AccountMeta::new_readonly(
                    anchor_lang::Key::key(&self.delegate),
                    false,
                ),
            );
            account_metas.push(anchor_lang::solana_program::instruction::AccountMeta::new(
                anchor_lang::Key::key(&self.token_account),
                false,
            ));
            account_metas.push(anchor_lang::solana_program::instruction::AccountMeta::new(
                anchor_lang::Key::key(&self.mint),
                false,
            ));
            account_metas.push(anchor_lang::solana_program::instruction::AccountMeta::new(
                anchor_lang::Key::key(&self.metadata),
                false,
            ));
            account_metas.push(anchor_lang::solana_program::instruction::AccountMeta::new(
                anchor_lang::Key::key(&self.master_edition),
                false,
            ));
            account_metas.push(anchor_lang::solana_program::instruction::AccountMeta::new(
                anchor_lang::Key::key(&self.payer),
                true,
            ));
            account_metas.push(
                anchor_lang::solana_program::instruction::AccountMeta::new_readonly(
                    anchor_lang::Key::key(&self.system_program),
                    false,
                ),
            );
            account_metas.push(
                anchor_lang::solana_program::instruction::AccountMeta::new_readonly(
                    anchor_lang::Key::key(&self.token_metadata_program),
                    false,
                ),
            );
            account_metas.push(
                anchor_lang::solana_program::instruction::AccountMeta::new_readonly(
                    anchor_lang::Key::key(&self.token_program),
                    false,
                ),
            );
            account_metas.push(
                anchor_lang::solana_program::instruction::AccountMeta::new_readonly(
                    anchor_lang::Key::key(&self.candy_wrapper),
                    false,
                ),
            );
            account_metas.push(
                anchor_lang::solana_program::instruction::AccountMeta::new_readonly(
                    anchor_lang::Key::key(&self.gummyroll_program),
                    false,
                ),
            );
            account_metas
        }
    }
    #[automatically_derived]
    impl<'info> anchor_lang::ToAccountInfos<'info> for Compress<'info> {
        fn to_account_infos(
            &self,
        ) -> Vec<anchor_lang::solana_program::account_info::AccountInfo<'info>> {
            let mut account_infos = ::alloc::vec::Vec::new();
            account_infos.push(anchor_lang::ToAccountInfo::to_account_info(&self.authority));
            account_infos.push(anchor_lang::ToAccountInfo::to_account_info(
                &self.merkle_slab,
            ));
            account_infos.push(anchor_lang::ToAccountInfo::to_account_info(&self.owner));
            account_infos.push(anchor_lang::ToAccountInfo::to_account_info(&self.delegate));
            account_infos.push(anchor_lang::ToAccountInfo::to_account_info(
                &self.token_account,
            ));
            account_infos.push(anchor_lang::ToAccountInfo::to_account_info(&self.mint));
            account_infos.push(anchor_lang::ToAccountInfo::to_account_info(&self.metadata));
            account_infos.push(anchor_lang::ToAccountInfo::to_account_info(
                &self.master_edition,
            ));
            account_infos.push(anchor_lang::ToAccountInfo::to_account_info(&self.payer));
            account_infos.push(anchor_lang::ToAccountInfo::to_account_info(
                &self.system_program,
            ));
            account_infos.push(anchor_lang::ToAccountInfo::to_account_info(
                &self.token_metadata_program,
            ));
            account_infos.push(anchor_lang::ToAccountInfo::to_account_info(
                &self.token_program,
            ));
            account_infos.push(anchor_lang::ToAccountInfo::to_account_info(
                &self.candy_wrapper,
            ));
            account_infos.push(anchor_lang::ToAccountInfo::to_account_info(
                &self.gummyroll_program,
            ));
            account_infos
        }
    }
}
pub struct SetMintRequest<'info> {
    # [account (init_if_needed , space = MINT_REQUEST_SIZE , seeds = [merkle_slab . key () . as_ref () , mint_authority . key () . as_ref ()] , payer = payer , bump)]
    pub mint_authority_request: Account<'info, MintRequest>,
    #[account(mut)]
    pub payer: Signer<'info>,
    pub mint_authority: Signer<'info>,
    # [account (mut , seeds = [merkle_slab . key () . as_ref ()] , bump)]
    pub tree_authority: Account<'info, TreeConfig>,
    pub system_program: Program<'info, System>,
    /// CHECK: this account is neither read from or written to
    pub merkle_slab: UncheckedAccount<'info>,
}
#[automatically_derived]
impl<'info> anchor_lang::Accounts<'info> for SetMintRequest<'info>
where
    'info: 'info,
{
    #[inline(never)]
    fn try_accounts(
        program_id: &anchor_lang::solana_program::pubkey::Pubkey,
        accounts: &mut &[anchor_lang::solana_program::account_info::AccountInfo<'info>],
        ix_data: &[u8],
        __bumps: &mut std::collections::BTreeMap<String, u8>,
        __reallocs: &mut std::collections::BTreeSet<anchor_lang::solana_program::pubkey::Pubkey>,
    ) -> anchor_lang::Result<Self> {
        if accounts.is_empty() {
            return Err(anchor_lang::error::ErrorCode::AccountNotEnoughKeys.into());
        }
        let mint_authority_request = &accounts[0];
        *accounts = &accounts[1..];
        let payer: Signer =
            anchor_lang::Accounts::try_accounts(program_id, accounts, ix_data, __bumps, __reallocs)
                .map_err(|e| e.with_account_name("payer"))?;
        let mint_authority: Signer =
            anchor_lang::Accounts::try_accounts(program_id, accounts, ix_data, __bumps, __reallocs)
                .map_err(|e| e.with_account_name("mint_authority"))?;
        let tree_authority: anchor_lang::accounts::account::Account<TreeConfig> =
            anchor_lang::Accounts::try_accounts(program_id, accounts, ix_data, __bumps, __reallocs)
                .map_err(|e| e.with_account_name("tree_authority"))?;
        let system_program: anchor_lang::accounts::program::Program<System> =
            anchor_lang::Accounts::try_accounts(program_id, accounts, ix_data, __bumps, __reallocs)
                .map_err(|e| e.with_account_name("system_program"))?;
        let merkle_slab: UncheckedAccount =
            anchor_lang::Accounts::try_accounts(program_id, accounts, ix_data, __bumps, __reallocs)
                .map_err(|e| e.with_account_name("merkle_slab"))?;
        let __anchor_rent = Rent::get()?;
        let (__pda_address, __bump) = Pubkey::find_program_address(
            &[merkle_slab.key().as_ref(), mint_authority.key().as_ref()],
            program_id,
        );
        __bumps.insert("mint_authority_request".to_string(), __bump);
        let mint_authority_request = {
            let actual_field = mint_authority_request.to_account_info();
            let actual_owner = actual_field.owner;
            let space = MINT_REQUEST_SIZE;
            let pa: anchor_lang::accounts::account::Account<MintRequest> = if !true
                || actual_owner == &anchor_lang::solana_program::system_program::ID
            {
                let payer = payer.to_account_info();
                let __current_lamports = mint_authority_request.lamports();
                if __current_lamports == 0 {
                    let lamports = __anchor_rent.minimum_balance(space);
                    let cpi_accounts = anchor_lang::system_program::CreateAccount {
                        from: payer.to_account_info(),
                        to: mint_authority_request.to_account_info(),
                    };
                    let cpi_context = anchor_lang::context::CpiContext::new(
                        system_program.to_account_info(),
                        cpi_accounts,
                    );
                    anchor_lang::system_program::create_account(
                        cpi_context.with_signer(&[&[
                            merkle_slab.key().as_ref(),
                            mint_authority.key().as_ref(),
                            &[__bump][..],
                        ][..]]),
                        lamports,
                        space as u64,
                        program_id,
                    )?;
                } else {
                    let required_lamports = __anchor_rent
                        .minimum_balance(space)
                        .max(1)
                        .saturating_sub(__current_lamports);
                    if required_lamports > 0 {
                        let cpi_accounts = anchor_lang::system_program::Transfer {
                            from: payer.to_account_info(),
                            to: mint_authority_request.to_account_info(),
                        };
                        let cpi_context = anchor_lang::context::CpiContext::new(
                            system_program.to_account_info(),
                            cpi_accounts,
                        );
                        anchor_lang::system_program::transfer(cpi_context, required_lamports)?;
                    }
                    let cpi_accounts = anchor_lang::system_program::Allocate {
                        account_to_allocate: mint_authority_request.to_account_info(),
                    };
                    let cpi_context = anchor_lang::context::CpiContext::new(
                        system_program.to_account_info(),
                        cpi_accounts,
                    );
                    anchor_lang::system_program::allocate(
                        cpi_context.with_signer(&[&[
                            merkle_slab.key().as_ref(),
                            mint_authority.key().as_ref(),
                            &[__bump][..],
                        ][..]]),
                        space as u64,
                    )?;
                    let cpi_accounts = anchor_lang::system_program::Assign {
                        account_to_assign: mint_authority_request.to_account_info(),
                    };
                    let cpi_context = anchor_lang::context::CpiContext::new(
                        system_program.to_account_info(),
                        cpi_accounts,
                    );
                    anchor_lang::system_program::assign(
                        cpi_context.with_signer(&[&[
                            merkle_slab.key().as_ref(),
                            mint_authority.key().as_ref(),
                            &[__bump][..],
                        ][..]]),
                        program_id,
                    )?;
                }
                anchor_lang::accounts::account::Account::try_from_unchecked(&mint_authority_request)
                    .map_err(|e| e.with_account_name("mint_authority_request"))?
            } else {
                anchor_lang::accounts::account::Account::try_from(&mint_authority_request)
                    .map_err(|e| e.with_account_name("mint_authority_request"))?
            };
            if true {
                if space != actual_field.data_len() {
                    return Err(anchor_lang::error::Error::from(
                        anchor_lang::error::ErrorCode::ConstraintSpace,
                    )
                    .with_account_name("mint_authority_request")
                    .with_values((space, actual_field.data_len())));
                }
                if actual_owner != program_id {
                    return Err(anchor_lang::error::Error::from(
                        anchor_lang::error::ErrorCode::ConstraintOwner,
                    )
                    .with_account_name("mint_authority_request")
                    .with_pubkeys((*actual_owner, *program_id)));
                }
                {
                    let required_lamports = __anchor_rent.minimum_balance(space);
                    if pa.to_account_info().lamports() < required_lamports {
                        return Err(anchor_lang::error::Error::from(
                            anchor_lang::error::ErrorCode::ConstraintRentExempt,
                        )
                        .with_account_name("mint_authority_request"));
                    }
                }
            }
            pa
        };
        if mint_authority_request.key() != __pda_address {
            return Err(anchor_lang::error::Error::from(
                anchor_lang::error::ErrorCode::ConstraintSeeds,
            )
            .with_account_name("mint_authority_request")
            .with_pubkeys((mint_authority_request.key(), __pda_address)));
        }
        if !mint_authority_request.to_account_info().is_writable {
            return Err(anchor_lang::error::Error::from(
                anchor_lang::error::ErrorCode::ConstraintMut,
            )
            .with_account_name("mint_authority_request"));
        }
        if !__anchor_rent.is_exempt(
            mint_authority_request.to_account_info().lamports(),
            mint_authority_request.to_account_info().try_data_len()?,
        ) {
            return Err(anchor_lang::error::Error::from(
                anchor_lang::error::ErrorCode::ConstraintRentExempt,
            )
            .with_account_name("mint_authority_request"));
        }
        if !payer.to_account_info().is_writable {
            return Err(anchor_lang::error::Error::from(
                anchor_lang::error::ErrorCode::ConstraintMut,
            )
            .with_account_name("payer"));
        }
        let (__pda_address, __bump) =
            Pubkey::find_program_address(&[merkle_slab.key().as_ref()], &program_id);
        __bumps.insert("tree_authority".to_string(), __bump);
        if tree_authority.key() != __pda_address {
            return Err(anchor_lang::error::Error::from(
                anchor_lang::error::ErrorCode::ConstraintSeeds,
            )
            .with_account_name("tree_authority")
            .with_pubkeys((tree_authority.key(), __pda_address)));
        }
        if !tree_authority.to_account_info().is_writable {
            return Err(anchor_lang::error::Error::from(
                anchor_lang::error::ErrorCode::ConstraintMut,
            )
            .with_account_name("tree_authority"));
        }
        Ok(SetMintRequest {
            mint_authority_request,
            payer,
            mint_authority,
            tree_authority,
            system_program,
            merkle_slab,
        })
    }
}
#[automatically_derived]
impl<'info> anchor_lang::ToAccountInfos<'info> for SetMintRequest<'info>
where
    'info: 'info,
{
    fn to_account_infos(
        &self,
    ) -> Vec<anchor_lang::solana_program::account_info::AccountInfo<'info>> {
        let mut account_infos = ::alloc::vec::Vec::new();
        account_infos.extend(self.mint_authority_request.to_account_infos());
        account_infos.extend(self.payer.to_account_infos());
        account_infos.extend(self.mint_authority.to_account_infos());
        account_infos.extend(self.tree_authority.to_account_infos());
        account_infos.extend(self.system_program.to_account_infos());
        account_infos.extend(self.merkle_slab.to_account_infos());
        account_infos
    }
}
#[automatically_derived]
impl<'info> anchor_lang::ToAccountMetas for SetMintRequest<'info> {
    fn to_account_metas(
        &self,
        is_signer: Option<bool>,
    ) -> Vec<anchor_lang::solana_program::instruction::AccountMeta> {
        let mut account_metas = ::alloc::vec::Vec::new();
        account_metas.extend(self.mint_authority_request.to_account_metas(None));
        account_metas.extend(self.payer.to_account_metas(None));
        account_metas.extend(self.mint_authority.to_account_metas(None));
        account_metas.extend(self.tree_authority.to_account_metas(None));
        account_metas.extend(self.system_program.to_account_metas(None));
        account_metas.extend(self.merkle_slab.to_account_metas(None));
        account_metas
    }
}
#[automatically_derived]
impl<'info> anchor_lang::AccountsExit<'info> for SetMintRequest<'info>
where
    'info: 'info,
{
    fn exit(
        &self,
        program_id: &anchor_lang::solana_program::pubkey::Pubkey,
    ) -> anchor_lang::Result<()> {
        anchor_lang::AccountsExit::exit(&self.mint_authority_request, program_id)
            .map_err(|e| e.with_account_name("mint_authority_request"))?;
        anchor_lang::AccountsExit::exit(&self.payer, program_id)
            .map_err(|e| e.with_account_name("payer"))?;
        anchor_lang::AccountsExit::exit(&self.tree_authority, program_id)
            .map_err(|e| e.with_account_name("tree_authority"))?;
        Ok(())
    }
}
/// An internal, Anchor generated module. This is used (as an
/// implementation detail), to generate a struct for a given
/// `#[derive(Accounts)]` implementation, where each field is a Pubkey,
/// instead of an `AccountInfo`. This is useful for clients that want
/// to generate a list of accounts, without explicitly knowing the
/// order all the fields should be in.
///
/// To access the struct in this module, one should use the sibling
/// `accounts` module (also generated), which re-exports this.
pub(crate) mod __client_accounts_set_mint_request {
    use super::*;
    use anchor_lang::prelude::borsh;
    /// Generated client accounts for [`SetMintRequest`].
    pub struct SetMintRequest {
        pub mint_authority_request: anchor_lang::solana_program::pubkey::Pubkey,
        pub payer: anchor_lang::solana_program::pubkey::Pubkey,
        pub mint_authority: anchor_lang::solana_program::pubkey::Pubkey,
        pub tree_authority: anchor_lang::solana_program::pubkey::Pubkey,
        pub system_program: anchor_lang::solana_program::pubkey::Pubkey,
        pub merkle_slab: anchor_lang::solana_program::pubkey::Pubkey,
    }
    impl borsh::ser::BorshSerialize for SetMintRequest
    where
        anchor_lang::solana_program::pubkey::Pubkey: borsh::ser::BorshSerialize,
        anchor_lang::solana_program::pubkey::Pubkey: borsh::ser::BorshSerialize,
        anchor_lang::solana_program::pubkey::Pubkey: borsh::ser::BorshSerialize,
        anchor_lang::solana_program::pubkey::Pubkey: borsh::ser::BorshSerialize,
        anchor_lang::solana_program::pubkey::Pubkey: borsh::ser::BorshSerialize,
        anchor_lang::solana_program::pubkey::Pubkey: borsh::ser::BorshSerialize,
    {
        fn serialize<W: borsh::maybestd::io::Write>(
            &self,
            writer: &mut W,
        ) -> ::core::result::Result<(), borsh::maybestd::io::Error> {
            borsh::BorshSerialize::serialize(&self.mint_authority_request, writer)?;
            borsh::BorshSerialize::serialize(&self.payer, writer)?;
            borsh::BorshSerialize::serialize(&self.mint_authority, writer)?;
            borsh::BorshSerialize::serialize(&self.tree_authority, writer)?;
            borsh::BorshSerialize::serialize(&self.system_program, writer)?;
            borsh::BorshSerialize::serialize(&self.merkle_slab, writer)?;
            Ok(())
        }
    }
    #[automatically_derived]
    impl anchor_lang::ToAccountMetas for SetMintRequest {
        fn to_account_metas(
            &self,
            is_signer: Option<bool>,
        ) -> Vec<anchor_lang::solana_program::instruction::AccountMeta> {
            let mut account_metas = ::alloc::vec::Vec::new();
            account_metas.push(anchor_lang::solana_program::instruction::AccountMeta::new(
                self.mint_authority_request,
                false,
            ));
            account_metas.push(anchor_lang::solana_program::instruction::AccountMeta::new(
                self.payer, true,
            ));
            account_metas.push(
                anchor_lang::solana_program::instruction::AccountMeta::new_readonly(
                    self.mint_authority,
                    true,
                ),
            );
            account_metas.push(anchor_lang::solana_program::instruction::AccountMeta::new(
                self.tree_authority,
                false,
            ));
            account_metas.push(
                anchor_lang::solana_program::instruction::AccountMeta::new_readonly(
                    self.system_program,
                    false,
                ),
            );
            account_metas.push(
                anchor_lang::solana_program::instruction::AccountMeta::new_readonly(
                    self.merkle_slab,
                    false,
                ),
            );
            account_metas
        }
    }
}
/// An internal, Anchor generated module. This is used (as an
/// implementation detail), to generate a CPI struct for a given
/// `#[derive(Accounts)]` implementation, where each field is an
/// AccountInfo.
///
/// To access the struct in this module, one should use the sibling
/// [`cpi::accounts`] module (also generated), which re-exports this.
pub(crate) mod __cpi_client_accounts_set_mint_request {
    use super::*;
    /// Generated CPI struct of the accounts for [`SetMintRequest`].
    pub struct SetMintRequest<'info> {
        pub mint_authority_request: anchor_lang::solana_program::account_info::AccountInfo<'info>,
        pub payer: anchor_lang::solana_program::account_info::AccountInfo<'info>,
        pub mint_authority: anchor_lang::solana_program::account_info::AccountInfo<'info>,
        pub tree_authority: anchor_lang::solana_program::account_info::AccountInfo<'info>,
        pub system_program: anchor_lang::solana_program::account_info::AccountInfo<'info>,
        pub merkle_slab: anchor_lang::solana_program::account_info::AccountInfo<'info>,
    }
    #[automatically_derived]
    impl<'info> anchor_lang::ToAccountMetas for SetMintRequest<'info> {
        fn to_account_metas(
            &self,
            is_signer: Option<bool>,
        ) -> Vec<anchor_lang::solana_program::instruction::AccountMeta> {
            let mut account_metas = ::alloc::vec::Vec::new();
            account_metas.push(anchor_lang::solana_program::instruction::AccountMeta::new(
                anchor_lang::Key::key(&self.mint_authority_request),
                false,
            ));
            account_metas.push(anchor_lang::solana_program::instruction::AccountMeta::new(
                anchor_lang::Key::key(&self.payer),
                true,
            ));
            account_metas.push(
                anchor_lang::solana_program::instruction::AccountMeta::new_readonly(
                    anchor_lang::Key::key(&self.mint_authority),
                    true,
                ),
            );
            account_metas.push(anchor_lang::solana_program::instruction::AccountMeta::new(
                anchor_lang::Key::key(&self.tree_authority),
                false,
            ));
            account_metas.push(
                anchor_lang::solana_program::instruction::AccountMeta::new_readonly(
                    anchor_lang::Key::key(&self.system_program),
                    false,
                ),
            );
            account_metas.push(
                anchor_lang::solana_program::instruction::AccountMeta::new_readonly(
                    anchor_lang::Key::key(&self.merkle_slab),
                    false,
                ),
            );
            account_metas
        }
    }
    #[automatically_derived]
    impl<'info> anchor_lang::ToAccountInfos<'info> for SetMintRequest<'info> {
        fn to_account_infos(
            &self,
        ) -> Vec<anchor_lang::solana_program::account_info::AccountInfo<'info>> {
            let mut account_infos = ::alloc::vec::Vec::new();
            account_infos.push(anchor_lang::ToAccountInfo::to_account_info(
                &self.mint_authority_request,
            ));
            account_infos.push(anchor_lang::ToAccountInfo::to_account_info(&self.payer));
            account_infos.push(anchor_lang::ToAccountInfo::to_account_info(
                &self.mint_authority,
            ));
            account_infos.push(anchor_lang::ToAccountInfo::to_account_info(
                &self.tree_authority,
            ));
            account_infos.push(anchor_lang::ToAccountInfo::to_account_info(
                &self.system_program,
            ));
            account_infos.push(anchor_lang::ToAccountInfo::to_account_info(
                &self.merkle_slab,
            ));
            account_infos
        }
    }
}
pub struct SetDefaultMintRequest<'info> {
    # [account (init_if_needed , space = MINT_REQUEST_SIZE , seeds = [merkle_slab . key () . as_ref () , tree_authority . key () . as_ref ()] , payer = payer , bump)]
    pub mint_authority_request: Account<'info, MintRequest>,
    #[account(mut)]
    pub payer: Signer<'info>,
    pub creator: Signer<'info>,
    # [account (mut , seeds = [merkle_slab . key () . as_ref ()] , bump , has_one = creator ,)]
    pub tree_authority: Account<'info, TreeConfig>,
    pub system_program: Program<'info, System>,
    /// CHECK: this account is neither read from or written to
    pub merkle_slab: UncheckedAccount<'info>,
}
#[automatically_derived]
impl<'info> anchor_lang::Accounts<'info> for SetDefaultMintRequest<'info>
where
    'info: 'info,
{
    #[inline(never)]
    fn try_accounts(
        program_id: &anchor_lang::solana_program::pubkey::Pubkey,
        accounts: &mut &[anchor_lang::solana_program::account_info::AccountInfo<'info>],
        ix_data: &[u8],
        __bumps: &mut std::collections::BTreeMap<String, u8>,
        __reallocs: &mut std::collections::BTreeSet<anchor_lang::solana_program::pubkey::Pubkey>,
    ) -> anchor_lang::Result<Self> {
        if accounts.is_empty() {
            return Err(anchor_lang::error::ErrorCode::AccountNotEnoughKeys.into());
        }
        let mint_authority_request = &accounts[0];
        *accounts = &accounts[1..];
        let payer: Signer =
            anchor_lang::Accounts::try_accounts(program_id, accounts, ix_data, __bumps, __reallocs)
                .map_err(|e| e.with_account_name("payer"))?;
        let creator: Signer =
            anchor_lang::Accounts::try_accounts(program_id, accounts, ix_data, __bumps, __reallocs)
                .map_err(|e| e.with_account_name("creator"))?;
        let tree_authority: anchor_lang::accounts::account::Account<TreeConfig> =
            anchor_lang::Accounts::try_accounts(program_id, accounts, ix_data, __bumps, __reallocs)
                .map_err(|e| e.with_account_name("tree_authority"))?;
        let system_program: anchor_lang::accounts::program::Program<System> =
            anchor_lang::Accounts::try_accounts(program_id, accounts, ix_data, __bumps, __reallocs)
                .map_err(|e| e.with_account_name("system_program"))?;
        let merkle_slab: UncheckedAccount =
            anchor_lang::Accounts::try_accounts(program_id, accounts, ix_data, __bumps, __reallocs)
                .map_err(|e| e.with_account_name("merkle_slab"))?;
        let __anchor_rent = Rent::get()?;
        let (__pda_address, __bump) = Pubkey::find_program_address(
            &[merkle_slab.key().as_ref(), tree_authority.key().as_ref()],
            program_id,
        );
        __bumps.insert("mint_authority_request".to_string(), __bump);
        let mint_authority_request = {
            let actual_field = mint_authority_request.to_account_info();
            let actual_owner = actual_field.owner;
            let space = MINT_REQUEST_SIZE;
            let pa: anchor_lang::accounts::account::Account<MintRequest> = if !true
                || actual_owner == &anchor_lang::solana_program::system_program::ID
            {
                let payer = payer.to_account_info();
                let __current_lamports = mint_authority_request.lamports();
                if __current_lamports == 0 {
                    let lamports = __anchor_rent.minimum_balance(space);
                    let cpi_accounts = anchor_lang::system_program::CreateAccount {
                        from: payer.to_account_info(),
                        to: mint_authority_request.to_account_info(),
                    };
                    let cpi_context = anchor_lang::context::CpiContext::new(
                        system_program.to_account_info(),
                        cpi_accounts,
                    );
                    anchor_lang::system_program::create_account(
                        cpi_context.with_signer(&[&[
                            merkle_slab.key().as_ref(),
                            tree_authority.key().as_ref(),
                            &[__bump][..],
                        ][..]]),
                        lamports,
                        space as u64,
                        program_id,
                    )?;
                } else {
                    let required_lamports = __anchor_rent
                        .minimum_balance(space)
                        .max(1)
                        .saturating_sub(__current_lamports);
                    if required_lamports > 0 {
                        let cpi_accounts = anchor_lang::system_program::Transfer {
                            from: payer.to_account_info(),
                            to: mint_authority_request.to_account_info(),
                        };
                        let cpi_context = anchor_lang::context::CpiContext::new(
                            system_program.to_account_info(),
                            cpi_accounts,
                        );
                        anchor_lang::system_program::transfer(cpi_context, required_lamports)?;
                    }
                    let cpi_accounts = anchor_lang::system_program::Allocate {
                        account_to_allocate: mint_authority_request.to_account_info(),
                    };
                    let cpi_context = anchor_lang::context::CpiContext::new(
                        system_program.to_account_info(),
                        cpi_accounts,
                    );
                    anchor_lang::system_program::allocate(
                        cpi_context.with_signer(&[&[
                            merkle_slab.key().as_ref(),
                            tree_authority.key().as_ref(),
                            &[__bump][..],
                        ][..]]),
                        space as u64,
                    )?;
                    let cpi_accounts = anchor_lang::system_program::Assign {
                        account_to_assign: mint_authority_request.to_account_info(),
                    };
                    let cpi_context = anchor_lang::context::CpiContext::new(
                        system_program.to_account_info(),
                        cpi_accounts,
                    );
                    anchor_lang::system_program::assign(
                        cpi_context.with_signer(&[&[
                            merkle_slab.key().as_ref(),
                            tree_authority.key().as_ref(),
                            &[__bump][..],
                        ][..]]),
                        program_id,
                    )?;
                }
                anchor_lang::accounts::account::Account::try_from_unchecked(&mint_authority_request)
                    .map_err(|e| e.with_account_name("mint_authority_request"))?
            } else {
                anchor_lang::accounts::account::Account::try_from(&mint_authority_request)
                    .map_err(|e| e.with_account_name("mint_authority_request"))?
            };
            if true {
                if space != actual_field.data_len() {
                    return Err(anchor_lang::error::Error::from(
                        anchor_lang::error::ErrorCode::ConstraintSpace,
                    )
                    .with_account_name("mint_authority_request")
                    .with_values((space, actual_field.data_len())));
                }
                if actual_owner != program_id {
                    return Err(anchor_lang::error::Error::from(
                        anchor_lang::error::ErrorCode::ConstraintOwner,
                    )
                    .with_account_name("mint_authority_request")
                    .with_pubkeys((*actual_owner, *program_id)));
                }
                {
                    let required_lamports = __anchor_rent.minimum_balance(space);
                    if pa.to_account_info().lamports() < required_lamports {
                        return Err(anchor_lang::error::Error::from(
                            anchor_lang::error::ErrorCode::ConstraintRentExempt,
                        )
                        .with_account_name("mint_authority_request"));
                    }
                }
            }
            pa
        };
        if mint_authority_request.key() != __pda_address {
            return Err(anchor_lang::error::Error::from(
                anchor_lang::error::ErrorCode::ConstraintSeeds,
            )
            .with_account_name("mint_authority_request")
            .with_pubkeys((mint_authority_request.key(), __pda_address)));
        }
        if !mint_authority_request.to_account_info().is_writable {
            return Err(anchor_lang::error::Error::from(
                anchor_lang::error::ErrorCode::ConstraintMut,
            )
            .with_account_name("mint_authority_request"));
        }
        if !__anchor_rent.is_exempt(
            mint_authority_request.to_account_info().lamports(),
            mint_authority_request.to_account_info().try_data_len()?,
        ) {
            return Err(anchor_lang::error::Error::from(
                anchor_lang::error::ErrorCode::ConstraintRentExempt,
            )
            .with_account_name("mint_authority_request"));
        }
        if !payer.to_account_info().is_writable {
            return Err(anchor_lang::error::Error::from(
                anchor_lang::error::ErrorCode::ConstraintMut,
            )
            .with_account_name("payer"));
        }
        let (__pda_address, __bump) =
            Pubkey::find_program_address(&[merkle_slab.key().as_ref()], &program_id);
        __bumps.insert("tree_authority".to_string(), __bump);
        if tree_authority.key() != __pda_address {
            return Err(anchor_lang::error::Error::from(
                anchor_lang::error::ErrorCode::ConstraintSeeds,
            )
            .with_account_name("tree_authority")
            .with_pubkeys((tree_authority.key(), __pda_address)));
        }
        if !tree_authority.to_account_info().is_writable {
            return Err(anchor_lang::error::Error::from(
                anchor_lang::error::ErrorCode::ConstraintMut,
            )
            .with_account_name("tree_authority"));
        }
        {
            let my_key = tree_authority.creator;
            let target_key = creator.key();
            if my_key != target_key {
                return Err(anchor_lang::error::Error::from(
                    anchor_lang::error::ErrorCode::ConstraintHasOne,
                )
                .with_account_name("tree_authority")
                .with_pubkeys((my_key, target_key)));
            }
        }
        Ok(SetDefaultMintRequest {
            mint_authority_request,
            payer,
            creator,
            tree_authority,
            system_program,
            merkle_slab,
        })
    }
}
#[automatically_derived]
impl<'info> anchor_lang::ToAccountInfos<'info> for SetDefaultMintRequest<'info>
where
    'info: 'info,
{
    fn to_account_infos(
        &self,
    ) -> Vec<anchor_lang::solana_program::account_info::AccountInfo<'info>> {
        let mut account_infos = ::alloc::vec::Vec::new();
        account_infos.extend(self.mint_authority_request.to_account_infos());
        account_infos.extend(self.payer.to_account_infos());
        account_infos.extend(self.creator.to_account_infos());
        account_infos.extend(self.tree_authority.to_account_infos());
        account_infos.extend(self.system_program.to_account_infos());
        account_infos.extend(self.merkle_slab.to_account_infos());
        account_infos
    }
}
#[automatically_derived]
impl<'info> anchor_lang::ToAccountMetas for SetDefaultMintRequest<'info> {
    fn to_account_metas(
        &self,
        is_signer: Option<bool>,
    ) -> Vec<anchor_lang::solana_program::instruction::AccountMeta> {
        let mut account_metas = ::alloc::vec::Vec::new();
        account_metas.extend(self.mint_authority_request.to_account_metas(None));
        account_metas.extend(self.payer.to_account_metas(None));
        account_metas.extend(self.creator.to_account_metas(None));
        account_metas.extend(self.tree_authority.to_account_metas(None));
        account_metas.extend(self.system_program.to_account_metas(None));
        account_metas.extend(self.merkle_slab.to_account_metas(None));
        account_metas
    }
}
#[automatically_derived]
impl<'info> anchor_lang::AccountsExit<'info> for SetDefaultMintRequest<'info>
where
    'info: 'info,
{
    fn exit(
        &self,
        program_id: &anchor_lang::solana_program::pubkey::Pubkey,
    ) -> anchor_lang::Result<()> {
        anchor_lang::AccountsExit::exit(&self.mint_authority_request, program_id)
            .map_err(|e| e.with_account_name("mint_authority_request"))?;
        anchor_lang::AccountsExit::exit(&self.payer, program_id)
            .map_err(|e| e.with_account_name("payer"))?;
        anchor_lang::AccountsExit::exit(&self.tree_authority, program_id)
            .map_err(|e| e.with_account_name("tree_authority"))?;
        Ok(())
    }
}
/// An internal, Anchor generated module. This is used (as an
/// implementation detail), to generate a struct for a given
/// `#[derive(Accounts)]` implementation, where each field is a Pubkey,
/// instead of an `AccountInfo`. This is useful for clients that want
/// to generate a list of accounts, without explicitly knowing the
/// order all the fields should be in.
///
/// To access the struct in this module, one should use the sibling
/// `accounts` module (also generated), which re-exports this.
pub(crate) mod __client_accounts_set_default_mint_request {
    use super::*;
    use anchor_lang::prelude::borsh;
    /// Generated client accounts for [`SetDefaultMintRequest`].
    pub struct SetDefaultMintRequest {
        pub mint_authority_request: anchor_lang::solana_program::pubkey::Pubkey,
        pub payer: anchor_lang::solana_program::pubkey::Pubkey,
        pub creator: anchor_lang::solana_program::pubkey::Pubkey,
        pub tree_authority: anchor_lang::solana_program::pubkey::Pubkey,
        pub system_program: anchor_lang::solana_program::pubkey::Pubkey,
        pub merkle_slab: anchor_lang::solana_program::pubkey::Pubkey,
    }
    impl borsh::ser::BorshSerialize for SetDefaultMintRequest
    where
        anchor_lang::solana_program::pubkey::Pubkey: borsh::ser::BorshSerialize,
        anchor_lang::solana_program::pubkey::Pubkey: borsh::ser::BorshSerialize,
        anchor_lang::solana_program::pubkey::Pubkey: borsh::ser::BorshSerialize,
        anchor_lang::solana_program::pubkey::Pubkey: borsh::ser::BorshSerialize,
        anchor_lang::solana_program::pubkey::Pubkey: borsh::ser::BorshSerialize,
        anchor_lang::solana_program::pubkey::Pubkey: borsh::ser::BorshSerialize,
    {
        fn serialize<W: borsh::maybestd::io::Write>(
            &self,
            writer: &mut W,
        ) -> ::core::result::Result<(), borsh::maybestd::io::Error> {
            borsh::BorshSerialize::serialize(&self.mint_authority_request, writer)?;
            borsh::BorshSerialize::serialize(&self.payer, writer)?;
            borsh::BorshSerialize::serialize(&self.creator, writer)?;
            borsh::BorshSerialize::serialize(&self.tree_authority, writer)?;
            borsh::BorshSerialize::serialize(&self.system_program, writer)?;
            borsh::BorshSerialize::serialize(&self.merkle_slab, writer)?;
            Ok(())
        }
    }
    #[automatically_derived]
    impl anchor_lang::ToAccountMetas for SetDefaultMintRequest {
        fn to_account_metas(
            &self,
            is_signer: Option<bool>,
        ) -> Vec<anchor_lang::solana_program::instruction::AccountMeta> {
            let mut account_metas = ::alloc::vec::Vec::new();
            account_metas.push(anchor_lang::solana_program::instruction::AccountMeta::new(
                self.mint_authority_request,
                false,
            ));
            account_metas.push(anchor_lang::solana_program::instruction::AccountMeta::new(
                self.payer, true,
            ));
            account_metas.push(
                anchor_lang::solana_program::instruction::AccountMeta::new_readonly(
                    self.creator,
                    true,
                ),
            );
            account_metas.push(anchor_lang::solana_program::instruction::AccountMeta::new(
                self.tree_authority,
                false,
            ));
            account_metas.push(
                anchor_lang::solana_program::instruction::AccountMeta::new_readonly(
                    self.system_program,
                    false,
                ),
            );
            account_metas.push(
                anchor_lang::solana_program::instruction::AccountMeta::new_readonly(
                    self.merkle_slab,
                    false,
                ),
            );
            account_metas
        }
    }
}
/// An internal, Anchor generated module. This is used (as an
/// implementation detail), to generate a CPI struct for a given
/// `#[derive(Accounts)]` implementation, where each field is an
/// AccountInfo.
///
/// To access the struct in this module, one should use the sibling
/// [`cpi::accounts`] module (also generated), which re-exports this.
pub(crate) mod __cpi_client_accounts_set_default_mint_request {
    use super::*;
    /// Generated CPI struct of the accounts for [`SetDefaultMintRequest`].
    pub struct SetDefaultMintRequest<'info> {
        pub mint_authority_request: anchor_lang::solana_program::account_info::AccountInfo<'info>,
        pub payer: anchor_lang::solana_program::account_info::AccountInfo<'info>,
        pub creator: anchor_lang::solana_program::account_info::AccountInfo<'info>,
        pub tree_authority: anchor_lang::solana_program::account_info::AccountInfo<'info>,
        pub system_program: anchor_lang::solana_program::account_info::AccountInfo<'info>,
        pub merkle_slab: anchor_lang::solana_program::account_info::AccountInfo<'info>,
    }
    #[automatically_derived]
    impl<'info> anchor_lang::ToAccountMetas for SetDefaultMintRequest<'info> {
        fn to_account_metas(
            &self,
            is_signer: Option<bool>,
        ) -> Vec<anchor_lang::solana_program::instruction::AccountMeta> {
            let mut account_metas = ::alloc::vec::Vec::new();
            account_metas.push(anchor_lang::solana_program::instruction::AccountMeta::new(
                anchor_lang::Key::key(&self.mint_authority_request),
                false,
            ));
            account_metas.push(anchor_lang::solana_program::instruction::AccountMeta::new(
                anchor_lang::Key::key(&self.payer),
                true,
            ));
            account_metas.push(
                anchor_lang::solana_program::instruction::AccountMeta::new_readonly(
                    anchor_lang::Key::key(&self.creator),
                    true,
                ),
            );
            account_metas.push(anchor_lang::solana_program::instruction::AccountMeta::new(
                anchor_lang::Key::key(&self.tree_authority),
                false,
            ));
            account_metas.push(
                anchor_lang::solana_program::instruction::AccountMeta::new_readonly(
                    anchor_lang::Key::key(&self.system_program),
                    false,
                ),
            );
            account_metas.push(
                anchor_lang::solana_program::instruction::AccountMeta::new_readonly(
                    anchor_lang::Key::key(&self.merkle_slab),
                    false,
                ),
            );
            account_metas
        }
    }
    #[automatically_derived]
    impl<'info> anchor_lang::ToAccountInfos<'info> for SetDefaultMintRequest<'info> {
        fn to_account_infos(
            &self,
        ) -> Vec<anchor_lang::solana_program::account_info::AccountInfo<'info>> {
            let mut account_infos = ::alloc::vec::Vec::new();
            account_infos.push(anchor_lang::ToAccountInfo::to_account_info(
                &self.mint_authority_request,
            ));
            account_infos.push(anchor_lang::ToAccountInfo::to_account_info(&self.payer));
            account_infos.push(anchor_lang::ToAccountInfo::to_account_info(&self.creator));
            account_infos.push(anchor_lang::ToAccountInfo::to_account_info(
                &self.tree_authority,
            ));
            account_infos.push(anchor_lang::ToAccountInfo::to_account_info(
                &self.system_program,
            ));
            account_infos.push(anchor_lang::ToAccountInfo::to_account_info(
                &self.merkle_slab,
            ));
            account_infos
        }
    }
}
pub struct ApproveMintRequest<'info> {
    # [account (mut , seeds = [merkle_slab . key () . as_ref () , mint_authority_request . mint_authority . as_ref ()] , bump)]
    pub mint_authority_request: Account<'info, MintRequest>,
    # [account (constraint = * tree_delegate . key == tree_authority . creator || * tree_delegate . key == tree_authority . delegate)]
    pub tree_delegate: Signer<'info>,
    # [account (mut , seeds = [merkle_slab . key () . as_ref ()] , bump)]
    pub tree_authority: Account<'info, TreeConfig>,
    /// CHECK: this account is neither read from or written to
    pub merkle_slab: UncheckedAccount<'info>,
}
#[automatically_derived]
impl<'info> anchor_lang::Accounts<'info> for ApproveMintRequest<'info>
where
    'info: 'info,
{
    #[inline(never)]
    fn try_accounts(
        program_id: &anchor_lang::solana_program::pubkey::Pubkey,
        accounts: &mut &[anchor_lang::solana_program::account_info::AccountInfo<'info>],
        ix_data: &[u8],
        __bumps: &mut std::collections::BTreeMap<String, u8>,
        __reallocs: &mut std::collections::BTreeSet<anchor_lang::solana_program::pubkey::Pubkey>,
    ) -> anchor_lang::Result<Self> {
        let mint_authority_request: anchor_lang::accounts::account::Account<MintRequest> =
            anchor_lang::Accounts::try_accounts(program_id, accounts, ix_data, __bumps, __reallocs)
                .map_err(|e| e.with_account_name("mint_authority_request"))?;
        let tree_delegate: Signer =
            anchor_lang::Accounts::try_accounts(program_id, accounts, ix_data, __bumps, __reallocs)
                .map_err(|e| e.with_account_name("tree_delegate"))?;
        let tree_authority: anchor_lang::accounts::account::Account<TreeConfig> =
            anchor_lang::Accounts::try_accounts(program_id, accounts, ix_data, __bumps, __reallocs)
                .map_err(|e| e.with_account_name("tree_authority"))?;
        let merkle_slab: UncheckedAccount =
            anchor_lang::Accounts::try_accounts(program_id, accounts, ix_data, __bumps, __reallocs)
                .map_err(|e| e.with_account_name("merkle_slab"))?;
        let (__pda_address, __bump) = Pubkey::find_program_address(
            &[
                merkle_slab.key().as_ref(),
                mint_authority_request.mint_authority.as_ref(),
            ],
            &program_id,
        );
        __bumps.insert("mint_authority_request".to_string(), __bump);
        if mint_authority_request.key() != __pda_address {
            return Err(anchor_lang::error::Error::from(
                anchor_lang::error::ErrorCode::ConstraintSeeds,
            )
            .with_account_name("mint_authority_request")
            .with_pubkeys((mint_authority_request.key(), __pda_address)));
        }
        if !mint_authority_request.to_account_info().is_writable {
            return Err(anchor_lang::error::Error::from(
                anchor_lang::error::ErrorCode::ConstraintMut,
            )
            .with_account_name("mint_authority_request"));
        }
        if !(*tree_delegate.key == tree_authority.creator
            || *tree_delegate.key == tree_authority.delegate)
        {
            return Err(anchor_lang::error::Error::from(
                anchor_lang::error::ErrorCode::ConstraintRaw,
            )
            .with_account_name("tree_delegate"));
        }
        let (__pda_address, __bump) =
            Pubkey::find_program_address(&[merkle_slab.key().as_ref()], &program_id);
        __bumps.insert("tree_authority".to_string(), __bump);
        if tree_authority.key() != __pda_address {
            return Err(anchor_lang::error::Error::from(
                anchor_lang::error::ErrorCode::ConstraintSeeds,
            )
            .with_account_name("tree_authority")
            .with_pubkeys((tree_authority.key(), __pda_address)));
        }
        if !tree_authority.to_account_info().is_writable {
            return Err(anchor_lang::error::Error::from(
                anchor_lang::error::ErrorCode::ConstraintMut,
            )
            .with_account_name("tree_authority"));
        }
        Ok(ApproveMintRequest {
            mint_authority_request,
            tree_delegate,
            tree_authority,
            merkle_slab,
        })
    }
}
#[automatically_derived]
impl<'info> anchor_lang::ToAccountInfos<'info> for ApproveMintRequest<'info>
where
    'info: 'info,
{
    fn to_account_infos(
        &self,
    ) -> Vec<anchor_lang::solana_program::account_info::AccountInfo<'info>> {
        let mut account_infos = ::alloc::vec::Vec::new();
        account_infos.extend(self.mint_authority_request.to_account_infos());
        account_infos.extend(self.tree_delegate.to_account_infos());
        account_infos.extend(self.tree_authority.to_account_infos());
        account_infos.extend(self.merkle_slab.to_account_infos());
        account_infos
    }
}
#[automatically_derived]
impl<'info> anchor_lang::ToAccountMetas for ApproveMintRequest<'info> {
    fn to_account_metas(
        &self,
        is_signer: Option<bool>,
    ) -> Vec<anchor_lang::solana_program::instruction::AccountMeta> {
        let mut account_metas = ::alloc::vec::Vec::new();
        account_metas.extend(self.mint_authority_request.to_account_metas(None));
        account_metas.extend(self.tree_delegate.to_account_metas(None));
        account_metas.extend(self.tree_authority.to_account_metas(None));
        account_metas.extend(self.merkle_slab.to_account_metas(None));
        account_metas
    }
}
#[automatically_derived]
impl<'info> anchor_lang::AccountsExit<'info> for ApproveMintRequest<'info>
where
    'info: 'info,
{
    fn exit(
        &self,
        program_id: &anchor_lang::solana_program::pubkey::Pubkey,
    ) -> anchor_lang::Result<()> {
        anchor_lang::AccountsExit::exit(&self.mint_authority_request, program_id)
            .map_err(|e| e.with_account_name("mint_authority_request"))?;
        anchor_lang::AccountsExit::exit(&self.tree_authority, program_id)
            .map_err(|e| e.with_account_name("tree_authority"))?;
        Ok(())
    }
}
/// An internal, Anchor generated module. This is used (as an
/// implementation detail), to generate a struct for a given
/// `#[derive(Accounts)]` implementation, where each field is a Pubkey,
/// instead of an `AccountInfo`. This is useful for clients that want
/// to generate a list of accounts, without explicitly knowing the
/// order all the fields should be in.
///
/// To access the struct in this module, one should use the sibling
/// `accounts` module (also generated), which re-exports this.
pub(crate) mod __client_accounts_approve_mint_request {
    use super::*;
    use anchor_lang::prelude::borsh;
    /// Generated client accounts for [`ApproveMintRequest`].
    pub struct ApproveMintRequest {
        pub mint_authority_request: anchor_lang::solana_program::pubkey::Pubkey,
        pub tree_delegate: anchor_lang::solana_program::pubkey::Pubkey,
        pub tree_authority: anchor_lang::solana_program::pubkey::Pubkey,
        pub merkle_slab: anchor_lang::solana_program::pubkey::Pubkey,
    }
    impl borsh::ser::BorshSerialize for ApproveMintRequest
    where
        anchor_lang::solana_program::pubkey::Pubkey: borsh::ser::BorshSerialize,
        anchor_lang::solana_program::pubkey::Pubkey: borsh::ser::BorshSerialize,
        anchor_lang::solana_program::pubkey::Pubkey: borsh::ser::BorshSerialize,
        anchor_lang::solana_program::pubkey::Pubkey: borsh::ser::BorshSerialize,
    {
        fn serialize<W: borsh::maybestd::io::Write>(
            &self,
            writer: &mut W,
        ) -> ::core::result::Result<(), borsh::maybestd::io::Error> {
            borsh::BorshSerialize::serialize(&self.mint_authority_request, writer)?;
            borsh::BorshSerialize::serialize(&self.tree_delegate, writer)?;
            borsh::BorshSerialize::serialize(&self.tree_authority, writer)?;
            borsh::BorshSerialize::serialize(&self.merkle_slab, writer)?;
            Ok(())
        }
    }
    #[automatically_derived]
    impl anchor_lang::ToAccountMetas for ApproveMintRequest {
        fn to_account_metas(
            &self,
            is_signer: Option<bool>,
        ) -> Vec<anchor_lang::solana_program::instruction::AccountMeta> {
            let mut account_metas = ::alloc::vec::Vec::new();
            account_metas.push(anchor_lang::solana_program::instruction::AccountMeta::new(
                self.mint_authority_request,
                false,
            ));
            account_metas.push(
                anchor_lang::solana_program::instruction::AccountMeta::new_readonly(
                    self.tree_delegate,
                    true,
                ),
            );
            account_metas.push(anchor_lang::solana_program::instruction::AccountMeta::new(
                self.tree_authority,
                false,
            ));
            account_metas.push(
                anchor_lang::solana_program::instruction::AccountMeta::new_readonly(
                    self.merkle_slab,
                    false,
                ),
            );
            account_metas
        }
    }
}
/// An internal, Anchor generated module. This is used (as an
/// implementation detail), to generate a CPI struct for a given
/// `#[derive(Accounts)]` implementation, where each field is an
/// AccountInfo.
///
/// To access the struct in this module, one should use the sibling
/// [`cpi::accounts`] module (also generated), which re-exports this.
pub(crate) mod __cpi_client_accounts_approve_mint_request {
    use super::*;
    /// Generated CPI struct of the accounts for [`ApproveMintRequest`].
    pub struct ApproveMintRequest<'info> {
        pub mint_authority_request: anchor_lang::solana_program::account_info::AccountInfo<'info>,
        pub tree_delegate: anchor_lang::solana_program::account_info::AccountInfo<'info>,
        pub tree_authority: anchor_lang::solana_program::account_info::AccountInfo<'info>,
        pub merkle_slab: anchor_lang::solana_program::account_info::AccountInfo<'info>,
    }
    #[automatically_derived]
    impl<'info> anchor_lang::ToAccountMetas for ApproveMintRequest<'info> {
        fn to_account_metas(
            &self,
            is_signer: Option<bool>,
        ) -> Vec<anchor_lang::solana_program::instruction::AccountMeta> {
            let mut account_metas = ::alloc::vec::Vec::new();
            account_metas.push(anchor_lang::solana_program::instruction::AccountMeta::new(
                anchor_lang::Key::key(&self.mint_authority_request),
                false,
            ));
            account_metas.push(
                anchor_lang::solana_program::instruction::AccountMeta::new_readonly(
                    anchor_lang::Key::key(&self.tree_delegate),
                    true,
                ),
            );
            account_metas.push(anchor_lang::solana_program::instruction::AccountMeta::new(
                anchor_lang::Key::key(&self.tree_authority),
                false,
            ));
            account_metas.push(
                anchor_lang::solana_program::instruction::AccountMeta::new_readonly(
                    anchor_lang::Key::key(&self.merkle_slab),
                    false,
                ),
            );
            account_metas
        }
    }
    #[automatically_derived]
    impl<'info> anchor_lang::ToAccountInfos<'info> for ApproveMintRequest<'info> {
        fn to_account_infos(
            &self,
        ) -> Vec<anchor_lang::solana_program::account_info::AccountInfo<'info>> {
            let mut account_infos = ::alloc::vec::Vec::new();
            account_infos.push(anchor_lang::ToAccountInfo::to_account_info(
                &self.mint_authority_request,
            ));
            account_infos.push(anchor_lang::ToAccountInfo::to_account_info(
                &self.tree_delegate,
            ));
            account_infos.push(anchor_lang::ToAccountInfo::to_account_info(
                &self.tree_authority,
            ));
            account_infos.push(anchor_lang::ToAccountInfo::to_account_info(
                &self.merkle_slab,
            ));
            account_infos
        }
    }
}
pub struct CloseMintRequest<'info> {
    # [account (mut , close = mint_authority , seeds = [merkle_slab . key () . as_ref () , mint_authority . key () . as_ref ()] , bump)]
    pub mint_authority_request: Account<'info, MintRequest>,
    #[account(mut)]
    pub mint_authority: Signer<'info>,
    # [account (mut , seeds = [merkle_slab . key () . as_ref ()] , bump)]
    pub tree_authority: Account<'info, TreeConfig>,
    /// CHECK: this account is neither read from or written to
    pub merkle_slab: UncheckedAccount<'info>,
}
#[automatically_derived]
impl<'info> anchor_lang::Accounts<'info> for CloseMintRequest<'info>
where
    'info: 'info,
{
    #[inline(never)]
    fn try_accounts(
        program_id: &anchor_lang::solana_program::pubkey::Pubkey,
        accounts: &mut &[anchor_lang::solana_program::account_info::AccountInfo<'info>],
        ix_data: &[u8],
        __bumps: &mut std::collections::BTreeMap<String, u8>,
        __reallocs: &mut std::collections::BTreeSet<anchor_lang::solana_program::pubkey::Pubkey>,
    ) -> anchor_lang::Result<Self> {
        let mint_authority_request: anchor_lang::accounts::account::Account<MintRequest> =
            anchor_lang::Accounts::try_accounts(program_id, accounts, ix_data, __bumps, __reallocs)
                .map_err(|e| e.with_account_name("mint_authority_request"))?;
        let mint_authority: Signer =
            anchor_lang::Accounts::try_accounts(program_id, accounts, ix_data, __bumps, __reallocs)
                .map_err(|e| e.with_account_name("mint_authority"))?;
        let tree_authority: anchor_lang::accounts::account::Account<TreeConfig> =
            anchor_lang::Accounts::try_accounts(program_id, accounts, ix_data, __bumps, __reallocs)
                .map_err(|e| e.with_account_name("tree_authority"))?;
        let merkle_slab: UncheckedAccount =
            anchor_lang::Accounts::try_accounts(program_id, accounts, ix_data, __bumps, __reallocs)
                .map_err(|e| e.with_account_name("merkle_slab"))?;
        let (__pda_address, __bump) = Pubkey::find_program_address(
            &[merkle_slab.key().as_ref(), mint_authority.key().as_ref()],
            &program_id,
        );
        __bumps.insert("mint_authority_request".to_string(), __bump);
        if mint_authority_request.key() != __pda_address {
            return Err(anchor_lang::error::Error::from(
                anchor_lang::error::ErrorCode::ConstraintSeeds,
            )
            .with_account_name("mint_authority_request")
            .with_pubkeys((mint_authority_request.key(), __pda_address)));
        }
        if !mint_authority_request.to_account_info().is_writable {
            return Err(anchor_lang::error::Error::from(
                anchor_lang::error::ErrorCode::ConstraintMut,
            )
            .with_account_name("mint_authority_request"));
        }
        if mint_authority_request.key() == mint_authority.key() {
            return Err(anchor_lang::error::Error::from(
                anchor_lang::error::ErrorCode::ConstraintClose,
            )
            .with_account_name("mint_authority_request"));
        }
        if !mint_authority.to_account_info().is_writable {
            return Err(anchor_lang::error::Error::from(
                anchor_lang::error::ErrorCode::ConstraintMut,
            )
            .with_account_name("mint_authority"));
        }
        let (__pda_address, __bump) =
            Pubkey::find_program_address(&[merkle_slab.key().as_ref()], &program_id);
        __bumps.insert("tree_authority".to_string(), __bump);
        if tree_authority.key() != __pda_address {
            return Err(anchor_lang::error::Error::from(
                anchor_lang::error::ErrorCode::ConstraintSeeds,
            )
            .with_account_name("tree_authority")
            .with_pubkeys((tree_authority.key(), __pda_address)));
        }
        if !tree_authority.to_account_info().is_writable {
            return Err(anchor_lang::error::Error::from(
                anchor_lang::error::ErrorCode::ConstraintMut,
            )
            .with_account_name("tree_authority"));
        }
        Ok(CloseMintRequest {
            mint_authority_request,
            mint_authority,
            tree_authority,
            merkle_slab,
        })
    }
}
#[automatically_derived]
impl<'info> anchor_lang::ToAccountInfos<'info> for CloseMintRequest<'info>
where
    'info: 'info,
{
    fn to_account_infos(
        &self,
    ) -> Vec<anchor_lang::solana_program::account_info::AccountInfo<'info>> {
        let mut account_infos = ::alloc::vec::Vec::new();
        account_infos.extend(self.mint_authority_request.to_account_infos());
        account_infos.extend(self.mint_authority.to_account_infos());
        account_infos.extend(self.tree_authority.to_account_infos());
        account_infos.extend(self.merkle_slab.to_account_infos());
        account_infos
    }
}
#[automatically_derived]
impl<'info> anchor_lang::ToAccountMetas for CloseMintRequest<'info> {
    fn to_account_metas(
        &self,
        is_signer: Option<bool>,
    ) -> Vec<anchor_lang::solana_program::instruction::AccountMeta> {
        let mut account_metas = ::alloc::vec::Vec::new();
        account_metas.extend(self.mint_authority_request.to_account_metas(None));
        account_metas.extend(self.mint_authority.to_account_metas(None));
        account_metas.extend(self.tree_authority.to_account_metas(None));
        account_metas.extend(self.merkle_slab.to_account_metas(None));
        account_metas
    }
}
#[automatically_derived]
impl<'info> anchor_lang::AccountsExit<'info> for CloseMintRequest<'info>
where
    'info: 'info,
{
    fn exit(
        &self,
        program_id: &anchor_lang::solana_program::pubkey::Pubkey,
    ) -> anchor_lang::Result<()> {
        anchor_lang::AccountsClose::close(
            &self.mint_authority_request,
            self.mint_authority.to_account_info(),
        )
        .map_err(|e| e.with_account_name("mint_authority_request"))?;
        anchor_lang::AccountsExit::exit(&self.mint_authority, program_id)
            .map_err(|e| e.with_account_name("mint_authority"))?;
        anchor_lang::AccountsExit::exit(&self.tree_authority, program_id)
            .map_err(|e| e.with_account_name("tree_authority"))?;
        Ok(())
    }
}
/// An internal, Anchor generated module. This is used (as an
/// implementation detail), to generate a struct for a given
/// `#[derive(Accounts)]` implementation, where each field is a Pubkey,
/// instead of an `AccountInfo`. This is useful for clients that want
/// to generate a list of accounts, without explicitly knowing the
/// order all the fields should be in.
///
/// To access the struct in this module, one should use the sibling
/// `accounts` module (also generated), which re-exports this.
pub(crate) mod __client_accounts_close_mint_request {
    use super::*;
    use anchor_lang::prelude::borsh;
    /// Generated client accounts for [`CloseMintRequest`].
    pub struct CloseMintRequest {
        pub mint_authority_request: anchor_lang::solana_program::pubkey::Pubkey,
        pub mint_authority: anchor_lang::solana_program::pubkey::Pubkey,
        pub tree_authority: anchor_lang::solana_program::pubkey::Pubkey,
        pub merkle_slab: anchor_lang::solana_program::pubkey::Pubkey,
    }
    impl borsh::ser::BorshSerialize for CloseMintRequest
    where
        anchor_lang::solana_program::pubkey::Pubkey: borsh::ser::BorshSerialize,
        anchor_lang::solana_program::pubkey::Pubkey: borsh::ser::BorshSerialize,
        anchor_lang::solana_program::pubkey::Pubkey: borsh::ser::BorshSerialize,
        anchor_lang::solana_program::pubkey::Pubkey: borsh::ser::BorshSerialize,
    {
        fn serialize<W: borsh::maybestd::io::Write>(
            &self,
            writer: &mut W,
        ) -> ::core::result::Result<(), borsh::maybestd::io::Error> {
            borsh::BorshSerialize::serialize(&self.mint_authority_request, writer)?;
            borsh::BorshSerialize::serialize(&self.mint_authority, writer)?;
            borsh::BorshSerialize::serialize(&self.tree_authority, writer)?;
            borsh::BorshSerialize::serialize(&self.merkle_slab, writer)?;
            Ok(())
        }
    }
    #[automatically_derived]
    impl anchor_lang::ToAccountMetas for CloseMintRequest {
        fn to_account_metas(
            &self,
            is_signer: Option<bool>,
        ) -> Vec<anchor_lang::solana_program::instruction::AccountMeta> {
            let mut account_metas = ::alloc::vec::Vec::new();
            account_metas.push(anchor_lang::solana_program::instruction::AccountMeta::new(
                self.mint_authority_request,
                false,
            ));
            account_metas.push(anchor_lang::solana_program::instruction::AccountMeta::new(
                self.mint_authority,
                true,
            ));
            account_metas.push(anchor_lang::solana_program::instruction::AccountMeta::new(
                self.tree_authority,
                false,
            ));
            account_metas.push(
                anchor_lang::solana_program::instruction::AccountMeta::new_readonly(
                    self.merkle_slab,
                    false,
                ),
            );
            account_metas
        }
    }
}
/// An internal, Anchor generated module. This is used (as an
/// implementation detail), to generate a CPI struct for a given
/// `#[derive(Accounts)]` implementation, where each field is an
/// AccountInfo.
///
/// To access the struct in this module, one should use the sibling
/// [`cpi::accounts`] module (also generated), which re-exports this.
pub(crate) mod __cpi_client_accounts_close_mint_request {
    use super::*;
    /// Generated CPI struct of the accounts for [`CloseMintRequest`].
    pub struct CloseMintRequest<'info> {
        pub mint_authority_request: anchor_lang::solana_program::account_info::AccountInfo<'info>,
        pub mint_authority: anchor_lang::solana_program::account_info::AccountInfo<'info>,
        pub tree_authority: anchor_lang::solana_program::account_info::AccountInfo<'info>,
        pub merkle_slab: anchor_lang::solana_program::account_info::AccountInfo<'info>,
    }
    #[automatically_derived]
    impl<'info> anchor_lang::ToAccountMetas for CloseMintRequest<'info> {
        fn to_account_metas(
            &self,
            is_signer: Option<bool>,
        ) -> Vec<anchor_lang::solana_program::instruction::AccountMeta> {
            let mut account_metas = ::alloc::vec::Vec::new();
            account_metas.push(anchor_lang::solana_program::instruction::AccountMeta::new(
                anchor_lang::Key::key(&self.mint_authority_request),
                false,
            ));
            account_metas.push(anchor_lang::solana_program::instruction::AccountMeta::new(
                anchor_lang::Key::key(&self.mint_authority),
                true,
            ));
            account_metas.push(anchor_lang::solana_program::instruction::AccountMeta::new(
                anchor_lang::Key::key(&self.tree_authority),
                false,
            ));
            account_metas.push(
                anchor_lang::solana_program::instruction::AccountMeta::new_readonly(
                    anchor_lang::Key::key(&self.merkle_slab),
                    false,
                ),
            );
            account_metas
        }
    }
    #[automatically_derived]
    impl<'info> anchor_lang::ToAccountInfos<'info> for CloseMintRequest<'info> {
        fn to_account_infos(
            &self,
        ) -> Vec<anchor_lang::solana_program::account_info::AccountInfo<'info>> {
            let mut account_infos = ::alloc::vec::Vec::new();
            account_infos.push(anchor_lang::ToAccountInfo::to_account_info(
                &self.mint_authority_request,
            ));
            account_infos.push(anchor_lang::ToAccountInfo::to_account_info(
                &self.mint_authority,
            ));
            account_infos.push(anchor_lang::ToAccountInfo::to_account_info(
                &self.tree_authority,
            ));
            account_infos.push(anchor_lang::ToAccountInfo::to_account_info(
                &self.merkle_slab,
            ));
            account_infos
        }
    }
}
pub struct SetTreeDelegate<'info> {
    pub creator: Signer<'info>,
    /// CHECK: this account is neither read from or written to
    pub new_delegate: UncheckedAccount<'info>,
    /// CHECK: this account is neither read from or written to
    pub merkle_slab: UncheckedAccount<'info>,
    # [account (mut , seeds = [merkle_slab . key () . as_ref ()] , bump , has_one = creator)]
    pub tree_authority: Account<'info, TreeConfig>,
}
#[automatically_derived]
impl<'info> anchor_lang::Accounts<'info> for SetTreeDelegate<'info>
where
    'info: 'info,
{
    #[inline(never)]
    fn try_accounts(
        program_id: &anchor_lang::solana_program::pubkey::Pubkey,
        accounts: &mut &[anchor_lang::solana_program::account_info::AccountInfo<'info>],
        ix_data: &[u8],
        __bumps: &mut std::collections::BTreeMap<String, u8>,
        __reallocs: &mut std::collections::BTreeSet<anchor_lang::solana_program::pubkey::Pubkey>,
    ) -> anchor_lang::Result<Self> {
        let creator: Signer =
            anchor_lang::Accounts::try_accounts(program_id, accounts, ix_data, __bumps, __reallocs)
                .map_err(|e| e.with_account_name("creator"))?;
        let new_delegate: UncheckedAccount =
            anchor_lang::Accounts::try_accounts(program_id, accounts, ix_data, __bumps, __reallocs)
                .map_err(|e| e.with_account_name("new_delegate"))?;
        let merkle_slab: UncheckedAccount =
            anchor_lang::Accounts::try_accounts(program_id, accounts, ix_data, __bumps, __reallocs)
                .map_err(|e| e.with_account_name("merkle_slab"))?;
        let tree_authority: anchor_lang::accounts::account::Account<TreeConfig> =
            anchor_lang::Accounts::try_accounts(program_id, accounts, ix_data, __bumps, __reallocs)
                .map_err(|e| e.with_account_name("tree_authority"))?;
        let (__pda_address, __bump) =
            Pubkey::find_program_address(&[merkle_slab.key().as_ref()], &program_id);
        __bumps.insert("tree_authority".to_string(), __bump);
        if tree_authority.key() != __pda_address {
            return Err(anchor_lang::error::Error::from(
                anchor_lang::error::ErrorCode::ConstraintSeeds,
            )
            .with_account_name("tree_authority")
            .with_pubkeys((tree_authority.key(), __pda_address)));
        }
        if !tree_authority.to_account_info().is_writable {
            return Err(anchor_lang::error::Error::from(
                anchor_lang::error::ErrorCode::ConstraintMut,
            )
            .with_account_name("tree_authority"));
        }
        {
            let my_key = tree_authority.creator;
            let target_key = creator.key();
            if my_key != target_key {
                return Err(anchor_lang::error::Error::from(
                    anchor_lang::error::ErrorCode::ConstraintHasOne,
                )
                .with_account_name("tree_authority")
                .with_pubkeys((my_key, target_key)));
            }
        }
        Ok(SetTreeDelegate {
            creator,
            new_delegate,
            merkle_slab,
            tree_authority,
        })
    }
}
#[automatically_derived]
impl<'info> anchor_lang::ToAccountInfos<'info> for SetTreeDelegate<'info>
where
    'info: 'info,
{
    fn to_account_infos(
        &self,
    ) -> Vec<anchor_lang::solana_program::account_info::AccountInfo<'info>> {
        let mut account_infos = ::alloc::vec::Vec::new();
        account_infos.extend(self.creator.to_account_infos());
        account_infos.extend(self.new_delegate.to_account_infos());
        account_infos.extend(self.merkle_slab.to_account_infos());
        account_infos.extend(self.tree_authority.to_account_infos());
        account_infos
    }
}
#[automatically_derived]
impl<'info> anchor_lang::ToAccountMetas for SetTreeDelegate<'info> {
    fn to_account_metas(
        &self,
        is_signer: Option<bool>,
    ) -> Vec<anchor_lang::solana_program::instruction::AccountMeta> {
        let mut account_metas = ::alloc::vec::Vec::new();
        account_metas.extend(self.creator.to_account_metas(None));
        account_metas.extend(self.new_delegate.to_account_metas(None));
        account_metas.extend(self.merkle_slab.to_account_metas(None));
        account_metas.extend(self.tree_authority.to_account_metas(None));
        account_metas
    }
}
#[automatically_derived]
impl<'info> anchor_lang::AccountsExit<'info> for SetTreeDelegate<'info>
where
    'info: 'info,
{
    fn exit(
        &self,
        program_id: &anchor_lang::solana_program::pubkey::Pubkey,
    ) -> anchor_lang::Result<()> {
        anchor_lang::AccountsExit::exit(&self.tree_authority, program_id)
            .map_err(|e| e.with_account_name("tree_authority"))?;
        Ok(())
    }
}
/// An internal, Anchor generated module. This is used (as an
/// implementation detail), to generate a struct for a given
/// `#[derive(Accounts)]` implementation, where each field is a Pubkey,
/// instead of an `AccountInfo`. This is useful for clients that want
/// to generate a list of accounts, without explicitly knowing the
/// order all the fields should be in.
///
/// To access the struct in this module, one should use the sibling
/// `accounts` module (also generated), which re-exports this.
pub(crate) mod __client_accounts_set_tree_delegate {
    use super::*;
    use anchor_lang::prelude::borsh;
    /// Generated client accounts for [`SetTreeDelegate`].
    pub struct SetTreeDelegate {
        pub creator: anchor_lang::solana_program::pubkey::Pubkey,
        pub new_delegate: anchor_lang::solana_program::pubkey::Pubkey,
        pub merkle_slab: anchor_lang::solana_program::pubkey::Pubkey,
        pub tree_authority: anchor_lang::solana_program::pubkey::Pubkey,
    }
    impl borsh::ser::BorshSerialize for SetTreeDelegate
    where
        anchor_lang::solana_program::pubkey::Pubkey: borsh::ser::BorshSerialize,
        anchor_lang::solana_program::pubkey::Pubkey: borsh::ser::BorshSerialize,
        anchor_lang::solana_program::pubkey::Pubkey: borsh::ser::BorshSerialize,
        anchor_lang::solana_program::pubkey::Pubkey: borsh::ser::BorshSerialize,
    {
        fn serialize<W: borsh::maybestd::io::Write>(
            &self,
            writer: &mut W,
        ) -> ::core::result::Result<(), borsh::maybestd::io::Error> {
            borsh::BorshSerialize::serialize(&self.creator, writer)?;
            borsh::BorshSerialize::serialize(&self.new_delegate, writer)?;
            borsh::BorshSerialize::serialize(&self.merkle_slab, writer)?;
            borsh::BorshSerialize::serialize(&self.tree_authority, writer)?;
            Ok(())
        }
    }
    #[automatically_derived]
    impl anchor_lang::ToAccountMetas for SetTreeDelegate {
        fn to_account_metas(
            &self,
            is_signer: Option<bool>,
        ) -> Vec<anchor_lang::solana_program::instruction::AccountMeta> {
            let mut account_metas = ::alloc::vec::Vec::new();
            account_metas.push(
                anchor_lang::solana_program::instruction::AccountMeta::new_readonly(
                    self.creator,
                    true,
                ),
            );
            account_metas.push(
                anchor_lang::solana_program::instruction::AccountMeta::new_readonly(
                    self.new_delegate,
                    false,
                ),
            );
            account_metas.push(
                anchor_lang::solana_program::instruction::AccountMeta::new_readonly(
                    self.merkle_slab,
                    false,
                ),
            );
            account_metas.push(anchor_lang::solana_program::instruction::AccountMeta::new(
                self.tree_authority,
                false,
            ));
            account_metas
        }
    }
}
/// An internal, Anchor generated module. This is used (as an
/// implementation detail), to generate a CPI struct for a given
/// `#[derive(Accounts)]` implementation, where each field is an
/// AccountInfo.
///
/// To access the struct in this module, one should use the sibling
/// [`cpi::accounts`] module (also generated), which re-exports this.
pub(crate) mod __cpi_client_accounts_set_tree_delegate {
    use super::*;
    /// Generated CPI struct of the accounts for [`SetTreeDelegate`].
    pub struct SetTreeDelegate<'info> {
        pub creator: anchor_lang::solana_program::account_info::AccountInfo<'info>,
        pub new_delegate: anchor_lang::solana_program::account_info::AccountInfo<'info>,
        pub merkle_slab: anchor_lang::solana_program::account_info::AccountInfo<'info>,
        pub tree_authority: anchor_lang::solana_program::account_info::AccountInfo<'info>,
    }
    #[automatically_derived]
    impl<'info> anchor_lang::ToAccountMetas for SetTreeDelegate<'info> {
        fn to_account_metas(
            &self,
            is_signer: Option<bool>,
        ) -> Vec<anchor_lang::solana_program::instruction::AccountMeta> {
            let mut account_metas = ::alloc::vec::Vec::new();
            account_metas.push(
                anchor_lang::solana_program::instruction::AccountMeta::new_readonly(
                    anchor_lang::Key::key(&self.creator),
                    true,
                ),
            );
            account_metas.push(
                anchor_lang::solana_program::instruction::AccountMeta::new_readonly(
                    anchor_lang::Key::key(&self.new_delegate),
                    false,
                ),
            );
            account_metas.push(
                anchor_lang::solana_program::instruction::AccountMeta::new_readonly(
                    anchor_lang::Key::key(&self.merkle_slab),
                    false,
                ),
            );
            account_metas.push(anchor_lang::solana_program::instruction::AccountMeta::new(
                anchor_lang::Key::key(&self.tree_authority),
                false,
            ));
            account_metas
        }
    }
    #[automatically_derived]
    impl<'info> anchor_lang::ToAccountInfos<'info> for SetTreeDelegate<'info> {
        fn to_account_infos(
            &self,
        ) -> Vec<anchor_lang::solana_program::account_info::AccountInfo<'info>> {
            let mut account_infos = ::alloc::vec::Vec::new();
            account_infos.push(anchor_lang::ToAccountInfo::to_account_info(&self.creator));
            account_infos.push(anchor_lang::ToAccountInfo::to_account_info(
                &self.new_delegate,
            ));
            account_infos.push(anchor_lang::ToAccountInfo::to_account_info(
                &self.merkle_slab,
            ));
            account_infos.push(anchor_lang::ToAccountInfo::to_account_info(
                &self.tree_authority,
            ));
            account_infos
        }
    }
}
pub fn hash_metadata(metadata: &MetadataArgs) -> Result<[u8; 32]> {
    let metadata_args_hash = keccak::hashv(&[metadata.try_to_vec()?.as_slice()]);
    Ok(keccak::hashv(&[
        &metadata_args_hash.to_bytes(),
        &metadata.seller_fee_basis_points.to_le_bytes(),
    ])
    .to_bytes())
}
pub enum InstructionName {
    Unknown,
    MintV1,
    Redeem,
    CancelRedeem,
    Transfer,
    Delegate,
    DecompressV1,
    Compress,
    Burn,
}
pub fn get_instruction_type(full_bytes: &[u8]) -> InstructionName {
    let disc: [u8; 8] = {
        let mut disc = [0; 8];
        disc.copy_from_slice(&full_bytes[..8]);
        disc
    };
    match disc {
        [145, 98, 192, 118, 184, 147, 118, 104] => InstructionName::MintV1,
        [111, 76, 232, 50, 39, 175, 48, 242] => InstructionName::CancelRedeem,
        [184, 12, 86, 149, 70, 196, 97, 225] => InstructionName::Redeem,
        [163, 52, 200, 231, 140, 3, 69, 186] => InstructionName::Transfer,
        [90, 147, 75, 178, 85, 88, 4, 137] => InstructionName::Delegate,
        [54, 85, 76, 70, 228, 250, 164, 81] => InstructionName::DecompressV1,
        [116, 110, 29, 56, 107, 219, 42, 93] => InstructionName::Burn,
        [82, 193, 176, 117, 176, 21, 115, 253] => InstructionName::Compress,
        _ => InstructionName::Unknown,
    }
}
fn assert_enough_mints_to_approve<'info>(
    authority: &Account<'info, TreeConfig>,
    to_approve: u64,
) -> Result<()> {
    if !authority.contains_mint_capacity(to_approve) {
        return Err(BubblegumError::InsufficientMintCapacity.into());
    }
    Ok(())
}
fn process_mint_v1<'info>(
    message: MetadataArgs,
    owner: Pubkey,
    delegate: Pubkey,
    metadata_auth: HashSet<Pubkey>,
    authority_bump: u8,
    authority: &mut Account<'info, TreeConfig>,
    merkle_slab: &AccountInfo<'info>,
    candy_wrapper: &Program<'info, CandyWrapper>,
    gummyroll_program: &AccountInfo<'info>,
) -> Result<()> {
    assert_metadata_is_mpl_compatible(&message)?;
    let metadata_args_hash = keccak::hashv(&[message.try_to_vec()?.as_slice()]);
    let data_hash = keccak::hashv(&[
        &metadata_args_hash.to_bytes(),
        &message.seller_fee_basis_points.to_le_bytes(),
    ]);
    let creator_data = message
        .creators
        .iter()
        .map(|c| {
            if c.verified && !metadata_auth.contains(&c.address) {
                Err(BubblegumError::CreatorDidNotVerify.into())
            } else {
                Ok([c.address.as_ref(), &[c.verified as u8], &[c.share]].concat())
            }
        })
        .collect::<Result<Vec<_>>>()?;
    let creator_hash = keccak::hashv(
        creator_data
            .iter()
            .map(|c| c.as_slice())
            .collect::<Vec<&[u8]>>()
            .as_ref(),
    );
    let asset_id = get_asset_id(&merkle_slab.key(), authority.num_minted);
    let leaf = LeafSchema::new_v0(
        asset_id,
        owner,
        delegate,
        authority.num_minted,
        data_hash.to_bytes(),
        creator_hash.to_bytes(),
    );
    let new_nft = NewNFTEvent {
        version: Version::V1,
        metadata: message,
        nonce: authority.num_minted,
    };
    {
        anchor_lang::solana_program::log::sol_log_data(&[&anchor_lang::Event::data(&new_nft)]);
    };
    wrap_event(new_nft.try_to_vec()?, &candy_wrapper)?;
    {
        anchor_lang::solana_program::log::sol_log_data(&[&anchor_lang::Event::data(
            &leaf.to_event(),
        )]);
    };
    authority.num_minted = authority.num_minted.saturating_add(1);
    append_leaf(
        &merkle_slab.key(),
        authority_bump,
        &gummyroll_program.to_account_info(),
        &authority.to_account_info(),
        &merkle_slab.to_account_info(),
        &candy_wrapper.to_account_info(),
        leaf.to_node(),
    )
}
fn process_creator_verification<'info>(
    ctx: Context<'_, '_, '_, 'info, CreatorVerification<'info>>,
    root: [u8; 32],
    data_hash: [u8; 32],
    creator_hash: [u8; 32],
    nonce: u64,
    index: u32,
    mut message: MetadataArgs,
    verify: bool,
) -> Result<()> {
    let owner = ctx.accounts.owner.to_account_info();
    let delegate = ctx.accounts.delegate.to_account_info();
    let merkle_slab = ctx.accounts.merkle_slab.to_account_info();
    let creator = ctx.accounts.creator.key();
    if message.creators.is_empty() {
        return Err(BubblegumError::NoCreatorsPresent.into());
    }
    if !message.creators.iter().any(|c| c.address == creator) {
        return Err(BubblegumError::CreatorNotFound.into());
    }
    let provided_creator_data = message
        .creators
        .iter()
        .map(|c| [c.address.as_ref(), &[c.verified as u8], &[c.share]].concat())
        .collect::<Vec<_>>();
    let calculated_creator_hash = keccak::hashv(
        provided_creator_data
            .iter()
            .map(|c| c.as_slice())
            .collect::<Vec<&[u8]>>()
            .as_ref(),
    );
    match (&creator_hash, &calculated_creator_hash.to_bytes()) {
        (left_val, right_val) => {
            if !(*left_val == *right_val) {
                let kind = ::core::panicking::AssertKind::Eq;
                ::core::panicking::assert_failed(
                    kind,
                    &*left_val,
                    &*right_val,
                    ::core::option::Option::None,
                );
            }
        }
    };
    let updated_creator_vec = message
        .creators
        .iter()
        .map(|c| {
            let verified = if c.address == creator.key() {
                verify
            } else {
                c.verified
            };
            Creator {
                address: c.address,
                verified,
                share: c.share,
            }
        })
        .collect::<Vec<Creator>>();
    message.creators = updated_creator_vec;
    let updated_creator_data = message
        .creators
        .iter()
        .map(|c| [c.address.as_ref(), &[c.verified as u8], &[c.share]].concat())
        .collect::<Vec<_>>();
    let updated_creator_hash = keccak::hashv(
        updated_creator_data
            .iter()
            .map(|c| c.as_slice())
            .collect::<Vec<&[u8]>>()
            .as_ref(),
    );
    let metadata_args_hash = keccak::hashv(&[message.try_to_vec()?.as_slice()]);
    let updated_data_hash = keccak::hashv(&[
        &metadata_args_hash.to_bytes(),
        &message.seller_fee_basis_points.to_le_bytes(),
    ]);
    let asset_id = get_asset_id(&merkle_slab.key(), nonce);
    let previous_leaf = LeafSchema::new_v0(
        asset_id,
        owner.key(),
        delegate.key(),
        nonce,
        data_hash,
        creator_hash,
    );
    let new_leaf = LeafSchema::new_v0(
        asset_id,
        owner.key(),
        delegate.key(),
        nonce,
        updated_data_hash.to_bytes(),
        updated_creator_hash.to_bytes(),
    );
    {
        anchor_lang::solana_program::log::sol_log_data(&[&anchor_lang::Event::data(
            &new_leaf.to_event(),
        )]);
    };
    replace_leaf(
        &merkle_slab.key(),
        *ctx.bumps.get("authority").unwrap(),
        &ctx.accounts.gummyroll_program.to_account_info(),
        &ctx.accounts.authority.to_account_info(),
        &ctx.accounts.merkle_slab.to_account_info(),
        &ctx.accounts.candy_wrapper.to_account_info(),
        ctx.remaining_accounts,
        root,
        previous_leaf.to_node(),
        new_leaf.to_node(),
        index,
    )
}
use self::bubblegum::*;
/// # Safety
#[no_mangle]
pub unsafe extern "C" fn entrypoint(input: *mut u8) -> u64 {
    let (program_id, accounts, instruction_data) =
        unsafe { ::solana_program::entrypoint::deserialize(input) };
    match entry(&program_id, &accounts, &instruction_data) {
        Ok(()) => ::solana_program::entrypoint::SUCCESS,
        Err(error) => error.into(),
    }
}
/// The Anchor codegen exposes a programming model where a user defines
/// a set of methods inside of a `#[program]` module in a way similar
/// to writing RPC request handlers. The macro then generates a bunch of
/// code wrapping these user defined methods into something that can be
/// executed on Solana.
///
/// These methods fall into one of three categories, each of which
/// can be considered a different "namespace" of the program.
///
/// 1) Global methods - regular methods inside of the `#[program]`.
/// 2) State methods - associated methods inside a `#[state]` struct.
/// 3) Interface methods - methods inside a strait struct's
///    implementation of an `#[interface]` trait.
///
/// Care must be taken by the codegen to prevent collisions between
/// methods in these different namespaces. For this reason, Anchor uses
/// a variant of sighash to perform method dispatch, rather than
/// something like a simple enum variant discriminator.
///
/// The execution flow of the generated code can be roughly outlined:
///
/// * Start program via the entrypoint.
/// * Strip method identifier off the first 8 bytes of the instruction
///   data and invoke the identified method. The method identifier
///   is a variant of sighash. See docs.rs for `anchor_lang` for details.
/// * If the method identifier is an IDL identifier, execute the IDL
///   instructions, which are a special set of hardcoded instructions
///   baked into every Anchor program. Then exit.
/// * Otherwise, the method identifier is for a user defined
///   instruction, i.e., one of the methods in the user defined
///   `#[program]` module. Perform method dispatch, i.e., execute the
///   big match statement mapping method identifier to method handler
///   wrapper.
/// * Run the method handler wrapper. This wraps the code the user
///   actually wrote, deserializing the accounts, constructing the
///   context, invoking the user's code, and finally running the exit
///   routine, which typically persists account changes.
///
/// The `entry` function here, defines the standard entry to a Solana
/// program, where execution begins.
pub fn entry(
    program_id: &Pubkey,
    accounts: &[AccountInfo],
    data: &[u8],
) -> anchor_lang::solana_program::entrypoint::ProgramResult {
    try_entry(program_id, accounts, data).map_err(|e| {
        e.log();
        e.into()
    })
}
fn try_entry(
    program_id: &Pubkey,
    accounts: &[AccountInfo],
    data: &[u8],
) -> anchor_lang::Result<()> {
    if *program_id != ID {
        return Err(anchor_lang::error::ErrorCode::DeclaredProgramIdMismatch.into());
    }
    if data.len() < 8 {
        return Err(anchor_lang::error::ErrorCode::InstructionMissing.into());
    }
    dispatch(program_id, accounts, data)
}
/// Module representing the program.
pub mod program {
    use super::*;
    /// Type representing the program.
    pub struct Bubblegum;
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::clone::Clone for Bubblegum {
        #[inline]
        fn clone(&self) -> Bubblegum {
            match *self {
                Bubblegum => Bubblegum,
            }
        }
    }
    impl anchor_lang::Id for Bubblegum {
        fn id() -> Pubkey {
            ID
        }
    }
}
/// Performs method dispatch.
///
/// Each method in an anchor program is uniquely defined by a namespace
/// and a rust identifier (i.e., the name given to the method). These
/// two pieces can be combined to creater a method identifier,
/// specifically, Anchor uses
///
/// Sha256("<namespace>:<rust-identifier>")[..8],
///
/// where the namespace can be one of three types. 1) "global" for a
/// regular instruction, 2) "state" for a state struct instruction
/// handler and 3) a trait namespace (used in combination with the
/// `#[interface]` attribute), which is defined by the trait name, e..
/// `MyTrait`.
///
/// With this 8 byte identifier, Anchor performs method dispatch,
/// matching the given 8 byte identifier to the associated method
/// handler, which leads to user defined code being eventually invoked.
fn dispatch(program_id: &Pubkey, accounts: &[AccountInfo], data: &[u8]) -> anchor_lang::Result<()> {
    let mut ix_data: &[u8] = data;
    let sighash: [u8; 8] = {
        let mut sighash: [u8; 8] = [0; 8];
        sighash.copy_from_slice(&ix_data[..8]);
        ix_data = &ix_data[8..];
        sighash
    };
    if true {
        if sighash == anchor_lang::idl::IDL_IX_TAG.to_le_bytes() {
            return __private::__idl::__idl_dispatch(program_id, accounts, &ix_data);
        }
    }
    match sighash {
        [165, 83, 136, 142, 89, 202, 47, 220] => {
            __private::__global::create_tree(program_id, accounts, ix_data)
        }
        [120, 51, 89, 77, 2, 133, 224, 130] => {
            __private::__global::create_default_mint_request(program_id, accounts, ix_data)
        }
        [68, 130, 170, 21, 167, 61, 63, 76] => {
            __private::__global::request_mint_authority(program_id, accounts, ix_data)
        }
        [59, 153, 108, 196, 228, 165, 169, 242] => {
            __private::__global::approve_mint_authority_request(program_id, accounts, ix_data)
        }
        [110, 107, 165, 251, 73, 53, 214, 194] => {
            __private::__global::close_mint_request(program_id, accounts, ix_data)
        }
        [253, 118, 66, 37, 190, 49, 154, 102] => {
            __private::__global::set_tree_delegate(program_id, accounts, ix_data)
        }
        [145, 98, 192, 118, 184, 147, 118, 104] => {
            __private::__global::mint_v1(program_id, accounts, ix_data)
        }
        [52, 17, 96, 132, 71, 4, 85, 194] => {
            __private::__global::verify_creator(program_id, accounts, ix_data)
        }
        [107, 178, 57, 39, 105, 115, 112, 152] => {
            __private::__global::unverify_creator(program_id, accounts, ix_data)
        }
        [163, 52, 200, 231, 140, 3, 69, 186] => {
            __private::__global::transfer(program_id, accounts, ix_data)
        }
        [90, 147, 75, 178, 85, 88, 4, 137] => {
            __private::__global::delegate(program_id, accounts, ix_data)
        }
        [116, 110, 29, 56, 107, 219, 42, 93] => {
            __private::__global::burn(program_id, accounts, ix_data)
        }
        [184, 12, 86, 149, 70, 196, 97, 225] => {
            __private::__global::redeem(program_id, accounts, ix_data)
        }
        [111, 76, 232, 50, 39, 175, 48, 242] => {
            __private::__global::cancel_redeem(program_id, accounts, ix_data)
        }
        [54, 85, 76, 70, 228, 250, 164, 81] => {
            __private::__global::decompress_v1(program_id, accounts, ix_data)
        }
        [82, 193, 176, 117, 176, 21, 115, 253] => {
            __private::__global::compress(program_id, accounts, ix_data)
        }
        _ => Err(anchor_lang::error::ErrorCode::InstructionFallbackNotFound.into()),
    }
}
/// Create a private module to not clutter the program's namespace.
/// Defines an entrypoint for each individual instruction handler
/// wrapper.
mod __private {
    use super::*;
    /// __idl mod defines handlers for injected Anchor IDL instructions.
    pub mod __idl {
        use super::*;
        #[inline(never)]
        #[cfg(not(feature = "no-idl"))]
        pub fn __idl_dispatch(
            program_id: &Pubkey,
            accounts: &[AccountInfo],
            idl_ix_data: &[u8],
        ) -> anchor_lang::Result<()> {
            let mut accounts = accounts;
            let mut data: &[u8] = idl_ix_data;
            let ix = anchor_lang::idl::IdlInstruction::deserialize(&mut data)
                .map_err(|_| anchor_lang::error::ErrorCode::InstructionDidNotDeserialize)?;
            match ix {
                anchor_lang::idl::IdlInstruction::Create { data_len } => {
                    let mut bumps = std::collections::BTreeMap::new();
                    let mut reallocs = std::collections::BTreeSet::new();
                    let mut accounts = anchor_lang::idl::IdlCreateAccounts::try_accounts(
                        program_id,
                        &mut accounts,
                        &[],
                        &mut bumps,
                        &mut reallocs,
                    )?;
                    __idl_create_account(program_id, &mut accounts, data_len)?;
                    accounts.exit(program_id)?;
                }
                anchor_lang::idl::IdlInstruction::CreateBuffer => {
                    let mut bumps = std::collections::BTreeMap::new();
                    let mut reallocs = std::collections::BTreeSet::new();
                    let mut accounts = anchor_lang::idl::IdlCreateBuffer::try_accounts(
                        program_id,
                        &mut accounts,
                        &[],
                        &mut bumps,
                        &mut reallocs,
                    )?;
                    __idl_create_buffer(program_id, &mut accounts)?;
                    accounts.exit(program_id)?;
                }
                anchor_lang::idl::IdlInstruction::Write { data } => {
                    let mut bumps = std::collections::BTreeMap::new();
                    let mut reallocs = std::collections::BTreeSet::new();
                    let mut accounts = anchor_lang::idl::IdlAccounts::try_accounts(
                        program_id,
                        &mut accounts,
                        &[],
                        &mut bumps,
                        &mut reallocs,
                    )?;
                    __idl_write(program_id, &mut accounts, data)?;
                    accounts.exit(program_id)?;
                }
                anchor_lang::idl::IdlInstruction::SetAuthority { new_authority } => {
                    let mut bumps = std::collections::BTreeMap::new();
                    let mut reallocs = std::collections::BTreeSet::new();
                    let mut accounts = anchor_lang::idl::IdlAccounts::try_accounts(
                        program_id,
                        &mut accounts,
                        &[],
                        &mut bumps,
                        &mut reallocs,
                    )?;
                    __idl_set_authority(program_id, &mut accounts, new_authority)?;
                    accounts.exit(program_id)?;
                }
                anchor_lang::idl::IdlInstruction::SetBuffer => {
                    let mut bumps = std::collections::BTreeMap::new();
                    let mut reallocs = std::collections::BTreeSet::new();
                    let mut accounts = anchor_lang::idl::IdlSetBuffer::try_accounts(
                        program_id,
                        &mut accounts,
                        &[],
                        &mut bumps,
                        &mut reallocs,
                    )?;
                    __idl_set_buffer(program_id, &mut accounts)?;
                    accounts.exit(program_id)?;
                }
            }
            Ok(())
        }
        #[inline(never)]
        pub fn __idl_create_account(
            program_id: &Pubkey,
            accounts: &mut anchor_lang::idl::IdlCreateAccounts,
            data_len: u64,
        ) -> anchor_lang::Result<()> {
            ::solana_program::log::sol_log("Instruction: IdlCreateAccount");
            if program_id != accounts.program.key {
                return Err(anchor_lang::error::ErrorCode::IdlInstructionInvalidProgram.into());
            }
            let from = accounts.from.key;
            let (base, nonce) = Pubkey::find_program_address(&[], program_id);
            let seed = anchor_lang::idl::IdlAccount::seed();
            let owner = accounts.program.key;
            let to = Pubkey::create_with_seed(&base, seed, owner).unwrap();
            let space = 8 + 32 + 4 + data_len as usize;
            let rent = Rent::get()?;
            let lamports = rent.minimum_balance(space);
            let seeds = &[&[nonce][..]];
            let ix = anchor_lang::solana_program::system_instruction::create_account_with_seed(
                from,
                &to,
                &base,
                seed,
                lamports,
                space as u64,
                owner,
            );
            anchor_lang::solana_program::program::invoke_signed(
                &ix,
                &[
                    accounts.from.clone(),
                    accounts.to.clone(),
                    accounts.base.clone(),
                    accounts.system_program.clone(),
                ],
                &[seeds],
            )?;
            let mut idl_account = {
                let mut account_data = accounts.to.try_borrow_data()?;
                let mut account_data_slice: &[u8] = &account_data;
                anchor_lang::idl::IdlAccount::try_deserialize_unchecked(&mut account_data_slice)?
            };
            idl_account.authority = *accounts.from.key;
            let mut data = accounts.to.try_borrow_mut_data()?;
            let dst: &mut [u8] = &mut data;
            let mut cursor = std::io::Cursor::new(dst);
            idl_account.try_serialize(&mut cursor)?;
            Ok(())
        }
        #[inline(never)]
        pub fn __idl_create_buffer(
            program_id: &Pubkey,
            accounts: &mut anchor_lang::idl::IdlCreateBuffer,
        ) -> anchor_lang::Result<()> {
            ::solana_program::log::sol_log("Instruction: IdlCreateBuffer");
            let mut buffer = &mut accounts.buffer;
            buffer.authority = *accounts.authority.key;
            Ok(())
        }
        #[inline(never)]
        pub fn __idl_write(
            program_id: &Pubkey,
            accounts: &mut anchor_lang::idl::IdlAccounts,
            idl_data: Vec<u8>,
        ) -> anchor_lang::Result<()> {
            ::solana_program::log::sol_log("Instruction: IdlWrite");
            let mut idl = &mut accounts.idl;
            idl.data.extend(idl_data);
            Ok(())
        }
        #[inline(never)]
        pub fn __idl_set_authority(
            program_id: &Pubkey,
            accounts: &mut anchor_lang::idl::IdlAccounts,
            new_authority: Pubkey,
        ) -> anchor_lang::Result<()> {
            ::solana_program::log::sol_log("Instruction: IdlSetAuthority");
            accounts.idl.authority = new_authority;
            Ok(())
        }
        #[inline(never)]
        pub fn __idl_set_buffer(
            program_id: &Pubkey,
            accounts: &mut anchor_lang::idl::IdlSetBuffer,
        ) -> anchor_lang::Result<()> {
            ::solana_program::log::sol_log("Instruction: IdlSetBuffer");
            accounts.idl.data = accounts.buffer.data.clone();
            Ok(())
        }
    }
    /// __state mod defines wrapped handlers for state instructions.
    pub mod __state {
        use super::*;
    }
    /// __interface mod defines wrapped handlers for `#[interface]` trait
    /// implementations.
    pub mod __interface {
        use super::*;
    }
    /// __global mod defines wrapped handlers for global instructions.
    pub mod __global {
        use super::*;
        #[inline(never)]
        pub fn create_tree(
            program_id: &Pubkey,
            accounts: &[AccountInfo],
            ix_data: &[u8],
        ) -> anchor_lang::Result<()> {
            ::solana_program::log::sol_log("Instruction: CreateTree");
            let ix = instruction::CreateTree::deserialize(&mut &ix_data[..])
                .map_err(|_| anchor_lang::error::ErrorCode::InstructionDidNotDeserialize)?;
            let instruction::CreateTree {
                max_depth,
                max_buffer_size,
            } = ix;
            let mut __bumps = std::collections::BTreeMap::new();
            let mut __reallocs = std::collections::BTreeSet::new();
            let mut remaining_accounts: &[AccountInfo] = accounts;
            let mut accounts = CreateTree::try_accounts(
                program_id,
                &mut remaining_accounts,
                ix_data,
                &mut __bumps,
                &mut __reallocs,
            )?;
            let result = bubblegum::create_tree(
                anchor_lang::context::Context::new(
                    program_id,
                    &mut accounts,
                    remaining_accounts,
                    __bumps,
                ),
                max_depth,
                max_buffer_size,
            )?;
            accounts.exit(program_id)
        }
        #[inline(never)]
        pub fn create_default_mint_request(
            program_id: &Pubkey,
            accounts: &[AccountInfo],
            ix_data: &[u8],
        ) -> anchor_lang::Result<()> {
            ::solana_program::log::sol_log("Instruction: CreateDefaultMintRequest");
            let ix = instruction::CreateDefaultMintRequest::deserialize(&mut &ix_data[..])
                .map_err(|_| anchor_lang::error::ErrorCode::InstructionDidNotDeserialize)?;
            let instruction::CreateDefaultMintRequest { mint_capacity } = ix;
            let mut __bumps = std::collections::BTreeMap::new();
            let mut __reallocs = std::collections::BTreeSet::new();
            let mut remaining_accounts: &[AccountInfo] = accounts;
            let mut accounts = SetDefaultMintRequest::try_accounts(
                program_id,
                &mut remaining_accounts,
                ix_data,
                &mut __bumps,
                &mut __reallocs,
            )?;
            let result = bubblegum::create_default_mint_request(
                anchor_lang::context::Context::new(
                    program_id,
                    &mut accounts,
                    remaining_accounts,
                    __bumps,
                ),
                mint_capacity,
            )?;
            accounts.exit(program_id)
        }
        #[inline(never)]
        pub fn request_mint_authority(
            program_id: &Pubkey,
            accounts: &[AccountInfo],
            ix_data: &[u8],
        ) -> anchor_lang::Result<()> {
            ::solana_program::log::sol_log("Instruction: RequestMintAuthority");
            let ix = instruction::RequestMintAuthority::deserialize(&mut &ix_data[..])
                .map_err(|_| anchor_lang::error::ErrorCode::InstructionDidNotDeserialize)?;
            let instruction::RequestMintAuthority { mint_capacity } = ix;
            let mut __bumps = std::collections::BTreeMap::new();
            let mut __reallocs = std::collections::BTreeSet::new();
            let mut remaining_accounts: &[AccountInfo] = accounts;
            let mut accounts = SetMintRequest::try_accounts(
                program_id,
                &mut remaining_accounts,
                ix_data,
                &mut __bumps,
                &mut __reallocs,
            )?;
            let result = bubblegum::request_mint_authority(
                anchor_lang::context::Context::new(
                    program_id,
                    &mut accounts,
                    remaining_accounts,
                    __bumps,
                ),
                mint_capacity,
            )?;
            accounts.exit(program_id)
        }
        #[inline(never)]
        pub fn approve_mint_authority_request(
            program_id: &Pubkey,
            accounts: &[AccountInfo],
            ix_data: &[u8],
        ) -> anchor_lang::Result<()> {
            ::solana_program::log::sol_log("Instruction: ApproveMintAuthorityRequest");
            let ix = instruction::ApproveMintAuthorityRequest::deserialize(&mut &ix_data[..])
                .map_err(|_| anchor_lang::error::ErrorCode::InstructionDidNotDeserialize)?;
            let instruction::ApproveMintAuthorityRequest {
                num_mints_to_approve,
            } = ix;
            let mut __bumps = std::collections::BTreeMap::new();
            let mut __reallocs = std::collections::BTreeSet::new();
            let mut remaining_accounts: &[AccountInfo] = accounts;
            let mut accounts = ApproveMintRequest::try_accounts(
                program_id,
                &mut remaining_accounts,
                ix_data,
                &mut __bumps,
                &mut __reallocs,
            )?;
            let result = bubblegum::approve_mint_authority_request(
                anchor_lang::context::Context::new(
                    program_id,
                    &mut accounts,
                    remaining_accounts,
                    __bumps,
                ),
                num_mints_to_approve,
            )?;
            accounts.exit(program_id)
        }
        #[inline(never)]
        pub fn close_mint_request(
            program_id: &Pubkey,
            accounts: &[AccountInfo],
            ix_data: &[u8],
        ) -> anchor_lang::Result<()> {
            ::solana_program::log::sol_log("Instruction: CloseMintRequest");
            let ix = instruction::CloseMintRequest::deserialize(&mut &ix_data[..])
                .map_err(|_| anchor_lang::error::ErrorCode::InstructionDidNotDeserialize)?;
            let instruction::CloseMintRequest = ix;
            let mut __bumps = std::collections::BTreeMap::new();
            let mut __reallocs = std::collections::BTreeSet::new();
            let mut remaining_accounts: &[AccountInfo] = accounts;
            let mut accounts = CloseMintRequest::try_accounts(
                program_id,
                &mut remaining_accounts,
                ix_data,
                &mut __bumps,
                &mut __reallocs,
            )?;
            let result = bubblegum::close_mint_request(anchor_lang::context::Context::new(
                program_id,
                &mut accounts,
                remaining_accounts,
                __bumps,
            ))?;
            accounts.exit(program_id)
        }
        #[inline(never)]
        pub fn set_tree_delegate(
            program_id: &Pubkey,
            accounts: &[AccountInfo],
            ix_data: &[u8],
        ) -> anchor_lang::Result<()> {
            ::solana_program::log::sol_log("Instruction: SetTreeDelegate");
            let ix = instruction::SetTreeDelegate::deserialize(&mut &ix_data[..])
                .map_err(|_| anchor_lang::error::ErrorCode::InstructionDidNotDeserialize)?;
            let instruction::SetTreeDelegate = ix;
            let mut __bumps = std::collections::BTreeMap::new();
            let mut __reallocs = std::collections::BTreeSet::new();
            let mut remaining_accounts: &[AccountInfo] = accounts;
            let mut accounts = SetTreeDelegate::try_accounts(
                program_id,
                &mut remaining_accounts,
                ix_data,
                &mut __bumps,
                &mut __reallocs,
            )?;
            let result = bubblegum::set_tree_delegate(anchor_lang::context::Context::new(
                program_id,
                &mut accounts,
                remaining_accounts,
                __bumps,
            ))?;
            accounts.exit(program_id)
        }
        #[inline(never)]
        pub fn mint_v1(
            program_id: &Pubkey,
            accounts: &[AccountInfo],
            ix_data: &[u8],
        ) -> anchor_lang::Result<()> {
            ::solana_program::log::sol_log("Instruction: MintV1");
            let ix = instruction::MintV1::deserialize(&mut &ix_data[..])
                .map_err(|_| anchor_lang::error::ErrorCode::InstructionDidNotDeserialize)?;
            let instruction::MintV1 { message } = ix;
            let mut __bumps = std::collections::BTreeMap::new();
            let mut __reallocs = std::collections::BTreeSet::new();
            let mut remaining_accounts: &[AccountInfo] = accounts;
            let mut accounts = MintV1::try_accounts(
                program_id,
                &mut remaining_accounts,
                ix_data,
                &mut __bumps,
                &mut __reallocs,
            )?;
            let result = bubblegum::mint_v1(
                anchor_lang::context::Context::new(
                    program_id,
                    &mut accounts,
                    remaining_accounts,
                    __bumps,
                ),
                message,
            )?;
            accounts.exit(program_id)
        }
        #[inline(never)]
        pub fn verify_creator(
            program_id: &Pubkey,
            accounts: &[AccountInfo],
            ix_data: &[u8],
        ) -> anchor_lang::Result<()> {
            ::solana_program::log::sol_log("Instruction: VerifyCreator");
            let ix = instruction::VerifyCreator::deserialize(&mut &ix_data[..])
                .map_err(|_| anchor_lang::error::ErrorCode::InstructionDidNotDeserialize)?;
            let instruction::VerifyCreator {
                root,
                data_hash,
                creator_hash,
                nonce,
                index,
                message,
            } = ix;
            let mut __bumps = std::collections::BTreeMap::new();
            let mut __reallocs = std::collections::BTreeSet::new();
            let mut remaining_accounts: &[AccountInfo] = accounts;
            let mut accounts = CreatorVerification::try_accounts(
                program_id,
                &mut remaining_accounts,
                ix_data,
                &mut __bumps,
                &mut __reallocs,
            )?;
            let result = bubblegum::verify_creator(
                anchor_lang::context::Context::new(
                    program_id,
                    &mut accounts,
                    remaining_accounts,
                    __bumps,
                ),
                root,
                data_hash,
                creator_hash,
                nonce,
                index,
                message,
            )?;
            accounts.exit(program_id)
        }
        #[inline(never)]
        pub fn unverify_creator(
            program_id: &Pubkey,
            accounts: &[AccountInfo],
            ix_data: &[u8],
        ) -> anchor_lang::Result<()> {
            ::solana_program::log::sol_log("Instruction: UnverifyCreator");
            let ix = instruction::UnverifyCreator::deserialize(&mut &ix_data[..])
                .map_err(|_| anchor_lang::error::ErrorCode::InstructionDidNotDeserialize)?;
            let instruction::UnverifyCreator {
                root,
                data_hash,
                creator_hash,
                nonce,
                index,
                message,
            } = ix;
            let mut __bumps = std::collections::BTreeMap::new();
            let mut __reallocs = std::collections::BTreeSet::new();
            let mut remaining_accounts: &[AccountInfo] = accounts;
            let mut accounts = CreatorVerification::try_accounts(
                program_id,
                &mut remaining_accounts,
                ix_data,
                &mut __bumps,
                &mut __reallocs,
            )?;
            let result = bubblegum::unverify_creator(
                anchor_lang::context::Context::new(
                    program_id,
                    &mut accounts,
                    remaining_accounts,
                    __bumps,
                ),
                root,
                data_hash,
                creator_hash,
                nonce,
                index,
                message,
            )?;
            accounts.exit(program_id)
        }
        #[inline(never)]
        pub fn transfer(
            program_id: &Pubkey,
            accounts: &[AccountInfo],
            ix_data: &[u8],
        ) -> anchor_lang::Result<()> {
            ::solana_program::log::sol_log("Instruction: Transfer");
            let ix = instruction::Transfer::deserialize(&mut &ix_data[..])
                .map_err(|_| anchor_lang::error::ErrorCode::InstructionDidNotDeserialize)?;
            let instruction::Transfer {
                root,
                data_hash,
                creator_hash,
                nonce,
                index,
            } = ix;
            let mut __bumps = std::collections::BTreeMap::new();
            let mut __reallocs = std::collections::BTreeSet::new();
            let mut remaining_accounts: &[AccountInfo] = accounts;
            let mut accounts = Transfer::try_accounts(
                program_id,
                &mut remaining_accounts,
                ix_data,
                &mut __bumps,
                &mut __reallocs,
            )?;
            let result = bubblegum::transfer(
                anchor_lang::context::Context::new(
                    program_id,
                    &mut accounts,
                    remaining_accounts,
                    __bumps,
                ),
                root,
                data_hash,
                creator_hash,
                nonce,
                index,
            )?;
            accounts.exit(program_id)
        }
        #[inline(never)]
        pub fn delegate(
            program_id: &Pubkey,
            accounts: &[AccountInfo],
            ix_data: &[u8],
        ) -> anchor_lang::Result<()> {
            ::solana_program::log::sol_log("Instruction: Delegate");
            let ix = instruction::Delegate::deserialize(&mut &ix_data[..])
                .map_err(|_| anchor_lang::error::ErrorCode::InstructionDidNotDeserialize)?;
            let instruction::Delegate {
                root,
                data_hash,
                creator_hash,
                nonce,
                index,
            } = ix;
            let mut __bumps = std::collections::BTreeMap::new();
            let mut __reallocs = std::collections::BTreeSet::new();
            let mut remaining_accounts: &[AccountInfo] = accounts;
            let mut accounts = Delegate::try_accounts(
                program_id,
                &mut remaining_accounts,
                ix_data,
                &mut __bumps,
                &mut __reallocs,
            )?;
            let result = bubblegum::delegate(
                anchor_lang::context::Context::new(
                    program_id,
                    &mut accounts,
                    remaining_accounts,
                    __bumps,
                ),
                root,
                data_hash,
                creator_hash,
                nonce,
                index,
            )?;
            accounts.exit(program_id)
        }
        #[inline(never)]
        pub fn burn(
            program_id: &Pubkey,
            accounts: &[AccountInfo],
            ix_data: &[u8],
        ) -> anchor_lang::Result<()> {
            ::solana_program::log::sol_log("Instruction: Burn");
            let ix = instruction::Burn::deserialize(&mut &ix_data[..])
                .map_err(|_| anchor_lang::error::ErrorCode::InstructionDidNotDeserialize)?;
            let instruction::Burn {
                root,
                data_hash,
                creator_hash,
                nonce,
                index,
            } = ix;
            let mut __bumps = std::collections::BTreeMap::new();
            let mut __reallocs = std::collections::BTreeSet::new();
            let mut remaining_accounts: &[AccountInfo] = accounts;
            let mut accounts = Burn::try_accounts(
                program_id,
                &mut remaining_accounts,
                ix_data,
                &mut __bumps,
                &mut __reallocs,
            )?;
            let result = bubblegum::burn(
                anchor_lang::context::Context::new(
                    program_id,
                    &mut accounts,
                    remaining_accounts,
                    __bumps,
                ),
                root,
                data_hash,
                creator_hash,
                nonce,
                index,
            )?;
            accounts.exit(program_id)
        }
        #[inline(never)]
        pub fn redeem(
            program_id: &Pubkey,
            accounts: &[AccountInfo],
            ix_data: &[u8],
        ) -> anchor_lang::Result<()> {
            ::solana_program::log::sol_log("Instruction: Redeem");
            let ix = instruction::Redeem::deserialize(&mut &ix_data[..])
                .map_err(|_| anchor_lang::error::ErrorCode::InstructionDidNotDeserialize)?;
            let instruction::Redeem {
                root,
                data_hash,
                creator_hash,
                nonce,
                index,
            } = ix;
            let mut __bumps = std::collections::BTreeMap::new();
            let mut __reallocs = std::collections::BTreeSet::new();
            let mut remaining_accounts: &[AccountInfo] = accounts;
            let mut accounts = Redeem::try_accounts(
                program_id,
                &mut remaining_accounts,
                ix_data,
                &mut __bumps,
                &mut __reallocs,
            )?;
            let result = bubblegum::redeem(
                anchor_lang::context::Context::new(
                    program_id,
                    &mut accounts,
                    remaining_accounts,
                    __bumps,
                ),
                root,
                data_hash,
                creator_hash,
                nonce,
                index,
            )?;
            accounts.exit(program_id)
        }
        #[inline(never)]
        pub fn cancel_redeem(
            program_id: &Pubkey,
            accounts: &[AccountInfo],
            ix_data: &[u8],
        ) -> anchor_lang::Result<()> {
            ::solana_program::log::sol_log("Instruction: CancelRedeem");
            let ix = instruction::CancelRedeem::deserialize(&mut &ix_data[..])
                .map_err(|_| anchor_lang::error::ErrorCode::InstructionDidNotDeserialize)?;
            let instruction::CancelRedeem { root } = ix;
            let mut __bumps = std::collections::BTreeMap::new();
            let mut __reallocs = std::collections::BTreeSet::new();
            let mut remaining_accounts: &[AccountInfo] = accounts;
            let mut accounts = CancelRedeem::try_accounts(
                program_id,
                &mut remaining_accounts,
                ix_data,
                &mut __bumps,
                &mut __reallocs,
            )?;
            let result = bubblegum::cancel_redeem(
                anchor_lang::context::Context::new(
                    program_id,
                    &mut accounts,
                    remaining_accounts,
                    __bumps,
                ),
                root,
            )?;
            accounts.exit(program_id)
        }
        #[inline(never)]
        pub fn decompress_v1(
            program_id: &Pubkey,
            accounts: &[AccountInfo],
            ix_data: &[u8],
        ) -> anchor_lang::Result<()> {
            ::solana_program::log::sol_log("Instruction: DecompressV1");
            let ix = instruction::DecompressV1::deserialize(&mut &ix_data[..])
                .map_err(|_| anchor_lang::error::ErrorCode::InstructionDidNotDeserialize)?;
            let instruction::DecompressV1 { metadata } = ix;
            let mut __bumps = std::collections::BTreeMap::new();
            let mut __reallocs = std::collections::BTreeSet::new();
            let mut remaining_accounts: &[AccountInfo] = accounts;
            let mut accounts = DecompressV1::try_accounts(
                program_id,
                &mut remaining_accounts,
                ix_data,
                &mut __bumps,
                &mut __reallocs,
            )?;
            let result = bubblegum::decompress_v1(
                anchor_lang::context::Context::new(
                    program_id,
                    &mut accounts,
                    remaining_accounts,
                    __bumps,
                ),
                metadata,
            )?;
            accounts.exit(program_id)
        }
        #[inline(never)]
        pub fn compress(
            program_id: &Pubkey,
            accounts: &[AccountInfo],
            ix_data: &[u8],
        ) -> anchor_lang::Result<()> {
            ::solana_program::log::sol_log("Instruction: Compress");
            let ix = instruction::Compress::deserialize(&mut &ix_data[..])
                .map_err(|_| anchor_lang::error::ErrorCode::InstructionDidNotDeserialize)?;
            let instruction::Compress = ix;
            let mut __bumps = std::collections::BTreeMap::new();
            let mut __reallocs = std::collections::BTreeSet::new();
            let mut remaining_accounts: &[AccountInfo] = accounts;
            let mut accounts = Compress::try_accounts(
                program_id,
                &mut remaining_accounts,
                ix_data,
                &mut __bumps,
                &mut __reallocs,
            )?;
            let result = bubblegum::compress(anchor_lang::context::Context::new(
                program_id,
                &mut accounts,
                remaining_accounts,
                __bumps,
            ))?;
            accounts.exit(program_id)
        }
    }
}
pub mod bubblegum {
    use super::*;
    pub fn create_tree(
        ctx: Context<CreateTree>,
        max_depth: u32,
        max_buffer_size: u32,
    ) -> Result<()> {
        let merkle_slab = ctx.accounts.merkle_slab.to_account_info();
        let seed = merkle_slab.key();
        let seeds = &[seed.as_ref(), &[*ctx.bumps.get("authority").unwrap()]];
        let authority = &mut ctx.accounts.authority;
        authority.set_inner(TreeConfig {
            creator: ctx.accounts.tree_creator.key(),
            delegate: ctx.accounts.tree_creator.key(),
            total_mint_capacity: 1 << max_depth,
            num_mints_approved: 0,
            num_minted: 0,
        });
        let authority_pda_signer = &[&seeds[..]];
        let cpi_ctx = CpiContext::new_with_signer(
            ctx.accounts.gummyroll_program.to_account_info(),
            gummyroll::cpi::accounts::Initialize {
                authority: ctx.accounts.authority.to_account_info(),
                merkle_roll: merkle_slab,
                candy_wrapper: ctx.accounts.candy_wrapper.to_account_info(),
            },
            authority_pda_signer,
        );
        gummyroll::cpi::init_empty_gummyroll(cpi_ctx, max_depth, max_buffer_size)
    }
    /// Creates a special mint request the tree_authority PDA. This allows permissionless minting without
    /// requiring a higher level CPI
    pub fn create_default_mint_request(
        ctx: Context<SetDefaultMintRequest>,
        mint_capacity: u64,
    ) -> Result<()> {
        let request = &mut ctx.accounts.mint_authority_request;
        assert_enough_mints_to_approve(&ctx.accounts.tree_authority, mint_capacity)?;
        request.init_or_set(ctx.accounts.tree_authority.key(), mint_capacity);
        Ok(())
    }
    pub fn request_mint_authority(ctx: Context<SetMintRequest>, mint_capacity: u64) -> Result<()> {
        let request = &mut ctx.accounts.mint_authority_request;
        assert_enough_mints_to_approve(&ctx.accounts.tree_authority, mint_capacity)?;
        request.init_or_set(ctx.accounts.mint_authority.key(), mint_capacity);
        Ok(())
    }
    pub fn approve_mint_authority_request(
        ctx: Context<ApproveMintRequest>,
        num_mints_to_approve: u64,
    ) -> Result<()> {
        let authority = &mut ctx.accounts.tree_authority;
        let request = &mut ctx.accounts.mint_authority_request;
        assert_enough_mints_to_approve(&authority, num_mints_to_approve)?;
        authority.approve_mint_capacity(num_mints_to_approve);
        request.approve(num_mints_to_approve)?;
        Ok(())
    }
    pub fn close_mint_request(ctx: Context<CloseMintRequest>) -> Result<()> {
        let authority = &mut ctx.accounts.tree_authority;
        let request = &ctx.accounts.mint_authority_request;
        authority.restore_mint_capacity(request.num_mints_approved);
        Ok(())
    }
    pub fn set_tree_delegate(ctx: Context<SetTreeDelegate>) -> Result<()> {
        ctx.accounts.tree_authority.delegate = ctx.accounts.new_delegate.key();
        Ok(())
    }
    pub fn mint_v1(ctx: Context<MintV1>, message: MetadataArgs) -> Result<()> {
        let owner = ctx.accounts.owner.key();
        let delegate = ctx.accounts.delegate.key();
        let mint_authority = &mut ctx.accounts.mint_authority;
        let merkle_slab = &ctx.accounts.merkle_slab;
        let mut metadata_auth = HashSet::<Pubkey>::new();
        if mint_authority.key() != ctx.accounts.authority.key() {
            if !mint_authority.is_signer {
                ::core::panicking::panic("assertion failed: mint_authority.is_signer")
            };
            metadata_auth.insert(mint_authority.key());
        }
        metadata_auth.extend(
            ctx.remaining_accounts
                .iter()
                .filter(|a| a.is_signer)
                .map(|a| a.key()),
        );
        let authority = &mut ctx.accounts.authority;
        let request = &mut ctx.accounts.mint_authority_request;
        request.decrement_approvals()?;
        process_mint_v1(
            message,
            owner,
            delegate,
            metadata_auth,
            *ctx.bumps.get("authority").unwrap(),
            authority,
            merkle_slab,
            &ctx.accounts.candy_wrapper,
            &ctx.accounts.gummyroll_program,
        )?;
        if request.num_mints_approved == 0 && request.num_mints_requested == 0 {
            let request_info = request.to_account_info();
            **mint_authority.lamports.borrow_mut() = mint_authority
                .lamports()
                .checked_add(request_info.lamports())
                .ok_or(BubblegumError::CloseMintRequestError)?;
            **request_info.lamports.borrow_mut() = 0;
        }
        Ok(())
    }
    pub fn verify_creator<'info>(
        ctx: Context<'_, '_, '_, 'info, CreatorVerification<'info>>,
        root: [u8; 32],
        data_hash: [u8; 32],
        creator_hash: [u8; 32],
        nonce: u64,
        index: u32,
        message: MetadataArgs,
    ) -> Result<()> {
        process_creator_verification(
            ctx,
            root,
            data_hash,
            creator_hash,
            nonce,
            index,
            message,
            true,
        )
    }
    pub fn unverify_creator<'info>(
        ctx: Context<'_, '_, '_, 'info, CreatorVerification<'info>>,
        root: [u8; 32],
        data_hash: [u8; 32],
        creator_hash: [u8; 32],
        nonce: u64,
        index: u32,
        message: MetadataArgs,
    ) -> Result<()> {
        process_creator_verification(
            ctx,
            root,
            data_hash,
            creator_hash,
            nonce,
            index,
            message,
            false,
        )
    }
    pub fn transfer<'info>(
        ctx: Context<'_, '_, '_, 'info, Transfer<'info>>,
        root: [u8; 32],
        data_hash: [u8; 32],
        creator_hash: [u8; 32],
        nonce: u64,
        index: u32,
    ) -> Result<()> {
        let merkle_slab = ctx.accounts.merkle_slab.to_account_info();
        let owner = ctx.accounts.owner.to_account_info();
        let delegate = ctx.accounts.delegate.to_account_info();
        if !(owner.is_signer || delegate.is_signer) {
            ::core::panicking::panic("assertion failed: owner.is_signer || delegate.is_signer")
        };
        let new_owner = ctx.accounts.new_owner.key();
        let asset_id = get_asset_id(&merkle_slab.key(), nonce);
        let previous_leaf = LeafSchema::new_v0(
            asset_id,
            owner.key(),
            delegate.key(),
            nonce,
            data_hash,
            creator_hash,
        );
        let new_leaf = LeafSchema::new_v0(
            asset_id,
            new_owner,
            new_owner,
            nonce,
            data_hash,
            creator_hash,
        );
        {
            anchor_lang::solana_program::log::sol_log_data(&[&anchor_lang::Event::data(
                &new_leaf.to_event(),
            )]);
        };
        replace_leaf(
            &merkle_slab.key(),
            *ctx.bumps.get("authority").unwrap(),
            &ctx.accounts.gummyroll_program.to_account_info(),
            &ctx.accounts.authority.to_account_info(),
            &ctx.accounts.merkle_slab.to_account_info(),
            &ctx.accounts.candy_wrapper.to_account_info(),
            ctx.remaining_accounts,
            root,
            previous_leaf.to_node(),
            new_leaf.to_node(),
            index,
        )
    }
    pub fn delegate<'info>(
        ctx: Context<'_, '_, '_, 'info, Delegate<'info>>,
        root: [u8; 32],
        data_hash: [u8; 32],
        creator_hash: [u8; 32],
        nonce: u64,
        index: u32,
    ) -> Result<()> {
        let merkle_slab = ctx.accounts.merkle_slab.to_account_info();
        let owner = ctx.accounts.owner.key();
        let previous_delegate = ctx.accounts.previous_delegate.key();
        let new_delegate = ctx.accounts.new_delegate.key();
        let asset_id = get_asset_id(&merkle_slab.key(), nonce);
        let previous_leaf = LeafSchema::new_v0(
            asset_id,
            owner,
            previous_delegate,
            nonce,
            data_hash,
            creator_hash,
        );
        let new_leaf = LeafSchema::new_v0(
            asset_id,
            owner,
            new_delegate,
            nonce,
            data_hash,
            creator_hash,
        );
        wrap_event(new_leaf.try_to_vec()?, &ctx.accounts.candy_wrapper)?;
        {
            anchor_lang::solana_program::log::sol_log_data(&[&anchor_lang::Event::data(
                &new_leaf.to_event(),
            )]);
        };
        replace_leaf(
            &merkle_slab.key(),
            *ctx.bumps.get("authority").unwrap(),
            &ctx.accounts.gummyroll_program.to_account_info(),
            &ctx.accounts.authority.to_account_info(),
            &ctx.accounts.merkle_slab.to_account_info(),
            &ctx.accounts.candy_wrapper.to_account_info(),
            ctx.remaining_accounts,
            root,
            previous_leaf.to_node(),
            new_leaf.to_node(),
            index,
        )
    }
    pub fn burn<'info>(
        ctx: Context<'_, '_, '_, 'info, Burn<'info>>,
        root: [u8; 32],
        data_hash: [u8; 32],
        creator_hash: [u8; 32],
        nonce: u64,
        index: u32,
    ) -> Result<()> {
        let owner = ctx.accounts.owner.to_account_info();
        let delegate = ctx.accounts.delegate.to_account_info();
        if !(owner.is_signer || delegate.is_signer) {
            ::core::panicking::panic("assertion failed: owner.is_signer || delegate.is_signer")
        };
        let merkle_slab = ctx.accounts.merkle_slab.to_account_info();
        let asset_id = get_asset_id(&merkle_slab.key(), nonce);
        let previous_leaf = LeafSchema::new_v0(
            asset_id,
            owner.key(),
            delegate.key(),
            nonce,
            data_hash,
            creator_hash,
        );
        {
            anchor_lang::solana_program::log::sol_log_data(&[&anchor_lang::Event::data(
                &previous_leaf.to_event(),
            )]);
        };
        let new_leaf = Node::default();
        wrap_event(new_leaf.try_to_vec()?, &ctx.accounts.candy_wrapper)?;
        replace_leaf(
            &merkle_slab.key(),
            *ctx.bumps.get("authority").unwrap(),
            &ctx.accounts.gummyroll_program.to_account_info(),
            &ctx.accounts.authority.to_account_info(),
            &ctx.accounts.merkle_slab.to_account_info(),
            &ctx.accounts.candy_wrapper.to_account_info(),
            ctx.remaining_accounts,
            root,
            previous_leaf.to_node(),
            new_leaf,
            index,
        )
    }
    pub fn redeem<'info>(
        ctx: Context<'_, '_, '_, 'info, Redeem<'info>>,
        root: [u8; 32],
        data_hash: [u8; 32],
        creator_hash: [u8; 32],
        nonce: u64,
        index: u32,
    ) -> Result<()> {
        let owner = ctx.accounts.owner.key();
        let delegate = ctx.accounts.delegate.key();
        let merkle_slab = ctx.accounts.merkle_slab.to_account_info();
        let asset_id = get_asset_id(&merkle_slab.key(), nonce);
        let previous_leaf =
            LeafSchema::new_v0(asset_id, owner, delegate, nonce, data_hash, creator_hash);
        {
            anchor_lang::solana_program::log::sol_log_data(&[&anchor_lang::Event::data(
                &previous_leaf.to_event(),
            )]);
        };
        let new_leaf = Node::default();
        wrap_event(new_leaf.try_to_vec()?, &ctx.accounts.candy_wrapper)?;
        replace_leaf(
            &merkle_slab.key(),
            *ctx.bumps.get("authority").unwrap(),
            &ctx.accounts.gummyroll_program.to_account_info(),
            &ctx.accounts.authority.to_account_info(),
            &ctx.accounts.merkle_slab.to_account_info(),
            &ctx.accounts.candy_wrapper.to_account_info(),
            ctx.remaining_accounts,
            root,
            previous_leaf.to_node(),
            new_leaf,
            index,
        )?;
        ctx.accounts
            .voucher
            .set_inner(Voucher::new(previous_leaf, index, merkle_slab.key()));
        Ok(())
    }
    pub fn cancel_redeem<'info>(
        ctx: Context<'_, '_, '_, 'info, CancelRedeem<'info>>,
        root: [u8; 32],
    ) -> Result<()> {
        let voucher = &ctx.accounts.voucher;
        match ctx.accounts.voucher.leaf_schema {
            LeafSchema::V1 { owner, .. } => assert_pubkey_equal(
                &ctx.accounts.owner.key(),
                &owner,
                Some(BubblegumError::AssetOwnerMismatch.into()),
            ),
        }?;
        let merkle_slab = ctx.accounts.merkle_slab.to_account_info();
        {
            anchor_lang::solana_program::log::sol_log_data(&[&anchor_lang::Event::data(
                &voucher.leaf_schema.to_event(),
            )]);
        };
        wrap_event(
            voucher.leaf_schema.try_to_vec()?,
            &ctx.accounts.candy_wrapper,
        )?;
        replace_leaf(
            &merkle_slab.key(),
            *ctx.bumps.get("authority").unwrap(),
            &ctx.accounts.gummyroll_program.to_account_info(),
            &ctx.accounts.authority.to_account_info(),
            &ctx.accounts.merkle_slab.to_account_info(),
            &ctx.accounts.candy_wrapper.to_account_info(),
            ctx.remaining_accounts,
            root,
            [0; 32],
            voucher.leaf_schema.to_node(),
            voucher.index,
        )
    }
    pub fn decompress_v1(ctx: Context<DecompressV1>, metadata: MetadataArgs) -> Result<()> {
        let incoming_data_hash = hash_metadata(&metadata)?;
        let event = match ctx.accounts.voucher.leaf_schema {
            LeafSchema::V1 {
                owner,
                data_hash,
                nonce,
                ..
            } => {
                if !cmp_bytes(&data_hash, &incoming_data_hash, 32) {
                    return Err(BubblegumError::HashingMismatch.into());
                }
                if !cmp_pubkeys(&owner, ctx.accounts.owner.key) {
                    return Err(BubblegumError::AssetOwnerMismatch.into());
                }
                Ok(NFTDecompressionEvent {
                    version: Version::V1,
                    tree_id: ctx.accounts.voucher.merkle_slab.key(),
                    id: get_asset_id(&ctx.accounts.voucher.merkle_slab.key(), nonce),
                    nonce: nonce,
                })
            }
            _ => Err(BubblegumError::UnsupportedSchemaVersion),
        }?;
        let voucher = &ctx.accounts.voucher;
        match metadata.token_program_version {
            TokenProgramVersion::Original => {
                if ctx.accounts.mint.data_is_empty() {
                    invoke_signed(
                        &system_instruction::create_account(
                            &ctx.accounts.owner.key(),
                            &ctx.accounts.mint.key(),
                            Rent::get()?.minimum_balance(SplMint::LEN),
                            SplMint::LEN as u64,
                            &spl_token::id(),
                        ),
                        &[
                            ctx.accounts.owner.to_account_info(),
                            ctx.accounts.mint.to_account_info(),
                            ctx.accounts.system_program.to_account_info(),
                        ],
                        &[&[
                            ASSET_PREFIX.as_bytes(),
                            voucher.merkle_slab.key().as_ref(),
                            voucher.leaf_schema.nonce().to_le_bytes().as_ref(),
                            &[*ctx.bumps.get("mint").unwrap()],
                        ]],
                    )?;
                    invoke(
                        &spl_token::instruction::initialize_mint2(
                            &spl_token::id(),
                            &ctx.accounts.mint.key(),
                            &ctx.accounts.mint_authority.key(),
                            None,
                            0,
                        )?,
                        &[
                            ctx.accounts.token_program.to_account_info(),
                            ctx.accounts.mint.to_account_info(),
                        ],
                    )?;
                }
                if ctx.accounts.token_account.data_is_empty() {
                    invoke(
                        &spl_associated_token_account::instruction::create_associated_token_account(
                            &ctx.accounts.owner.key(),
                            &ctx.accounts.owner.key(),
                            &ctx.accounts.mint.key(),
                        ),
                        &[
                            ctx.accounts.owner.to_account_info(),
                            ctx.accounts.mint.to_account_info(),
                            ctx.accounts.token_account.to_account_info(),
                            ctx.accounts.token_program.to_account_info(),
                            ctx.accounts.associated_token_program.to_account_info(),
                            ctx.accounts.system_program.to_account_info(),
                            ctx.accounts.sysvar_rent.to_account_info(),
                        ],
                    )?;
                }
                invoke_signed(
                    &spl_token::instruction::mint_to(
                        &spl_token::id(),
                        &ctx.accounts.mint.key(),
                        &ctx.accounts.token_account.key(),
                        &ctx.accounts.mint_authority.key(),
                        &[],
                        1,
                    )?,
                    &[
                        ctx.accounts.mint.to_account_info(),
                        ctx.accounts.token_account.to_account_info(),
                        ctx.accounts.mint_authority.to_account_info(),
                        ctx.accounts.token_program.to_account_info(),
                    ],
                    &[&[
                        ctx.accounts.mint.key().as_ref(),
                        &[ctx.bumps["mint_authority"]],
                    ]],
                )?;
            }
            TokenProgramVersion::Token2022 => return Err(ProgramError::InvalidArgument.into()),
        }
        let metadata_infos = <[_]>::into_vec(box [
            ctx.accounts.metadata.to_account_info(),
            ctx.accounts.mint.to_account_info(),
            ctx.accounts.mint_authority.to_account_info(),
            ctx.accounts.owner.to_account_info(),
            ctx.accounts.token_metadata_program.to_account_info(),
            ctx.accounts.token_program.to_account_info(),
            ctx.accounts.system_program.to_account_info(),
            ctx.accounts.sysvar_rent.to_account_info(),
        ]);
        let master_edition_infos = <[_]>::into_vec(box [
            ctx.accounts.master_edition.to_account_info(),
            ctx.accounts.mint.to_account_info(),
            ctx.accounts.mint_authority.to_account_info(),
            ctx.accounts.owner.to_account_info(),
            ctx.accounts.metadata.to_account_info(),
            ctx.accounts.token_metadata_program.to_account_info(),
            ctx.accounts.token_program.to_account_info(),
            ctx.accounts.system_program.to_account_info(),
            ctx.accounts.sysvar_rent.to_account_info(),
        ]);
        ::solana_program::log::sol_log("Creating metadata!");
        invoke_signed(
            &mpl_token_metadata::instruction::create_metadata_accounts_v2(
                ctx.accounts.token_metadata_program.key(),
                ctx.accounts.metadata.key(),
                ctx.accounts.mint.key(),
                ctx.accounts.mint_authority.key(),
                ctx.accounts.owner.key(),
                ctx.accounts.mint_authority.key(),
                metadata.name.clone(),
                metadata.symbol.clone(),
                metadata.uri.clone(),
                if metadata.creators.len() > 0 {
                    let mut amended_metadata_creators = metadata.creators;
                    amended_metadata_creators.push(Creator {
                        address: ctx.accounts.mint_authority.key(),
                        verified: true,
                        share: 0,
                    });
                    Some(
                        amended_metadata_creators
                            .iter()
                            .map(|c| c.adapt())
                            .collect(),
                    )
                } else {
                    None
                },
                metadata.seller_fee_basis_points,
                true,
                metadata.is_mutable,
                match metadata.collection {
                    Some(c) => Some(c.adapt()),
                    None => None,
                },
                match metadata.uses {
                    Some(u) => Some(u.adapt()),
                    None => None,
                },
            ),
            metadata_infos.as_slice(),
            &[&[
                ctx.accounts.mint.key().as_ref(),
                &[ctx.bumps["mint_authority"]],
            ]],
        )?;
        ::solana_program::log::sol_log("Creating master edition!");
        invoke_signed(
            &mpl_token_metadata::instruction::create_master_edition_v3(
                ctx.accounts.token_metadata_program.key(),
                ctx.accounts.master_edition.key(),
                ctx.accounts.mint.key(),
                ctx.accounts.mint_authority.key(),
                ctx.accounts.mint_authority.key(),
                ctx.accounts.metadata.key(),
                ctx.accounts.owner.key(),
                Some(0),
            ),
            master_edition_infos.as_slice(),
            &[&[
                ctx.accounts.mint.key().as_ref(),
                &[ctx.bumps["mint_authority"]],
            ]],
        )?;
        {
            anchor_lang::solana_program::log::sol_log_data(&[&anchor_lang::Event::data(&event)]);
        };
        Ok(())
    }
    pub fn compress(_ctx: Context<Compress>) -> Result<()> {
        Ok(())
    }
}
/// An Anchor generated module containing the program's set of
/// instructions, where each method handler in the `#[program]` mod is
/// associated with a struct defining the input arguments to the
/// method. These should be used directly, when one wants to serialize
/// Anchor instruction data, for example, when speciying
/// instructions on a client.
pub mod instruction {
    use super::*;
    /// Instruction struct definitions for `#[state]` methods.
    pub mod state {
        use super::*;
    }
    /// Instruction.
    pub struct CreateTree {
        pub max_depth: u32,
        pub max_buffer_size: u32,
    }
    impl borsh::ser::BorshSerialize for CreateTree
    where
        u32: borsh::ser::BorshSerialize,
        u32: borsh::ser::BorshSerialize,
    {
        fn serialize<W: borsh::maybestd::io::Write>(
            &self,
            writer: &mut W,
        ) -> ::core::result::Result<(), borsh::maybestd::io::Error> {
            borsh::BorshSerialize::serialize(&self.max_depth, writer)?;
            borsh::BorshSerialize::serialize(&self.max_buffer_size, writer)?;
            Ok(())
        }
    }
    impl borsh::de::BorshDeserialize for CreateTree
    where
        u32: borsh::BorshDeserialize,
        u32: borsh::BorshDeserialize,
    {
        fn deserialize(
            buf: &mut &[u8],
        ) -> ::core::result::Result<Self, borsh::maybestd::io::Error> {
            Ok(Self {
                max_depth: borsh::BorshDeserialize::deserialize(buf)?,
                max_buffer_size: borsh::BorshDeserialize::deserialize(buf)?,
            })
        }
    }
    impl anchor_lang::InstructionData for CreateTree {
        fn data(&self) -> Vec<u8> {
            let mut d = [165, 83, 136, 142, 89, 202, 47, 220].to_vec();
            d.append(&mut self.try_to_vec().expect("Should always serialize"));
            d
        }
    }
    /// Instruction.
    pub struct CreateDefaultMintRequest {
        pub mint_capacity: u64,
    }
    impl borsh::ser::BorshSerialize for CreateDefaultMintRequest
    where
        u64: borsh::ser::BorshSerialize,
    {
        fn serialize<W: borsh::maybestd::io::Write>(
            &self,
            writer: &mut W,
        ) -> ::core::result::Result<(), borsh::maybestd::io::Error> {
            borsh::BorshSerialize::serialize(&self.mint_capacity, writer)?;
            Ok(())
        }
    }
    impl borsh::de::BorshDeserialize for CreateDefaultMintRequest
    where
        u64: borsh::BorshDeserialize,
    {
        fn deserialize(
            buf: &mut &[u8],
        ) -> ::core::result::Result<Self, borsh::maybestd::io::Error> {
            Ok(Self {
                mint_capacity: borsh::BorshDeserialize::deserialize(buf)?,
            })
        }
    }
    impl anchor_lang::InstructionData for CreateDefaultMintRequest {
        fn data(&self) -> Vec<u8> {
            let mut d = [120, 51, 89, 77, 2, 133, 224, 130].to_vec();
            d.append(&mut self.try_to_vec().expect("Should always serialize"));
            d
        }
    }
    /// Instruction.
    pub struct RequestMintAuthority {
        pub mint_capacity: u64,
    }
    impl borsh::ser::BorshSerialize for RequestMintAuthority
    where
        u64: borsh::ser::BorshSerialize,
    {
        fn serialize<W: borsh::maybestd::io::Write>(
            &self,
            writer: &mut W,
        ) -> ::core::result::Result<(), borsh::maybestd::io::Error> {
            borsh::BorshSerialize::serialize(&self.mint_capacity, writer)?;
            Ok(())
        }
    }
    impl borsh::de::BorshDeserialize for RequestMintAuthority
    where
        u64: borsh::BorshDeserialize,
    {
        fn deserialize(
            buf: &mut &[u8],
        ) -> ::core::result::Result<Self, borsh::maybestd::io::Error> {
            Ok(Self {
                mint_capacity: borsh::BorshDeserialize::deserialize(buf)?,
            })
        }
    }
    impl anchor_lang::InstructionData for RequestMintAuthority {
        fn data(&self) -> Vec<u8> {
            let mut d = [68, 130, 170, 21, 167, 61, 63, 76].to_vec();
            d.append(&mut self.try_to_vec().expect("Should always serialize"));
            d
        }
    }
    /// Instruction.
    pub struct ApproveMintAuthorityRequest {
        pub num_mints_to_approve: u64,
    }
    impl borsh::ser::BorshSerialize for ApproveMintAuthorityRequest
    where
        u64: borsh::ser::BorshSerialize,
    {
        fn serialize<W: borsh::maybestd::io::Write>(
            &self,
            writer: &mut W,
        ) -> ::core::result::Result<(), borsh::maybestd::io::Error> {
            borsh::BorshSerialize::serialize(&self.num_mints_to_approve, writer)?;
            Ok(())
        }
    }
    impl borsh::de::BorshDeserialize for ApproveMintAuthorityRequest
    where
        u64: borsh::BorshDeserialize,
    {
        fn deserialize(
            buf: &mut &[u8],
        ) -> ::core::result::Result<Self, borsh::maybestd::io::Error> {
            Ok(Self {
                num_mints_to_approve: borsh::BorshDeserialize::deserialize(buf)?,
            })
        }
    }
    impl anchor_lang::InstructionData for ApproveMintAuthorityRequest {
        fn data(&self) -> Vec<u8> {
            let mut d = [59, 153, 108, 196, 228, 165, 169, 242].to_vec();
            d.append(&mut self.try_to_vec().expect("Should always serialize"));
            d
        }
    }
    /// Instruction.
    pub struct CloseMintRequest;
    impl borsh::ser::BorshSerialize for CloseMintRequest {
        fn serialize<W: borsh::maybestd::io::Write>(
            &self,
            writer: &mut W,
        ) -> ::core::result::Result<(), borsh::maybestd::io::Error> {
            Ok(())
        }
    }
    impl borsh::de::BorshDeserialize for CloseMintRequest {
        fn deserialize(
            buf: &mut &[u8],
        ) -> ::core::result::Result<Self, borsh::maybestd::io::Error> {
            Ok(Self {})
        }
    }
    impl anchor_lang::InstructionData for CloseMintRequest {
        fn data(&self) -> Vec<u8> {
            let mut d = [110, 107, 165, 251, 73, 53, 214, 194].to_vec();
            d.append(&mut self.try_to_vec().expect("Should always serialize"));
            d
        }
    }
    /// Instruction.
    pub struct SetTreeDelegate;
    impl borsh::ser::BorshSerialize for SetTreeDelegate {
        fn serialize<W: borsh::maybestd::io::Write>(
            &self,
            writer: &mut W,
        ) -> ::core::result::Result<(), borsh::maybestd::io::Error> {
            Ok(())
        }
    }
    impl borsh::de::BorshDeserialize for SetTreeDelegate {
        fn deserialize(
            buf: &mut &[u8],
        ) -> ::core::result::Result<Self, borsh::maybestd::io::Error> {
            Ok(Self {})
        }
    }
    impl anchor_lang::InstructionData for SetTreeDelegate {
        fn data(&self) -> Vec<u8> {
            let mut d = [253, 118, 66, 37, 190, 49, 154, 102].to_vec();
            d.append(&mut self.try_to_vec().expect("Should always serialize"));
            d
        }
    }
    /// Instruction.
    pub struct MintV1 {
        pub message: MetadataArgs,
    }
    impl borsh::ser::BorshSerialize for MintV1
    where
        MetadataArgs: borsh::ser::BorshSerialize,
    {
        fn serialize<W: borsh::maybestd::io::Write>(
            &self,
            writer: &mut W,
        ) -> ::core::result::Result<(), borsh::maybestd::io::Error> {
            borsh::BorshSerialize::serialize(&self.message, writer)?;
            Ok(())
        }
    }
    impl borsh::de::BorshDeserialize for MintV1
    where
        MetadataArgs: borsh::BorshDeserialize,
    {
        fn deserialize(
            buf: &mut &[u8],
        ) -> ::core::result::Result<Self, borsh::maybestd::io::Error> {
            Ok(Self {
                message: borsh::BorshDeserialize::deserialize(buf)?,
            })
        }
    }
    impl anchor_lang::InstructionData for MintV1 {
        fn data(&self) -> Vec<u8> {
            let mut d = [145, 98, 192, 118, 184, 147, 118, 104].to_vec();
            d.append(&mut self.try_to_vec().expect("Should always serialize"));
            d
        }
    }
    /// Instruction.
    pub struct VerifyCreator {
        pub root: [u8; 32],
        pub data_hash: [u8; 32],
        pub creator_hash: [u8; 32],
        pub nonce: u64,
        pub index: u32,
        pub message: MetadataArgs,
    }
    impl borsh::ser::BorshSerialize for VerifyCreator
    where
        [u8; 32]: borsh::ser::BorshSerialize,
        [u8; 32]: borsh::ser::BorshSerialize,
        [u8; 32]: borsh::ser::BorshSerialize,
        u64: borsh::ser::BorshSerialize,
        u32: borsh::ser::BorshSerialize,
        MetadataArgs: borsh::ser::BorshSerialize,
    {
        fn serialize<W: borsh::maybestd::io::Write>(
            &self,
            writer: &mut W,
        ) -> ::core::result::Result<(), borsh::maybestd::io::Error> {
            borsh::BorshSerialize::serialize(&self.root, writer)?;
            borsh::BorshSerialize::serialize(&self.data_hash, writer)?;
            borsh::BorshSerialize::serialize(&self.creator_hash, writer)?;
            borsh::BorshSerialize::serialize(&self.nonce, writer)?;
            borsh::BorshSerialize::serialize(&self.index, writer)?;
            borsh::BorshSerialize::serialize(&self.message, writer)?;
            Ok(())
        }
    }
    impl borsh::de::BorshDeserialize for VerifyCreator
    where
        [u8; 32]: borsh::BorshDeserialize,
        [u8; 32]: borsh::BorshDeserialize,
        [u8; 32]: borsh::BorshDeserialize,
        u64: borsh::BorshDeserialize,
        u32: borsh::BorshDeserialize,
        MetadataArgs: borsh::BorshDeserialize,
    {
        fn deserialize(
            buf: &mut &[u8],
        ) -> ::core::result::Result<Self, borsh::maybestd::io::Error> {
            Ok(Self {
                root: borsh::BorshDeserialize::deserialize(buf)?,
                data_hash: borsh::BorshDeserialize::deserialize(buf)?,
                creator_hash: borsh::BorshDeserialize::deserialize(buf)?,
                nonce: borsh::BorshDeserialize::deserialize(buf)?,
                index: borsh::BorshDeserialize::deserialize(buf)?,
                message: borsh::BorshDeserialize::deserialize(buf)?,
            })
        }
    }
    impl anchor_lang::InstructionData for VerifyCreator {
        fn data(&self) -> Vec<u8> {
            let mut d = [52, 17, 96, 132, 71, 4, 85, 194].to_vec();
            d.append(&mut self.try_to_vec().expect("Should always serialize"));
            d
        }
    }
    /// Instruction.
    pub struct UnverifyCreator {
        pub root: [u8; 32],
        pub data_hash: [u8; 32],
        pub creator_hash: [u8; 32],
        pub nonce: u64,
        pub index: u32,
        pub message: MetadataArgs,
    }
    impl borsh::ser::BorshSerialize for UnverifyCreator
    where
        [u8; 32]: borsh::ser::BorshSerialize,
        [u8; 32]: borsh::ser::BorshSerialize,
        [u8; 32]: borsh::ser::BorshSerialize,
        u64: borsh::ser::BorshSerialize,
        u32: borsh::ser::BorshSerialize,
        MetadataArgs: borsh::ser::BorshSerialize,
    {
        fn serialize<W: borsh::maybestd::io::Write>(
            &self,
            writer: &mut W,
        ) -> ::core::result::Result<(), borsh::maybestd::io::Error> {
            borsh::BorshSerialize::serialize(&self.root, writer)?;
            borsh::BorshSerialize::serialize(&self.data_hash, writer)?;
            borsh::BorshSerialize::serialize(&self.creator_hash, writer)?;
            borsh::BorshSerialize::serialize(&self.nonce, writer)?;
            borsh::BorshSerialize::serialize(&self.index, writer)?;
            borsh::BorshSerialize::serialize(&self.message, writer)?;
            Ok(())
        }
    }
    impl borsh::de::BorshDeserialize for UnverifyCreator
    where
        [u8; 32]: borsh::BorshDeserialize,
        [u8; 32]: borsh::BorshDeserialize,
        [u8; 32]: borsh::BorshDeserialize,
        u64: borsh::BorshDeserialize,
        u32: borsh::BorshDeserialize,
        MetadataArgs: borsh::BorshDeserialize,
    {
        fn deserialize(
            buf: &mut &[u8],
        ) -> ::core::result::Result<Self, borsh::maybestd::io::Error> {
            Ok(Self {
                root: borsh::BorshDeserialize::deserialize(buf)?,
                data_hash: borsh::BorshDeserialize::deserialize(buf)?,
                creator_hash: borsh::BorshDeserialize::deserialize(buf)?,
                nonce: borsh::BorshDeserialize::deserialize(buf)?,
                index: borsh::BorshDeserialize::deserialize(buf)?,
                message: borsh::BorshDeserialize::deserialize(buf)?,
            })
        }
    }
    impl anchor_lang::InstructionData for UnverifyCreator {
        fn data(&self) -> Vec<u8> {
            let mut d = [107, 178, 57, 39, 105, 115, 112, 152].to_vec();
            d.append(&mut self.try_to_vec().expect("Should always serialize"));
            d
        }
    }
    /// Instruction.
    pub struct Transfer {
        pub root: [u8; 32],
        pub data_hash: [u8; 32],
        pub creator_hash: [u8; 32],
        pub nonce: u64,
        pub index: u32,
    }
    impl borsh::ser::BorshSerialize for Transfer
    where
        [u8; 32]: borsh::ser::BorshSerialize,
        [u8; 32]: borsh::ser::BorshSerialize,
        [u8; 32]: borsh::ser::BorshSerialize,
        u64: borsh::ser::BorshSerialize,
        u32: borsh::ser::BorshSerialize,
    {
        fn serialize<W: borsh::maybestd::io::Write>(
            &self,
            writer: &mut W,
        ) -> ::core::result::Result<(), borsh::maybestd::io::Error> {
            borsh::BorshSerialize::serialize(&self.root, writer)?;
            borsh::BorshSerialize::serialize(&self.data_hash, writer)?;
            borsh::BorshSerialize::serialize(&self.creator_hash, writer)?;
            borsh::BorshSerialize::serialize(&self.nonce, writer)?;
            borsh::BorshSerialize::serialize(&self.index, writer)?;
            Ok(())
        }
    }
    impl borsh::de::BorshDeserialize for Transfer
    where
        [u8; 32]: borsh::BorshDeserialize,
        [u8; 32]: borsh::BorshDeserialize,
        [u8; 32]: borsh::BorshDeserialize,
        u64: borsh::BorshDeserialize,
        u32: borsh::BorshDeserialize,
    {
        fn deserialize(
            buf: &mut &[u8],
        ) -> ::core::result::Result<Self, borsh::maybestd::io::Error> {
            Ok(Self {
                root: borsh::BorshDeserialize::deserialize(buf)?,
                data_hash: borsh::BorshDeserialize::deserialize(buf)?,
                creator_hash: borsh::BorshDeserialize::deserialize(buf)?,
                nonce: borsh::BorshDeserialize::deserialize(buf)?,
                index: borsh::BorshDeserialize::deserialize(buf)?,
            })
        }
    }
    impl anchor_lang::InstructionData for Transfer {
        fn data(&self) -> Vec<u8> {
            let mut d = [163, 52, 200, 231, 140, 3, 69, 186].to_vec();
            d.append(&mut self.try_to_vec().expect("Should always serialize"));
            d
        }
    }
    /// Instruction.
    pub struct Delegate {
        pub root: [u8; 32],
        pub data_hash: [u8; 32],
        pub creator_hash: [u8; 32],
        pub nonce: u64,
        pub index: u32,
    }
    impl borsh::ser::BorshSerialize for Delegate
    where
        [u8; 32]: borsh::ser::BorshSerialize,
        [u8; 32]: borsh::ser::BorshSerialize,
        [u8; 32]: borsh::ser::BorshSerialize,
        u64: borsh::ser::BorshSerialize,
        u32: borsh::ser::BorshSerialize,
    {
        fn serialize<W: borsh::maybestd::io::Write>(
            &self,
            writer: &mut W,
        ) -> ::core::result::Result<(), borsh::maybestd::io::Error> {
            borsh::BorshSerialize::serialize(&self.root, writer)?;
            borsh::BorshSerialize::serialize(&self.data_hash, writer)?;
            borsh::BorshSerialize::serialize(&self.creator_hash, writer)?;
            borsh::BorshSerialize::serialize(&self.nonce, writer)?;
            borsh::BorshSerialize::serialize(&self.index, writer)?;
            Ok(())
        }
    }
    impl borsh::de::BorshDeserialize for Delegate
    where
        [u8; 32]: borsh::BorshDeserialize,
        [u8; 32]: borsh::BorshDeserialize,
        [u8; 32]: borsh::BorshDeserialize,
        u64: borsh::BorshDeserialize,
        u32: borsh::BorshDeserialize,
    {
        fn deserialize(
            buf: &mut &[u8],
        ) -> ::core::result::Result<Self, borsh::maybestd::io::Error> {
            Ok(Self {
                root: borsh::BorshDeserialize::deserialize(buf)?,
                data_hash: borsh::BorshDeserialize::deserialize(buf)?,
                creator_hash: borsh::BorshDeserialize::deserialize(buf)?,
                nonce: borsh::BorshDeserialize::deserialize(buf)?,
                index: borsh::BorshDeserialize::deserialize(buf)?,
            })
        }
    }
    impl anchor_lang::InstructionData for Delegate {
        fn data(&self) -> Vec<u8> {
            let mut d = [90, 147, 75, 178, 85, 88, 4, 137].to_vec();
            d.append(&mut self.try_to_vec().expect("Should always serialize"));
            d
        }
    }
    /// Instruction.
    pub struct Burn {
        pub root: [u8; 32],
        pub data_hash: [u8; 32],
        pub creator_hash: [u8; 32],
        pub nonce: u64,
        pub index: u32,
    }
    impl borsh::ser::BorshSerialize for Burn
    where
        [u8; 32]: borsh::ser::BorshSerialize,
        [u8; 32]: borsh::ser::BorshSerialize,
        [u8; 32]: borsh::ser::BorshSerialize,
        u64: borsh::ser::BorshSerialize,
        u32: borsh::ser::BorshSerialize,
    {
        fn serialize<W: borsh::maybestd::io::Write>(
            &self,
            writer: &mut W,
        ) -> ::core::result::Result<(), borsh::maybestd::io::Error> {
            borsh::BorshSerialize::serialize(&self.root, writer)?;
            borsh::BorshSerialize::serialize(&self.data_hash, writer)?;
            borsh::BorshSerialize::serialize(&self.creator_hash, writer)?;
            borsh::BorshSerialize::serialize(&self.nonce, writer)?;
            borsh::BorshSerialize::serialize(&self.index, writer)?;
            Ok(())
        }
    }
    impl borsh::de::BorshDeserialize for Burn
    where
        [u8; 32]: borsh::BorshDeserialize,
        [u8; 32]: borsh::BorshDeserialize,
        [u8; 32]: borsh::BorshDeserialize,
        u64: borsh::BorshDeserialize,
        u32: borsh::BorshDeserialize,
    {
        fn deserialize(
            buf: &mut &[u8],
        ) -> ::core::result::Result<Self, borsh::maybestd::io::Error> {
            Ok(Self {
                root: borsh::BorshDeserialize::deserialize(buf)?,
                data_hash: borsh::BorshDeserialize::deserialize(buf)?,
                creator_hash: borsh::BorshDeserialize::deserialize(buf)?,
                nonce: borsh::BorshDeserialize::deserialize(buf)?,
                index: borsh::BorshDeserialize::deserialize(buf)?,
            })
        }
    }
    impl anchor_lang::InstructionData for Burn {
        fn data(&self) -> Vec<u8> {
            let mut d = [116, 110, 29, 56, 107, 219, 42, 93].to_vec();
            d.append(&mut self.try_to_vec().expect("Should always serialize"));
            d
        }
    }
    /// Instruction.
    pub struct Redeem {
        pub root: [u8; 32],
        pub data_hash: [u8; 32],
        pub creator_hash: [u8; 32],
        pub nonce: u64,
        pub index: u32,
    }
    impl borsh::ser::BorshSerialize for Redeem
    where
        [u8; 32]: borsh::ser::BorshSerialize,
        [u8; 32]: borsh::ser::BorshSerialize,
        [u8; 32]: borsh::ser::BorshSerialize,
        u64: borsh::ser::BorshSerialize,
        u32: borsh::ser::BorshSerialize,
    {
        fn serialize<W: borsh::maybestd::io::Write>(
            &self,
            writer: &mut W,
        ) -> ::core::result::Result<(), borsh::maybestd::io::Error> {
            borsh::BorshSerialize::serialize(&self.root, writer)?;
            borsh::BorshSerialize::serialize(&self.data_hash, writer)?;
            borsh::BorshSerialize::serialize(&self.creator_hash, writer)?;
            borsh::BorshSerialize::serialize(&self.nonce, writer)?;
            borsh::BorshSerialize::serialize(&self.index, writer)?;
            Ok(())
        }
    }
    impl borsh::de::BorshDeserialize for Redeem
    where
        [u8; 32]: borsh::BorshDeserialize,
        [u8; 32]: borsh::BorshDeserialize,
        [u8; 32]: borsh::BorshDeserialize,
        u64: borsh::BorshDeserialize,
        u32: borsh::BorshDeserialize,
    {
        fn deserialize(
            buf: &mut &[u8],
        ) -> ::core::result::Result<Self, borsh::maybestd::io::Error> {
            Ok(Self {
                root: borsh::BorshDeserialize::deserialize(buf)?,
                data_hash: borsh::BorshDeserialize::deserialize(buf)?,
                creator_hash: borsh::BorshDeserialize::deserialize(buf)?,
                nonce: borsh::BorshDeserialize::deserialize(buf)?,
                index: borsh::BorshDeserialize::deserialize(buf)?,
            })
        }
    }
    impl anchor_lang::InstructionData for Redeem {
        fn data(&self) -> Vec<u8> {
            let mut d = [184, 12, 86, 149, 70, 196, 97, 225].to_vec();
            d.append(&mut self.try_to_vec().expect("Should always serialize"));
            d
        }
    }
    /// Instruction.
    pub struct CancelRedeem {
        pub root: [u8; 32],
    }
    impl borsh::ser::BorshSerialize for CancelRedeem
    where
        [u8; 32]: borsh::ser::BorshSerialize,
    {
        fn serialize<W: borsh::maybestd::io::Write>(
            &self,
            writer: &mut W,
        ) -> ::core::result::Result<(), borsh::maybestd::io::Error> {
            borsh::BorshSerialize::serialize(&self.root, writer)?;
            Ok(())
        }
    }
    impl borsh::de::BorshDeserialize for CancelRedeem
    where
        [u8; 32]: borsh::BorshDeserialize,
    {
        fn deserialize(
            buf: &mut &[u8],
        ) -> ::core::result::Result<Self, borsh::maybestd::io::Error> {
            Ok(Self {
                root: borsh::BorshDeserialize::deserialize(buf)?,
            })
        }
    }
    impl anchor_lang::InstructionData for CancelRedeem {
        fn data(&self) -> Vec<u8> {
            let mut d = [111, 76, 232, 50, 39, 175, 48, 242].to_vec();
            d.append(&mut self.try_to_vec().expect("Should always serialize"));
            d
        }
    }
    /// Instruction.
    pub struct DecompressV1 {
        pub metadata: MetadataArgs,
    }
    impl borsh::ser::BorshSerialize for DecompressV1
    where
        MetadataArgs: borsh::ser::BorshSerialize,
    {
        fn serialize<W: borsh::maybestd::io::Write>(
            &self,
            writer: &mut W,
        ) -> ::core::result::Result<(), borsh::maybestd::io::Error> {
            borsh::BorshSerialize::serialize(&self.metadata, writer)?;
            Ok(())
        }
    }
    impl borsh::de::BorshDeserialize for DecompressV1
    where
        MetadataArgs: borsh::BorshDeserialize,
    {
        fn deserialize(
            buf: &mut &[u8],
        ) -> ::core::result::Result<Self, borsh::maybestd::io::Error> {
            Ok(Self {
                metadata: borsh::BorshDeserialize::deserialize(buf)?,
            })
        }
    }
    impl anchor_lang::InstructionData for DecompressV1 {
        fn data(&self) -> Vec<u8> {
            let mut d = [54, 85, 76, 70, 228, 250, 164, 81].to_vec();
            d.append(&mut self.try_to_vec().expect("Should always serialize"));
            d
        }
    }
    /// Instruction.
    pub struct Compress;
    impl borsh::ser::BorshSerialize for Compress {
        fn serialize<W: borsh::maybestd::io::Write>(
            &self,
            writer: &mut W,
        ) -> ::core::result::Result<(), borsh::maybestd::io::Error> {
            Ok(())
        }
    }
    impl borsh::de::BorshDeserialize for Compress {
        fn deserialize(
            buf: &mut &[u8],
        ) -> ::core::result::Result<Self, borsh::maybestd::io::Error> {
            Ok(Self {})
        }
    }
    impl anchor_lang::InstructionData for Compress {
        fn data(&self) -> Vec<u8> {
            let mut d = [82, 193, 176, 117, 176, 21, 115, 253].to_vec();
            d.append(&mut self.try_to_vec().expect("Should always serialize"));
            d
        }
    }
}
/// An Anchor generated module, providing a set of structs
/// mirroring the structs deriving `Accounts`, where each field is
/// a `Pubkey`. This is useful for specifying accounts for a client.
pub mod accounts {
    pub use crate::__client_accounts_mint_v1::*;
    pub use crate::__client_accounts_create_tree::*;
    pub use crate::__client_accounts_close_mint_request::*;
    pub use crate::__client_accounts_approve_mint_request::*;
    pub use crate::__client_accounts_set_tree_delegate::*;
    pub use crate::__client_accounts_transfer::*;
    pub use crate::__client_accounts_delegate::*;
    pub use crate::__client_accounts_redeem::*;
    pub use crate::__client_accounts_decompress_v1::*;
    pub use crate::__client_accounts_burn::*;
    pub use crate::__client_accounts_creator_verification::*;
    pub use crate::__client_accounts_cancel_redeem::*;
    pub use crate::__client_accounts_compress::*;
    pub use crate::__client_accounts_set_mint_request::*;
    pub use crate::__client_accounts_set_default_mint_request::*;
}
#![feature(prelude_import)]
#[prelude_import]
use std::prelude::rust_2018::*;
#[macro_use]
extern crate std;
use {
    crate::error::BubblegumError,
    crate::state::metaplex_anchor::MplTokenMetadata,
    crate::state::{
        leaf_schema::{LeafSchema, Version},
        metaplex_adapter::{Creator, MetadataArgs, TokenProgramVersion},
        metaplex_anchor::{MasterEdition, TokenMetadata},
        request::{MintRequest, MINT_REQUEST_SIZE},
        NFTDecompressionEvent, NewNFTEvent, TreeConfig, Voucher, ASSET_PREFIX, TREE_AUTHORITY_SIZE,
        VOUCHER_PREFIX, VOUCHER_SIZE,
    },
    crate::utils::{
        append_leaf, assert_metadata_is_mpl_compatible, assert_pubkey_equal, cmp_bytes,
        cmp_pubkeys, get_asset_id, replace_leaf,
    },
    anchor_lang::{
        prelude::*,
        solana_program::{
            keccak,
            program::{invoke, invoke_signed},
            program_error::ProgramError,
            program_pack::Pack,
            system_instruction,
            account_info::AccountInfo,
        },
    },
    spl_compression::{
        Node,
        data_wrapper::{Wrapper, wrap_event},
    },
    spl_token::state::Mint as SplMint,
    std::collections::HashSet,
};
pub mod error {
    use anchor_lang::prelude::*;
    #[repr(u32)]
    pub enum BubblegumError {
        AssetOwnerMismatch,
        PublicKeyMismatch,
        HashingMismatch,
        UnsupportedSchemaVersion,
        CreatorShareTotalMustBe100,
        DuplicateCreatorAddress,
        CreatorDidNotVerify,
        CreatorNotFound,
        NoCreatorsPresent,
        CreatorsTooLong,
        MetadataNameTooLong,
        MetadataSymbolTooLong,
        MetadataUriTooLong,
        MetadataBasisPointsTooHigh,
        InsufficientMintCapacity,
        MintRequestNotApproved,
        MintRequestKeyMismatch,
        MintRequestDiscriminatorMismatch,
        CloseMintRequestError,
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::fmt::Debug for BubblegumError {
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            match (&*self,) {
                (&BubblegumError::AssetOwnerMismatch,) => {
                    ::core::fmt::Formatter::write_str(f, "AssetOwnerMismatch")
                }
                (&BubblegumError::PublicKeyMismatch,) => {
                    ::core::fmt::Formatter::write_str(f, "PublicKeyMismatch")
                }
                (&BubblegumError::HashingMismatch,) => {
                    ::core::fmt::Formatter::write_str(f, "HashingMismatch")
                }
                (&BubblegumError::UnsupportedSchemaVersion,) => {
                    ::core::fmt::Formatter::write_str(f, "UnsupportedSchemaVersion")
                }
                (&BubblegumError::CreatorShareTotalMustBe100,) => {
                    ::core::fmt::Formatter::write_str(f, "CreatorShareTotalMustBe100")
                }
                (&BubblegumError::DuplicateCreatorAddress,) => {
                    ::core::fmt::Formatter::write_str(f, "DuplicateCreatorAddress")
                }
                (&BubblegumError::CreatorDidNotVerify,) => {
                    ::core::fmt::Formatter::write_str(f, "CreatorDidNotVerify")
                }
                (&BubblegumError::CreatorNotFound,) => {
                    ::core::fmt::Formatter::write_str(f, "CreatorNotFound")
                }
                (&BubblegumError::NoCreatorsPresent,) => {
                    ::core::fmt::Formatter::write_str(f, "NoCreatorsPresent")
                }
                (&BubblegumError::CreatorsTooLong,) => {
                    ::core::fmt::Formatter::write_str(f, "CreatorsTooLong")
                }
                (&BubblegumError::MetadataNameTooLong,) => {
                    ::core::fmt::Formatter::write_str(f, "MetadataNameTooLong")
                }
                (&BubblegumError::MetadataSymbolTooLong,) => {
                    ::core::fmt::Formatter::write_str(f, "MetadataSymbolTooLong")
                }
                (&BubblegumError::MetadataUriTooLong,) => {
                    ::core::fmt::Formatter::write_str(f, "MetadataUriTooLong")
                }
                (&BubblegumError::MetadataBasisPointsTooHigh,) => {
                    ::core::fmt::Formatter::write_str(f, "MetadataBasisPointsTooHigh")
                }
                (&BubblegumError::InsufficientMintCapacity,) => {
                    ::core::fmt::Formatter::write_str(f, "InsufficientMintCapacity")
                }
                (&BubblegumError::MintRequestNotApproved,) => {
                    ::core::fmt::Formatter::write_str(f, "MintRequestNotApproved")
                }
                (&BubblegumError::MintRequestKeyMismatch,) => {
                    ::core::fmt::Formatter::write_str(f, "MintRequestKeyMismatch")
                }
                (&BubblegumError::MintRequestDiscriminatorMismatch,) => {
                    ::core::fmt::Formatter::write_str(f, "MintRequestDiscriminatorMismatch")
                }
                (&BubblegumError::CloseMintRequestError,) => {
                    ::core::fmt::Formatter::write_str(f, "CloseMintRequestError")
                }
            }
        }
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::clone::Clone for BubblegumError {
        #[inline]
        fn clone(&self) -> BubblegumError {
            {
                *self
            }
        }
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::marker::Copy for BubblegumError {}
    impl BubblegumError {
        /// Gets the name of this [#enum_name].
        pub fn name(&self) -> String {
            match self {
                BubblegumError::AssetOwnerMismatch => "AssetOwnerMismatch".to_string(),
                BubblegumError::PublicKeyMismatch => "PublicKeyMismatch".to_string(),
                BubblegumError::HashingMismatch => "HashingMismatch".to_string(),
                BubblegumError::UnsupportedSchemaVersion => "UnsupportedSchemaVersion".to_string(),
                BubblegumError::CreatorShareTotalMustBe100 => {
                    "CreatorShareTotalMustBe100".to_string()
                }
                BubblegumError::DuplicateCreatorAddress => "DuplicateCreatorAddress".to_string(),
                BubblegumError::CreatorDidNotVerify => "CreatorDidNotVerify".to_string(),
                BubblegumError::CreatorNotFound => "CreatorNotFound".to_string(),
                BubblegumError::NoCreatorsPresent => "NoCreatorsPresent".to_string(),
                BubblegumError::CreatorsTooLong => "CreatorsTooLong".to_string(),
                BubblegumError::MetadataNameTooLong => "MetadataNameTooLong".to_string(),
                BubblegumError::MetadataSymbolTooLong => "MetadataSymbolTooLong".to_string(),
                BubblegumError::MetadataUriTooLong => "MetadataUriTooLong".to_string(),
                BubblegumError::MetadataBasisPointsTooHigh => {
                    "MetadataBasisPointsTooHigh".to_string()
                }
                BubblegumError::InsufficientMintCapacity => "InsufficientMintCapacity".to_string(),
                BubblegumError::MintRequestNotApproved => "MintRequestNotApproved".to_string(),
                BubblegumError::MintRequestKeyMismatch => "MintRequestKeyMismatch".to_string(),
                BubblegumError::MintRequestDiscriminatorMismatch => {
                    "MintRequestDiscriminatorMismatch".to_string()
                }
                BubblegumError::CloseMintRequestError => "CloseMintRequestError".to_string(),
            }
        }
    }
    impl From<BubblegumError> for u32 {
        fn from(e: BubblegumError) -> u32 {
            e as u32 + anchor_lang::error::ERROR_CODE_OFFSET
        }
    }
    impl From<BubblegumError> for anchor_lang::error::Error {
        fn from(error_code: BubblegumError) -> anchor_lang::error::Error {
            anchor_lang::error::Error::from(anchor_lang::error::AnchorError {
                error_name: error_code.name(),
                error_code_number: error_code.into(),
                error_msg: error_code.to_string(),
                error_origin: None,
                compared_values: None,
            })
        }
    }
    impl std::fmt::Display for BubblegumError {
        fn fmt(
            &self,
            fmt: &mut std::fmt::Formatter<'_>,
        ) -> std::result::Result<(), std::fmt::Error> {
            match self {
                BubblegumError::AssetOwnerMismatch => {
                    let result = fmt.write_fmt(::core::fmt::Arguments::new_v1(
                        &["Asset Owner Does not match"],
                        &[],
                    ));
                    result
                }
                BubblegumError::PublicKeyMismatch => {
                    let result =
                        fmt.write_fmt(::core::fmt::Arguments::new_v1(&["PublicKeyMismatch"], &[]));
                    result
                }
                BubblegumError::HashingMismatch => {
                    let result = fmt.write_fmt(::core::fmt::Arguments::new_v1(
                        &["Hashing Mismatch Within Leaf Schema"],
                        &[],
                    ));
                    result
                }
                BubblegumError::UnsupportedSchemaVersion => {
                    let result = fmt.write_fmt(::core::fmt::Arguments::new_v1(
                        &["Unsupported Schema Version"],
                        &[],
                    ));
                    result
                }
                BubblegumError::CreatorShareTotalMustBe100 => {
                    let result = fmt.write_fmt(::core::fmt::Arguments::new_v1(
                        &["Creator shares must sum to 100"],
                        &[],
                    ));
                    result
                }
                BubblegumError::DuplicateCreatorAddress => {
                    let result = fmt.write_fmt(::core::fmt::Arguments::new_v1(
                        &["No duplicate creator addresses in metadata"],
                        &[],
                    ));
                    result
                }
                BubblegumError::CreatorDidNotVerify => {
                    let result = fmt.write_fmt(::core::fmt::Arguments::new_v1(
                        &["Creator did not verify the metadata"],
                        &[],
                    ));
                    result
                }
                BubblegumError::CreatorNotFound => {
                    let result = fmt.write_fmt(::core::fmt::Arguments::new_v1(
                        &["Creator not found in creator Vec"],
                        &[],
                    ));
                    result
                }
                BubblegumError::NoCreatorsPresent => {
                    let result = fmt.write_fmt(::core::fmt::Arguments::new_v1(
                        &["No creators in creator Vec"],
                        &[],
                    ));
                    result
                }
                BubblegumError::CreatorsTooLong => {
                    let result = fmt.write_fmt(::core::fmt::Arguments::new_v1(
                        &["Creators list too long"],
                        &[],
                    ));
                    result
                }
                BubblegumError::MetadataNameTooLong => {
                    let result = fmt.write_fmt(::core::fmt::Arguments::new_v1(
                        &["Name in metadata is too long"],
                        &[],
                    ));
                    result
                }
                BubblegumError::MetadataSymbolTooLong => {
                    let result = fmt.write_fmt(::core::fmt::Arguments::new_v1(
                        &["Symbol in metadata is too long"],
                        &[],
                    ));
                    result
                }
                BubblegumError::MetadataUriTooLong => {
                    let result = fmt.write_fmt(::core::fmt::Arguments::new_v1(
                        &["Uri in metadata is too long"],
                        &[],
                    ));
                    result
                }
                BubblegumError::MetadataBasisPointsTooHigh => {
                    let result = fmt.write_fmt(::core::fmt::Arguments::new_v1(
                        &["Basis points in metadata cannot exceed 10000"],
                        &[],
                    ));
                    result
                }
                BubblegumError::InsufficientMintCapacity => {
                    let result = fmt.write_fmt(::core::fmt::Arguments::new_v1(
                        &["Not enough unapproved mints left"],
                        &[],
                    ));
                    result
                }
                BubblegumError::MintRequestNotApproved => {
                    let result = fmt.write_fmt(::core::fmt::Arguments::new_v1(
                        &["Mint request not approved"],
                        &[],
                    ));
                    result
                }
                BubblegumError::MintRequestKeyMismatch => {
                    let result = fmt.write_fmt(::core::fmt::Arguments::new_v1(
                        &["Mint authority key does not match request"],
                        &[],
                    ));
                    result
                }
                BubblegumError::MintRequestDiscriminatorMismatch => {
                    let result = fmt.write_fmt(::core::fmt::Arguments::new_v1(
                        &["Mint request data has incorrect disciminator"],
                        &[],
                    ));
                    result
                }
                BubblegumError::CloseMintRequestError => {
                    let result = fmt.write_fmt(::core::fmt::Arguments::new_v1(
                        &["Something went wrong closing mint request"],
                        &[],
                    ));
                    result
                }
            }
        }
    }
}
pub mod state {
    pub mod leaf_schema {
        use anchor_lang::{prelude::*, solana_program::keccak};
        use gummyroll::Node;
        pub struct LeafSchemaEvent {
            pub version: Version,
            pub schema: LeafSchema,
            pub leaf_hash: [u8; 32],
        }
        impl borsh::ser::BorshSerialize for LeafSchemaEvent
        where
            Version: borsh::ser::BorshSerialize,
            LeafSchema: borsh::ser::BorshSerialize,
            [u8; 32]: borsh::ser::BorshSerialize,
        {
            fn serialize<W: borsh::maybestd::io::Write>(
                &self,
                writer: &mut W,
            ) -> ::core::result::Result<(), borsh::maybestd::io::Error> {
                borsh::BorshSerialize::serialize(&self.version, writer)?;
                borsh::BorshSerialize::serialize(&self.schema, writer)?;
                borsh::BorshSerialize::serialize(&self.leaf_hash, writer)?;
                Ok(())
            }
        }
        impl borsh::de::BorshDeserialize for LeafSchemaEvent
        where
            Version: borsh::BorshDeserialize,
            LeafSchema: borsh::BorshDeserialize,
            [u8; 32]: borsh::BorshDeserialize,
        {
            fn deserialize(
                buf: &mut &[u8],
            ) -> ::core::result::Result<Self, borsh::maybestd::io::Error> {
                Ok(Self {
                    version: borsh::BorshDeserialize::deserialize(buf)?,
                    schema: borsh::BorshDeserialize::deserialize(buf)?,
                    leaf_hash: borsh::BorshDeserialize::deserialize(buf)?,
                })
            }
        }
        impl anchor_lang::Event for LeafSchemaEvent {
            fn data(&self) -> Vec<u8> {
                let mut d = [56, 139, 154, 164, 204, 170, 78, 204].to_vec();
                d.append(&mut self.try_to_vec().unwrap());
                d
            }
        }
        impl anchor_lang::Discriminator for LeafSchemaEvent {
            fn discriminator() -> [u8; 8] {
                [56, 139, 154, 164, 204, 170, 78, 204]
            }
        }
        pub enum Version {
            V1,
        }
        impl borsh::de::BorshDeserialize for Version {
            fn deserialize(
                buf: &mut &[u8],
            ) -> core::result::Result<Self, borsh::maybestd::io::Error> {
                let variant_idx: u8 = borsh::BorshDeserialize::deserialize(buf)?;
                let return_value = match variant_idx {
                    0u8 => Version::V1,
                    _ => {
                        let msg = {
                            let res = ::alloc::fmt::format(::core::fmt::Arguments::new_v1(
                                &["Unexpected variant index: "],
                                &[::core::fmt::ArgumentV1::new_debug(&variant_idx)],
                            ));
                            res
                        };
                        return Err(borsh::maybestd::io::Error::new(
                            borsh::maybestd::io::ErrorKind::InvalidInput,
                            msg,
                        ));
                    }
                };
                Ok(return_value)
            }
        }
        impl borsh::ser::BorshSerialize for Version {
            fn serialize<W: borsh::maybestd::io::Write>(
                &self,
                writer: &mut W,
            ) -> core::result::Result<(), borsh::maybestd::io::Error> {
                let variant_idx: u8 = match self {
                    Version::V1 => 0u8,
                };
                writer.write_all(&variant_idx.to_le_bytes())?;
                match self {
                    Version::V1 => {}
                }
                Ok(())
            }
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::core::clone::Clone for Version {
            #[inline]
            fn clone(&self) -> Version {
                {
                    *self
                }
            }
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::core::marker::Copy for Version {}
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::core::fmt::Debug for Version {
            fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                match (&*self,) {
                    (&Version::V1,) => ::core::fmt::Formatter::write_str(f, "V1"),
                }
            }
        }
        impl Default for Version {
            fn default() -> Self {
                Version::V1
            }
        }
        impl Version {
            pub fn to_bytes(&self) -> u8 {
                match self {
                    Version::V1 => 1,
                }
            }
        }
        pub enum LeafSchema {
            V1 {
                id: Pubkey,
                owner: Pubkey,
                delegate: Pubkey,
                nonce: u64,
                data_hash: [u8; 32],
                creator_hash: [u8; 32],
            },
        }
        impl borsh::de::BorshDeserialize for LeafSchema
        where
            Pubkey: borsh::BorshDeserialize,
            Pubkey: borsh::BorshDeserialize,
            Pubkey: borsh::BorshDeserialize,
            u64: borsh::BorshDeserialize,
            [u8; 32]: borsh::BorshDeserialize,
            [u8; 32]: borsh::BorshDeserialize,
        {
            fn deserialize(
                buf: &mut &[u8],
            ) -> core::result::Result<Self, borsh::maybestd::io::Error> {
                let variant_idx: u8 = borsh::BorshDeserialize::deserialize(buf)?;
                let return_value = match variant_idx {
                    0u8 => LeafSchema::V1 {
                        id: borsh::BorshDeserialize::deserialize(buf)?,
                        owner: borsh::BorshDeserialize::deserialize(buf)?,
                        delegate: borsh::BorshDeserialize::deserialize(buf)?,
                        nonce: borsh::BorshDeserialize::deserialize(buf)?,
                        data_hash: borsh::BorshDeserialize::deserialize(buf)?,
                        creator_hash: borsh::BorshDeserialize::deserialize(buf)?,
                    },
                    _ => {
                        let msg = {
                            let res = ::alloc::fmt::format(::core::fmt::Arguments::new_v1(
                                &["Unexpected variant index: "],
                                &[::core::fmt::ArgumentV1::new_debug(&variant_idx)],
                            ));
                            res
                        };
                        return Err(borsh::maybestd::io::Error::new(
                            borsh::maybestd::io::ErrorKind::InvalidInput,
                            msg,
                        ));
                    }
                };
                Ok(return_value)
            }
        }
        impl borsh::ser::BorshSerialize for LeafSchema
        where
            Pubkey: borsh::ser::BorshSerialize,
            Pubkey: borsh::ser::BorshSerialize,
            Pubkey: borsh::ser::BorshSerialize,
            u64: borsh::ser::BorshSerialize,
            [u8; 32]: borsh::ser::BorshSerialize,
            [u8; 32]: borsh::ser::BorshSerialize,
        {
            fn serialize<W: borsh::maybestd::io::Write>(
                &self,
                writer: &mut W,
            ) -> core::result::Result<(), borsh::maybestd::io::Error> {
                let variant_idx: u8 = match self {
                    LeafSchema::V1 { .. } => 0u8,
                };
                writer.write_all(&variant_idx.to_le_bytes())?;
                match self {
                    LeafSchema::V1 {
                        id,
                        owner,
                        delegate,
                        nonce,
                        data_hash,
                        creator_hash,
                    } => {
                        borsh::BorshSerialize::serialize(id, writer)?;
                        borsh::BorshSerialize::serialize(owner, writer)?;
                        borsh::BorshSerialize::serialize(delegate, writer)?;
                        borsh::BorshSerialize::serialize(nonce, writer)?;
                        borsh::BorshSerialize::serialize(data_hash, writer)?;
                        borsh::BorshSerialize::serialize(creator_hash, writer)?;
                    }
                }
                Ok(())
            }
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::core::clone::Clone for LeafSchema {
            #[inline]
            fn clone(&self) -> LeafSchema {
                {
                    let _: ::core::clone::AssertParamIsClone<Pubkey>;
                    let _: ::core::clone::AssertParamIsClone<Pubkey>;
                    let _: ::core::clone::AssertParamIsClone<Pubkey>;
                    let _: ::core::clone::AssertParamIsClone<u64>;
                    let _: ::core::clone::AssertParamIsClone<[u8; 32]>;
                    let _: ::core::clone::AssertParamIsClone<[u8; 32]>;
                    *self
                }
            }
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::core::marker::Copy for LeafSchema {}
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::core::fmt::Debug for LeafSchema {
            fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                match (&*self,) {
                    (&LeafSchema::V1 {
                        id: ref __self_0,
                        owner: ref __self_1,
                        delegate: ref __self_2,
                        nonce: ref __self_3,
                        data_hash: ref __self_4,
                        creator_hash: ref __self_5,
                    },) => {
                        let debug_trait_builder =
                            &mut ::core::fmt::Formatter::debug_struct(f, "V1");
                        let _ = ::core::fmt::DebugStruct::field(
                            debug_trait_builder,
                            "id",
                            &&(*__self_0),
                        );
                        let _ = ::core::fmt::DebugStruct::field(
                            debug_trait_builder,
                            "owner",
                            &&(*__self_1),
                        );
                        let _ = ::core::fmt::DebugStruct::field(
                            debug_trait_builder,
                            "delegate",
                            &&(*__self_2),
                        );
                        let _ = ::core::fmt::DebugStruct::field(
                            debug_trait_builder,
                            "nonce",
                            &&(*__self_3),
                        );
                        let _ = ::core::fmt::DebugStruct::field(
                            debug_trait_builder,
                            "data_hash",
                            &&(*__self_4),
                        );
                        let _ = ::core::fmt::DebugStruct::field(
                            debug_trait_builder,
                            "creator_hash",
                            &&(*__self_5),
                        );
                        ::core::fmt::DebugStruct::finish(debug_trait_builder)
                    }
                }
            }
        }
        impl Default for LeafSchema {
            fn default() -> Self {
                Self::V1 {
                    id: Default::default(),
                    owner: Default::default(),
                    delegate: Default::default(),
                    nonce: 0,
                    data_hash: [0; 32],
                    creator_hash: [0; 32],
                }
            }
        }
        impl LeafSchema {
            pub fn new_v0(
                id: Pubkey,
                owner: Pubkey,
                delegate: Pubkey,
                nonce: u64,
                data_hash: [u8; 32],
                creator_hash: [u8; 32],
            ) -> Self {
                Self::V1 {
                    id,
                    owner,
                    delegate,
                    nonce,
                    data_hash,
                    creator_hash,
                }
            }
            pub fn version(&self) -> Version {
                match self {
                    LeafSchema::V1 { .. } => Version::V1,
                }
            }
            pub fn id(&self) -> Pubkey {
                match self {
                    LeafSchema::V1 { id, .. } => *id,
                }
            }
            pub fn nonce(&self) -> u64 {
                match self {
                    LeafSchema::V1 { nonce, .. } => *nonce,
                }
            }
            pub fn data_hash(&self) -> [u8; 32] {
                match self {
                    LeafSchema::V1 { data_hash, .. } => *data_hash,
                }
            }
            pub fn to_event(&self) -> LeafSchemaEvent {
                LeafSchemaEvent {
                    version: self.version(),
                    schema: *self,
                    leaf_hash: self.to_node(),
                }
            }
            pub fn to_node(&self) -> Node {
                let hashed_leaf = match self {
                    LeafSchema::V1 {
                        id,
                        owner,
                        delegate,
                        nonce,
                        data_hash,
                        creator_hash,
                    } => keccak::hashv(&[
                        &[self.version().to_bytes()],
                        id.as_ref(),
                        owner.as_ref(),
                        delegate.as_ref(),
                        nonce.to_le_bytes().as_ref(),
                        data_hash.as_ref(),
                        creator_hash.as_ref(),
                    ])
                    .to_bytes(),
                };
                hashed_leaf
            }
        }
    }
    pub mod metaplex_adapter {
        use anchor_lang::prelude::*;
        pub enum TokenProgramVersion {
            Original,
            Token2022,
        }
        impl borsh::ser::BorshSerialize for TokenProgramVersion {
            fn serialize<W: borsh::maybestd::io::Write>(
                &self,
                writer: &mut W,
            ) -> core::result::Result<(), borsh::maybestd::io::Error> {
                let variant_idx: u8 = match self {
                    TokenProgramVersion::Original => 0u8,
                    TokenProgramVersion::Token2022 => 1u8,
                };
                writer.write_all(&variant_idx.to_le_bytes())?;
                match self {
                    TokenProgramVersion::Original => {}
                    TokenProgramVersion::Token2022 => {}
                }
                Ok(())
            }
        }
        impl borsh::de::BorshDeserialize for TokenProgramVersion {
            fn deserialize(
                buf: &mut &[u8],
            ) -> core::result::Result<Self, borsh::maybestd::io::Error> {
                let variant_idx: u8 = borsh::BorshDeserialize::deserialize(buf)?;
                let return_value = match variant_idx {
                    0u8 => TokenProgramVersion::Original,
                    1u8 => TokenProgramVersion::Token2022,
                    _ => {
                        let msg = {
                            let res = ::alloc::fmt::format(::core::fmt::Arguments::new_v1(
                                &["Unexpected variant index: "],
                                &[::core::fmt::ArgumentV1::new_debug(&variant_idx)],
                            ));
                            res
                        };
                        return Err(borsh::maybestd::io::Error::new(
                            borsh::maybestd::io::ErrorKind::InvalidInput,
                            msg,
                        ));
                    }
                };
                Ok(return_value)
            }
        }
        impl ::core::marker::StructuralPartialEq for TokenProgramVersion {}
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::core::cmp::PartialEq for TokenProgramVersion {
            #[inline]
            fn eq(&self, other: &TokenProgramVersion) -> bool {
                {
                    let __self_vi = ::core::intrinsics::discriminant_value(&*self);
                    let __arg_1_vi = ::core::intrinsics::discriminant_value(&*other);
                    if true && __self_vi == __arg_1_vi {
                        match (&*self, &*other) {
                            _ => true,
                        }
                    } else {
                        false
                    }
                }
            }
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::core::marker::Copy for TokenProgramVersion {}
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::core::clone::Clone for TokenProgramVersion {
            #[inline]
            fn clone(&self) -> TokenProgramVersion {
                {
                    *self
                }
            }
        }
        pub struct Creator {
            pub address: Pubkey,
            pub verified: bool,
            pub share: u8,
        }
        impl borsh::ser::BorshSerialize for Creator
        where
            Pubkey: borsh::ser::BorshSerialize,
            bool: borsh::ser::BorshSerialize,
            u8: borsh::ser::BorshSerialize,
        {
            fn serialize<W: borsh::maybestd::io::Write>(
                &self,
                writer: &mut W,
            ) -> ::core::result::Result<(), borsh::maybestd::io::Error> {
                borsh::BorshSerialize::serialize(&self.address, writer)?;
                borsh::BorshSerialize::serialize(&self.verified, writer)?;
                borsh::BorshSerialize::serialize(&self.share, writer)?;
                Ok(())
            }
        }
        impl borsh::de::BorshDeserialize for Creator
        where
            Pubkey: borsh::BorshDeserialize,
            bool: borsh::BorshDeserialize,
            u8: borsh::BorshDeserialize,
        {
            fn deserialize(
                buf: &mut &[u8],
            ) -> ::core::result::Result<Self, borsh::maybestd::io::Error> {
                Ok(Self {
                    address: borsh::BorshDeserialize::deserialize(buf)?,
                    verified: borsh::BorshDeserialize::deserialize(buf)?,
                    share: borsh::BorshDeserialize::deserialize(buf)?,
                })
            }
        }
        impl ::core::marker::StructuralPartialEq for Creator {}
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::core::cmp::PartialEq for Creator {
            #[inline]
            fn eq(&self, other: &Creator) -> bool {
                match *other {
                    Creator {
                        address: ref __self_1_0,
                        verified: ref __self_1_1,
                        share: ref __self_1_2,
                    } => match *self {
                        Creator {
                            address: ref __self_0_0,
                            verified: ref __self_0_1,
                            share: ref __self_0_2,
                        } => {
                            (*__self_0_0) == (*__self_1_0)
                                && (*__self_0_1) == (*__self_1_1)
                                && (*__self_0_2) == (*__self_1_2)
                        }
                    },
                }
            }
            #[inline]
            fn ne(&self, other: &Creator) -> bool {
                match *other {
                    Creator {
                        address: ref __self_1_0,
                        verified: ref __self_1_1,
                        share: ref __self_1_2,
                    } => match *self {
                        Creator {
                            address: ref __self_0_0,
                            verified: ref __self_0_1,
                            share: ref __self_0_2,
                        } => {
                            (*__self_0_0) != (*__self_1_0)
                                || (*__self_0_1) != (*__self_1_1)
                                || (*__self_0_2) != (*__self_1_2)
                        }
                    },
                }
            }
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::core::marker::Copy for Creator {}
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::core::clone::Clone for Creator {
            #[inline]
            fn clone(&self) -> Creator {
                {
                    let _: ::core::clone::AssertParamIsClone<Pubkey>;
                    let _: ::core::clone::AssertParamIsClone<bool>;
                    let _: ::core::clone::AssertParamIsClone<u8>;
                    *self
                }
            }
        }
        impl Creator {
            pub fn adapt(&self) -> mpl_token_metadata::state::Creator {
                mpl_token_metadata::state::Creator {
                    address: self.address,
                    verified: self.verified,
                    share: self.share,
                }
            }
        }
        pub enum TokenStandard {
            NonFungible,
            FungibleAsset,
            Fungible,
            NonFungibleEdition,
        }
        impl borsh::ser::BorshSerialize for TokenStandard {
            fn serialize<W: borsh::maybestd::io::Write>(
                &self,
                writer: &mut W,
            ) -> core::result::Result<(), borsh::maybestd::io::Error> {
                let variant_idx: u8 = match self {
                    TokenStandard::NonFungible => 0u8,
                    TokenStandard::FungibleAsset => 1u8,
                    TokenStandard::Fungible => 2u8,
                    TokenStandard::NonFungibleEdition => 3u8,
                };
                writer.write_all(&variant_idx.to_le_bytes())?;
                match self {
                    TokenStandard::NonFungible => {}
                    TokenStandard::FungibleAsset => {}
                    TokenStandard::Fungible => {}
                    TokenStandard::NonFungibleEdition => {}
                }
                Ok(())
            }
        }
        impl borsh::de::BorshDeserialize for TokenStandard {
            fn deserialize(
                buf: &mut &[u8],
            ) -> core::result::Result<Self, borsh::maybestd::io::Error> {
                let variant_idx: u8 = borsh::BorshDeserialize::deserialize(buf)?;
                let return_value = match variant_idx {
                    0u8 => TokenStandard::NonFungible,
                    1u8 => TokenStandard::FungibleAsset,
                    2u8 => TokenStandard::Fungible,
                    3u8 => TokenStandard::NonFungibleEdition,
                    _ => {
                        let msg = {
                            let res = ::alloc::fmt::format(::core::fmt::Arguments::new_v1(
                                &["Unexpected variant index: "],
                                &[::core::fmt::ArgumentV1::new_debug(&variant_idx)],
                            ));
                            res
                        };
                        return Err(borsh::maybestd::io::Error::new(
                            borsh::maybestd::io::ErrorKind::InvalidInput,
                            msg,
                        ));
                    }
                };
                Ok(return_value)
            }
        }
        impl ::core::marker::StructuralPartialEq for TokenStandard {}
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::core::cmp::PartialEq for TokenStandard {
            #[inline]
            fn eq(&self, other: &TokenStandard) -> bool {
                {
                    let __self_vi = ::core::intrinsics::discriminant_value(&*self);
                    let __arg_1_vi = ::core::intrinsics::discriminant_value(&*other);
                    if true && __self_vi == __arg_1_vi {
                        match (&*self, &*other) {
                            _ => true,
                        }
                    } else {
                        false
                    }
                }
            }
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::core::fmt::Debug for TokenStandard {
            fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                match (&*self,) {
                    (&TokenStandard::NonFungible,) => {
                        ::core::fmt::Formatter::write_str(f, "NonFungible")
                    }
                    (&TokenStandard::FungibleAsset,) => {
                        ::core::fmt::Formatter::write_str(f, "FungibleAsset")
                    }
                    (&TokenStandard::Fungible,) => ::core::fmt::Formatter::write_str(f, "Fungible"),
                    (&TokenStandard::NonFungibleEdition,) => {
                        ::core::fmt::Formatter::write_str(f, "NonFungibleEdition")
                    }
                }
            }
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::core::clone::Clone for TokenStandard {
            #[inline]
            fn clone(&self) -> TokenStandard {
                match (&*self,) {
                    (&TokenStandard::NonFungible,) => TokenStandard::NonFungible,
                    (&TokenStandard::FungibleAsset,) => TokenStandard::FungibleAsset,
                    (&TokenStandard::Fungible,) => TokenStandard::Fungible,
                    (&TokenStandard::NonFungibleEdition,) => TokenStandard::NonFungibleEdition,
                }
            }
        }
        pub enum UseMethod {
            Burn,
            Multiple,
            Single,
        }
        impl borsh::ser::BorshSerialize for UseMethod {
            fn serialize<W: borsh::maybestd::io::Write>(
                &self,
                writer: &mut W,
            ) -> core::result::Result<(), borsh::maybestd::io::Error> {
                let variant_idx: u8 = match self {
                    UseMethod::Burn => 0u8,
                    UseMethod::Multiple => 1u8,
                    UseMethod::Single => 2u8,
                };
                writer.write_all(&variant_idx.to_le_bytes())?;
                match self {
                    UseMethod::Burn => {}
                    UseMethod::Multiple => {}
                    UseMethod::Single => {}
                }
                Ok(())
            }
        }
        impl borsh::de::BorshDeserialize for UseMethod {
            fn deserialize(
                buf: &mut &[u8],
            ) -> core::result::Result<Self, borsh::maybestd::io::Error> {
                let variant_idx: u8 = borsh::BorshDeserialize::deserialize(buf)?;
                let return_value = match variant_idx {
                    0u8 => UseMethod::Burn,
                    1u8 => UseMethod::Multiple,
                    2u8 => UseMethod::Single,
                    _ => {
                        let msg = {
                            let res = ::alloc::fmt::format(::core::fmt::Arguments::new_v1(
                                &["Unexpected variant index: "],
                                &[::core::fmt::ArgumentV1::new_debug(&variant_idx)],
                            ));
                            res
                        };
                        return Err(borsh::maybestd::io::Error::new(
                            borsh::maybestd::io::ErrorKind::InvalidInput,
                            msg,
                        ));
                    }
                };
                Ok(return_value)
            }
        }
        impl ::core::marker::StructuralPartialEq for UseMethod {}
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::core::cmp::PartialEq for UseMethod {
            #[inline]
            fn eq(&self, other: &UseMethod) -> bool {
                {
                    let __self_vi = ::core::intrinsics::discriminant_value(&*self);
                    let __arg_1_vi = ::core::intrinsics::discriminant_value(&*other);
                    if true && __self_vi == __arg_1_vi {
                        match (&*self, &*other) {
                            _ => true,
                        }
                    } else {
                        false
                    }
                }
            }
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::core::fmt::Debug for UseMethod {
            fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                match (&*self,) {
                    (&UseMethod::Burn,) => ::core::fmt::Formatter::write_str(f, "Burn"),
                    (&UseMethod::Multiple,) => ::core::fmt::Formatter::write_str(f, "Multiple"),
                    (&UseMethod::Single,) => ::core::fmt::Formatter::write_str(f, "Single"),
                }
            }
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::core::clone::Clone for UseMethod {
            #[inline]
            fn clone(&self) -> UseMethod {
                match (&*self,) {
                    (&UseMethod::Burn,) => UseMethod::Burn,
                    (&UseMethod::Multiple,) => UseMethod::Multiple,
                    (&UseMethod::Single,) => UseMethod::Single,
                }
            }
        }
        pub struct Uses {
            pub use_method: UseMethod,
            pub remaining: u64,
            pub total: u64,
        }
        impl borsh::ser::BorshSerialize for Uses
        where
            UseMethod: borsh::ser::BorshSerialize,
            u64: borsh::ser::BorshSerialize,
            u64: borsh::ser::BorshSerialize,
        {
            fn serialize<W: borsh::maybestd::io::Write>(
                &self,
                writer: &mut W,
            ) -> ::core::result::Result<(), borsh::maybestd::io::Error> {
                borsh::BorshSerialize::serialize(&self.use_method, writer)?;
                borsh::BorshSerialize::serialize(&self.remaining, writer)?;
                borsh::BorshSerialize::serialize(&self.total, writer)?;
                Ok(())
            }
        }
        impl borsh::de::BorshDeserialize for Uses
        where
            UseMethod: borsh::BorshDeserialize,
            u64: borsh::BorshDeserialize,
            u64: borsh::BorshDeserialize,
        {
            fn deserialize(
                buf: &mut &[u8],
            ) -> ::core::result::Result<Self, borsh::maybestd::io::Error> {
                Ok(Self {
                    use_method: borsh::BorshDeserialize::deserialize(buf)?,
                    remaining: borsh::BorshDeserialize::deserialize(buf)?,
                    total: borsh::BorshDeserialize::deserialize(buf)?,
                })
            }
        }
        impl ::core::marker::StructuralPartialEq for Uses {}
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::core::cmp::PartialEq for Uses {
            #[inline]
            fn eq(&self, other: &Uses) -> bool {
                match *other {
                    Uses {
                        use_method: ref __self_1_0,
                        remaining: ref __self_1_1,
                        total: ref __self_1_2,
                    } => match *self {
                        Uses {
                            use_method: ref __self_0_0,
                            remaining: ref __self_0_1,
                            total: ref __self_0_2,
                        } => {
                            (*__self_0_0) == (*__self_1_0)
                                && (*__self_0_1) == (*__self_1_1)
                                && (*__self_0_2) == (*__self_1_2)
                        }
                    },
                }
            }
            #[inline]
            fn ne(&self, other: &Uses) -> bool {
                match *other {
                    Uses {
                        use_method: ref __self_1_0,
                        remaining: ref __self_1_1,
                        total: ref __self_1_2,
                    } => match *self {
                        Uses {
                            use_method: ref __self_0_0,
                            remaining: ref __self_0_1,
                            total: ref __self_0_2,
                        } => {
                            (*__self_0_0) != (*__self_1_0)
                                || (*__self_0_1) != (*__self_1_1)
                                || (*__self_0_2) != (*__self_1_2)
                        }
                    },
                }
            }
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::core::fmt::Debug for Uses {
            fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                match *self {
                    Uses {
                        use_method: ref __self_0_0,
                        remaining: ref __self_0_1,
                        total: ref __self_0_2,
                    } => {
                        let debug_trait_builder =
                            &mut ::core::fmt::Formatter::debug_struct(f, "Uses");
                        let _ = ::core::fmt::DebugStruct::field(
                            debug_trait_builder,
                            "use_method",
                            &&(*__self_0_0),
                        );
                        let _ = ::core::fmt::DebugStruct::field(
                            debug_trait_builder,
                            "remaining",
                            &&(*__self_0_1),
                        );
                        let _ = ::core::fmt::DebugStruct::field(
                            debug_trait_builder,
                            "total",
                            &&(*__self_0_2),
                        );
                        ::core::fmt::DebugStruct::finish(debug_trait_builder)
                    }
                }
            }
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::core::clone::Clone for Uses {
            #[inline]
            fn clone(&self) -> Uses {
                match *self {
                    Uses {
                        use_method: ref __self_0_0,
                        remaining: ref __self_0_1,
                        total: ref __self_0_2,
                    } => Uses {
                        use_method: ::core::clone::Clone::clone(&(*__self_0_0)),
                        remaining: ::core::clone::Clone::clone(&(*__self_0_1)),
                        total: ::core::clone::Clone::clone(&(*__self_0_2)),
                    },
                }
            }
        }
        impl Uses {
            pub fn adapt(&self) -> mpl_token_metadata::state::Uses {
                mpl_token_metadata::state::Uses {
                    use_method: match self.use_method {
                        UseMethod::Burn => mpl_token_metadata::state::UseMethod::Burn,
                        UseMethod::Multiple => mpl_token_metadata::state::UseMethod::Multiple,
                        UseMethod::Single => mpl_token_metadata::state::UseMethod::Single,
                    },
                    remaining: self.remaining,
                    total: self.total,
                }
            }
        }
        #[repr(C)]
        pub struct Collection {
            pub verified: bool,
            pub key: Pubkey,
        }
        impl borsh::ser::BorshSerialize for Collection
        where
            bool: borsh::ser::BorshSerialize,
            Pubkey: borsh::ser::BorshSerialize,
        {
            fn serialize<W: borsh::maybestd::io::Write>(
                &self,
                writer: &mut W,
            ) -> ::core::result::Result<(), borsh::maybestd::io::Error> {
                borsh::BorshSerialize::serialize(&self.verified, writer)?;
                borsh::BorshSerialize::serialize(&self.key, writer)?;
                Ok(())
            }
        }
        impl borsh::de::BorshDeserialize for Collection
        where
            bool: borsh::BorshDeserialize,
            Pubkey: borsh::BorshDeserialize,
        {
            fn deserialize(
                buf: &mut &[u8],
            ) -> ::core::result::Result<Self, borsh::maybestd::io::Error> {
                Ok(Self {
                    verified: borsh::BorshDeserialize::deserialize(buf)?,
                    key: borsh::BorshDeserialize::deserialize(buf)?,
                })
            }
        }
        impl ::core::marker::StructuralPartialEq for Collection {}
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::core::cmp::PartialEq for Collection {
            #[inline]
            fn eq(&self, other: &Collection) -> bool {
                match *other {
                    Collection {
                        verified: ref __self_1_0,
                        key: ref __self_1_1,
                    } => match *self {
                        Collection {
                            verified: ref __self_0_0,
                            key: ref __self_0_1,
                        } => (*__self_0_0) == (*__self_1_0) && (*__self_0_1) == (*__self_1_1),
                    },
                }
            }
            #[inline]
            fn ne(&self, other: &Collection) -> bool {
                match *other {
                    Collection {
                        verified: ref __self_1_0,
                        key: ref __self_1_1,
                    } => match *self {
                        Collection {
                            verified: ref __self_0_0,
                            key: ref __self_0_1,
                        } => (*__self_0_0) != (*__self_1_0) || (*__self_0_1) != (*__self_1_1),
                    },
                }
            }
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::core::fmt::Debug for Collection {
            fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                match *self {
                    Collection {
                        verified: ref __self_0_0,
                        key: ref __self_0_1,
                    } => {
                        let debug_trait_builder =
                            &mut ::core::fmt::Formatter::debug_struct(f, "Collection");
                        let _ = ::core::fmt::DebugStruct::field(
                            debug_trait_builder,
                            "verified",
                            &&(*__self_0_0),
                        );
                        let _ = ::core::fmt::DebugStruct::field(
                            debug_trait_builder,
                            "key",
                            &&(*__self_0_1),
                        );
                        ::core::fmt::DebugStruct::finish(debug_trait_builder)
                    }
                }
            }
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::core::clone::Clone for Collection {
            #[inline]
            fn clone(&self) -> Collection {
                match *self {
                    Collection {
                        verified: ref __self_0_0,
                        key: ref __self_0_1,
                    } => Collection {
                        verified: ::core::clone::Clone::clone(&(*__self_0_0)),
                        key: ::core::clone::Clone::clone(&(*__self_0_1)),
                    },
                }
            }
        }
        impl Collection {
            pub fn adapt(&self) -> mpl_token_metadata::state::Collection {
                mpl_token_metadata::state::Collection {
                    verified: self.verified,
                    key: self.key,
                }
            }
        }
        pub struct MetadataArgs {
            /// The name of the asset
            pub name: String,
            /// The symbol for the asset
            pub symbol: String,
            /// URI pointing to JSON representing the asset
            pub uri: String,
            /// Royalty basis points that goes to creators in secondary sales (0-10000)
            pub seller_fee_basis_points: u16,
            pub primary_sale_happened: bool,
            pub is_mutable: bool,
            /// nonce for easy calculation of editions, if present
            pub edition_nonce: Option<u8>,
            /// Since we cannot easily change Metadata, we add the new DataV2 fields here at the end.
            pub token_standard: Option<TokenStandard>,
            /// Collection
            pub collection: Option<Collection>,
            /// Uses
            pub uses: Option<Uses>,
            pub token_program_version: TokenProgramVersion,
            pub creators: Vec<Creator>,
        }
        impl borsh::ser::BorshSerialize for MetadataArgs
        where
            String: borsh::ser::BorshSerialize,
            String: borsh::ser::BorshSerialize,
            String: borsh::ser::BorshSerialize,
            u16: borsh::ser::BorshSerialize,
            bool: borsh::ser::BorshSerialize,
            bool: borsh::ser::BorshSerialize,
            Option<u8>: borsh::ser::BorshSerialize,
            Option<TokenStandard>: borsh::ser::BorshSerialize,
            Option<Collection>: borsh::ser::BorshSerialize,
            Option<Uses>: borsh::ser::BorshSerialize,
            TokenProgramVersion: borsh::ser::BorshSerialize,
            Vec<Creator>: borsh::ser::BorshSerialize,
        {
            fn serialize<W: borsh::maybestd::io::Write>(
                &self,
                writer: &mut W,
            ) -> ::core::result::Result<(), borsh::maybestd::io::Error> {
                borsh::BorshSerialize::serialize(&self.name, writer)?;
                borsh::BorshSerialize::serialize(&self.symbol, writer)?;
                borsh::BorshSerialize::serialize(&self.uri, writer)?;
                borsh::BorshSerialize::serialize(&self.seller_fee_basis_points, writer)?;
                borsh::BorshSerialize::serialize(&self.primary_sale_happened, writer)?;
                borsh::BorshSerialize::serialize(&self.is_mutable, writer)?;
                borsh::BorshSerialize::serialize(&self.edition_nonce, writer)?;
                borsh::BorshSerialize::serialize(&self.token_standard, writer)?;
                borsh::BorshSerialize::serialize(&self.collection, writer)?;
                borsh::BorshSerialize::serialize(&self.uses, writer)?;
                borsh::BorshSerialize::serialize(&self.token_program_version, writer)?;
                borsh::BorshSerialize::serialize(&self.creators, writer)?;
                Ok(())
            }
        }
        impl borsh::de::BorshDeserialize for MetadataArgs
        where
            String: borsh::BorshDeserialize,
            String: borsh::BorshDeserialize,
            String: borsh::BorshDeserialize,
            u16: borsh::BorshDeserialize,
            bool: borsh::BorshDeserialize,
            bool: borsh::BorshDeserialize,
            Option<u8>: borsh::BorshDeserialize,
            Option<TokenStandard>: borsh::BorshDeserialize,
            Option<Collection>: borsh::BorshDeserialize,
            Option<Uses>: borsh::BorshDeserialize,
            TokenProgramVersion: borsh::BorshDeserialize,
            Vec<Creator>: borsh::BorshDeserialize,
        {
            fn deserialize(
                buf: &mut &[u8],
            ) -> ::core::result::Result<Self, borsh::maybestd::io::Error> {
                Ok(Self {
                    name: borsh::BorshDeserialize::deserialize(buf)?,
                    symbol: borsh::BorshDeserialize::deserialize(buf)?,
                    uri: borsh::BorshDeserialize::deserialize(buf)?,
                    seller_fee_basis_points: borsh::BorshDeserialize::deserialize(buf)?,
                    primary_sale_happened: borsh::BorshDeserialize::deserialize(buf)?,
                    is_mutable: borsh::BorshDeserialize::deserialize(buf)?,
                    edition_nonce: borsh::BorshDeserialize::deserialize(buf)?,
                    token_standard: borsh::BorshDeserialize::deserialize(buf)?,
                    collection: borsh::BorshDeserialize::deserialize(buf)?,
                    uses: borsh::BorshDeserialize::deserialize(buf)?,
                    token_program_version: borsh::BorshDeserialize::deserialize(buf)?,
                    creators: borsh::BorshDeserialize::deserialize(buf)?,
                })
            }
        }
        impl ::core::marker::StructuralPartialEq for MetadataArgs {}
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::core::cmp::PartialEq for MetadataArgs {
            #[inline]
            fn eq(&self, other: &MetadataArgs) -> bool {
                match *other {
                    MetadataArgs {
                        name: ref __self_1_0,
                        symbol: ref __self_1_1,
                        uri: ref __self_1_2,
                        seller_fee_basis_points: ref __self_1_3,
                        primary_sale_happened: ref __self_1_4,
                        is_mutable: ref __self_1_5,
                        edition_nonce: ref __self_1_6,
                        token_standard: ref __self_1_7,
                        collection: ref __self_1_8,
                        uses: ref __self_1_9,
                        token_program_version: ref __self_1_10,
                        creators: ref __self_1_11,
                    } => match *self {
                        MetadataArgs {
                            name: ref __self_0_0,
                            symbol: ref __self_0_1,
                            uri: ref __self_0_2,
                            seller_fee_basis_points: ref __self_0_3,
                            primary_sale_happened: ref __self_0_4,
                            is_mutable: ref __self_0_5,
                            edition_nonce: ref __self_0_6,
                            token_standard: ref __self_0_7,
                            collection: ref __self_0_8,
                            uses: ref __self_0_9,
                            token_program_version: ref __self_0_10,
                            creators: ref __self_0_11,
                        } => {
                            (*__self_0_0) == (*__self_1_0)
                                && (*__self_0_1) == (*__self_1_1)
                                && (*__self_0_2) == (*__self_1_2)
                                && (*__self_0_3) == (*__self_1_3)
                                && (*__self_0_4) == (*__self_1_4)
                                && (*__self_0_5) == (*__self_1_5)
                                && (*__self_0_6) == (*__self_1_6)
                                && (*__self_0_7) == (*__self_1_7)
                                && (*__self_0_8) == (*__self_1_8)
                                && (*__self_0_9) == (*__self_1_9)
                                && (*__self_0_10) == (*__self_1_10)
                                && (*__self_0_11) == (*__self_1_11)
                        }
                    },
                }
            }
            #[inline]
            fn ne(&self, other: &MetadataArgs) -> bool {
                match *other {
                    MetadataArgs {
                        name: ref __self_1_0,
                        symbol: ref __self_1_1,
                        uri: ref __self_1_2,
                        seller_fee_basis_points: ref __self_1_3,
                        primary_sale_happened: ref __self_1_4,
                        is_mutable: ref __self_1_5,
                        edition_nonce: ref __self_1_6,
                        token_standard: ref __self_1_7,
                        collection: ref __self_1_8,
                        uses: ref __self_1_9,
                        token_program_version: ref __self_1_10,
                        creators: ref __self_1_11,
                    } => match *self {
                        MetadataArgs {
                            name: ref __self_0_0,
                            symbol: ref __self_0_1,
                            uri: ref __self_0_2,
                            seller_fee_basis_points: ref __self_0_3,
                            primary_sale_happened: ref __self_0_4,
                            is_mutable: ref __self_0_5,
                            edition_nonce: ref __self_0_6,
                            token_standard: ref __self_0_7,
                            collection: ref __self_0_8,
                            uses: ref __self_0_9,
                            token_program_version: ref __self_0_10,
                            creators: ref __self_0_11,
                        } => {
                            (*__self_0_0) != (*__self_1_0)
                                || (*__self_0_1) != (*__self_1_1)
                                || (*__self_0_2) != (*__self_1_2)
                                || (*__self_0_3) != (*__self_1_3)
                                || (*__self_0_4) != (*__self_1_4)
                                || (*__self_0_5) != (*__self_1_5)
                                || (*__self_0_6) != (*__self_1_6)
                                || (*__self_0_7) != (*__self_1_7)
                                || (*__self_0_8) != (*__self_1_8)
                                || (*__self_0_9) != (*__self_1_9)
                                || (*__self_0_10) != (*__self_1_10)
                                || (*__self_0_11) != (*__self_1_11)
                        }
                    },
                }
            }
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::core::clone::Clone for MetadataArgs {
            #[inline]
            fn clone(&self) -> MetadataArgs {
                match *self {
                    MetadataArgs {
                        name: ref __self_0_0,
                        symbol: ref __self_0_1,
                        uri: ref __self_0_2,
                        seller_fee_basis_points: ref __self_0_3,
                        primary_sale_happened: ref __self_0_4,
                        is_mutable: ref __self_0_5,
                        edition_nonce: ref __self_0_6,
                        token_standard: ref __self_0_7,
                        collection: ref __self_0_8,
                        uses: ref __self_0_9,
                        token_program_version: ref __self_0_10,
                        creators: ref __self_0_11,
                    } => MetadataArgs {
                        name: ::core::clone::Clone::clone(&(*__self_0_0)),
                        symbol: ::core::clone::Clone::clone(&(*__self_0_1)),
                        uri: ::core::clone::Clone::clone(&(*__self_0_2)),
                        seller_fee_basis_points: ::core::clone::Clone::clone(&(*__self_0_3)),
                        primary_sale_happened: ::core::clone::Clone::clone(&(*__self_0_4)),
                        is_mutable: ::core::clone::Clone::clone(&(*__self_0_5)),
                        edition_nonce: ::core::clone::Clone::clone(&(*__self_0_6)),
                        token_standard: ::core::clone::Clone::clone(&(*__self_0_7)),
                        collection: ::core::clone::Clone::clone(&(*__self_0_8)),
                        uses: ::core::clone::Clone::clone(&(*__self_0_9)),
                        token_program_version: ::core::clone::Clone::clone(&(*__self_0_10)),
                        creators: ::core::clone::Clone::clone(&(*__self_0_11)),
                    },
                }
            }
        }
    }
    pub mod metaplex_anchor {
        use anchor_lang::prelude::*;
        use anchor_lang::solana_program::pubkey::Pubkey;
        use mpl_token_metadata::{
            state::{MAX_MASTER_EDITION_LEN, MAX_METADATA_LEN},
            utils::try_from_slice_checked,
        };
        use std::ops::Deref;
        pub struct MasterEdition(mpl_token_metadata::state::MasterEditionV2);
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::core::clone::Clone for MasterEdition {
            #[inline]
            fn clone(&self) -> MasterEdition {
                match *self {
                    MasterEdition(ref __self_0_0) => {
                        MasterEdition(::core::clone::Clone::clone(&(*__self_0_0)))
                    }
                }
            }
        }
        impl borsh::de::BorshDeserialize for MasterEdition {
            fn deserialize(
                buf: &mut &[u8],
            ) -> ::core::result::Result<Self, borsh::maybestd::io::Error> {
                Ok(Self(borsh::BorshDeserialize::deserialize(buf)?))
            }
        }
        impl borsh::ser::BorshSerialize for MasterEdition {
            fn serialize<W: borsh::maybestd::io::Write>(
                &self,
                writer: &mut W,
            ) -> ::core::result::Result<(), borsh::maybestd::io::Error> {
                borsh::BorshSerialize::serialize(&self.0, writer)?;
                Ok(())
            }
        }
        impl anchor_lang::AccountDeserialize for MasterEdition {
            fn try_deserialize_unchecked(buf: &mut &[u8]) -> Result<Self> {
                try_from_slice_checked(
                    buf,
                    mpl_token_metadata::state::Key::MasterEditionV2,
                    MAX_MASTER_EDITION_LEN,
                )
                .map_err(Into::into)
            }
        }
        impl anchor_lang::AccountSerialize for MasterEdition {}
        impl anchor_lang::Owner for MasterEdition {
            fn owner() -> Pubkey {
                mpl_token_metadata::id()
            }
        }
        impl Deref for MasterEdition {
            type Target = mpl_token_metadata::state::MasterEditionV2;
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        pub struct TokenMetadata(mpl_token_metadata::state::Metadata);
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::core::clone::Clone for TokenMetadata {
            #[inline]
            fn clone(&self) -> TokenMetadata {
                match *self {
                    TokenMetadata(ref __self_0_0) => {
                        TokenMetadata(::core::clone::Clone::clone(&(*__self_0_0)))
                    }
                }
            }
        }
        impl borsh::de::BorshDeserialize for TokenMetadata {
            fn deserialize(
                buf: &mut &[u8],
            ) -> ::core::result::Result<Self, borsh::maybestd::io::Error> {
                Ok(Self(borsh::BorshDeserialize::deserialize(buf)?))
            }
        }
        impl borsh::ser::BorshSerialize for TokenMetadata {
            fn serialize<W: borsh::maybestd::io::Write>(
                &self,
                writer: &mut W,
            ) -> ::core::result::Result<(), borsh::maybestd::io::Error> {
                borsh::BorshSerialize::serialize(&self.0, writer)?;
                Ok(())
            }
        }
        impl anchor_lang::AccountDeserialize for TokenMetadata {
            fn try_deserialize_unchecked(buf: &mut &[u8]) -> Result<Self> {
                try_from_slice_checked(
                    buf,
                    mpl_token_metadata::state::Key::MetadataV1,
                    MAX_METADATA_LEN,
                )
                .map_err(Into::into)
            }
        }
        impl anchor_lang::AccountSerialize for TokenMetadata {}
        impl anchor_lang::Owner for TokenMetadata {
            fn owner() -> Pubkey {
                mpl_token_metadata::id()
            }
        }
        impl Deref for TokenMetadata {
            type Target = mpl_token_metadata::state::Metadata;
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        pub struct MplTokenMetadata;
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::core::clone::Clone for MplTokenMetadata {
            #[inline]
            fn clone(&self) -> MplTokenMetadata {
                match *self {
                    MplTokenMetadata => MplTokenMetadata,
                }
            }
        }
        impl anchor_lang::Id for MplTokenMetadata {
            fn id() -> Pubkey {
                mpl_token_metadata::id()
            }
        }
    }
    pub mod request {
        use crate::error::BubblegumError;
        use anchor_lang::prelude::*;
        pub const MINT_REQUEST_SIZE: usize = 48 + 8;
        pub struct MintRequest {
            pub mint_authority: Pubkey,
            pub num_mints_requested: u64,
            pub num_mints_approved: u64,
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::core::marker::Copy for MintRequest {}
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::core::fmt::Debug for MintRequest {
            fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                match *self {
                    MintRequest {
                        mint_authority: ref __self_0_0,
                        num_mints_requested: ref __self_0_1,
                        num_mints_approved: ref __self_0_2,
                    } => {
                        let debug_trait_builder =
                            &mut ::core::fmt::Formatter::debug_struct(f, "MintRequest");
                        let _ = ::core::fmt::DebugStruct::field(
                            debug_trait_builder,
                            "mint_authority",
                            &&(*__self_0_0),
                        );
                        let _ = ::core::fmt::DebugStruct::field(
                            debug_trait_builder,
                            "num_mints_requested",
                            &&(*__self_0_1),
                        );
                        let _ = ::core::fmt::DebugStruct::field(
                            debug_trait_builder,
                            "num_mints_approved",
                            &&(*__self_0_2),
                        );
                        ::core::fmt::DebugStruct::finish(debug_trait_builder)
                    }
                }
            }
        }
        impl borsh::ser::BorshSerialize for MintRequest
        where
            Pubkey: borsh::ser::BorshSerialize,
            u64: borsh::ser::BorshSerialize,
            u64: borsh::ser::BorshSerialize,
        {
            fn serialize<W: borsh::maybestd::io::Write>(
                &self,
                writer: &mut W,
            ) -> ::core::result::Result<(), borsh::maybestd::io::Error> {
                borsh::BorshSerialize::serialize(&self.mint_authority, writer)?;
                borsh::BorshSerialize::serialize(&self.num_mints_requested, writer)?;
                borsh::BorshSerialize::serialize(&self.num_mints_approved, writer)?;
                Ok(())
            }
        }
        impl borsh::de::BorshDeserialize for MintRequest
        where
            Pubkey: borsh::BorshDeserialize,
            u64: borsh::BorshDeserialize,
            u64: borsh::BorshDeserialize,
        {
            fn deserialize(
                buf: &mut &[u8],
            ) -> ::core::result::Result<Self, borsh::maybestd::io::Error> {
                Ok(Self {
                    mint_authority: borsh::BorshDeserialize::deserialize(buf)?,
                    num_mints_requested: borsh::BorshDeserialize::deserialize(buf)?,
                    num_mints_approved: borsh::BorshDeserialize::deserialize(buf)?,
                })
            }
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::core::clone::Clone for MintRequest {
            #[inline]
            fn clone(&self) -> MintRequest {
                match *self {
                    MintRequest {
                        mint_authority: ref __self_0_0,
                        num_mints_requested: ref __self_0_1,
                        num_mints_approved: ref __self_0_2,
                    } => MintRequest {
                        mint_authority: ::core::clone::Clone::clone(&(*__self_0_0)),
                        num_mints_requested: ::core::clone::Clone::clone(&(*__self_0_1)),
                        num_mints_approved: ::core::clone::Clone::clone(&(*__self_0_2)),
                    },
                }
            }
        }
        #[automatically_derived]
        impl anchor_lang::AccountSerialize for MintRequest {
            fn try_serialize<W: std::io::Write>(&self, writer: &mut W) -> anchor_lang::Result<()> {
                if writer
                    .write_all(&[60, 88, 16, 213, 180, 138, 14, 225])
                    .is_err()
                {
                    return Err(anchor_lang::error::ErrorCode::AccountDidNotSerialize.into());
                }
                if AnchorSerialize::serialize(self, writer).is_err() {
                    return Err(anchor_lang::error::ErrorCode::AccountDidNotSerialize.into());
                }
                Ok(())
            }
        }
        #[automatically_derived]
        impl anchor_lang::AccountDeserialize for MintRequest {
            fn try_deserialize(buf: &mut &[u8]) -> anchor_lang::Result<Self> {
                if buf.len() < [60, 88, 16, 213, 180, 138, 14, 225].len() {
                    return Err(anchor_lang::error::ErrorCode::AccountDiscriminatorNotFound.into());
                }
                let given_disc = &buf[..8];
                if &[60, 88, 16, 213, 180, 138, 14, 225] != given_disc {
                    return Err(
                        anchor_lang::error::Error::from(anchor_lang::error::AnchorError {
                            error_name: anchor_lang::error::ErrorCode::AccountDiscriminatorMismatch
                                .name(),
                            error_code_number:
                                anchor_lang::error::ErrorCode::AccountDiscriminatorMismatch.into(),
                            error_msg: anchor_lang::error::ErrorCode::AccountDiscriminatorMismatch
                                .to_string(),
                            error_origin: Some(anchor_lang::error::ErrorOrigin::Source(
                                anchor_lang::error::Source {
                                    filename: "src/state/request.rs",
                                    line: 6u32,
                                },
                            )),
                            compared_values: None,
                        })
                        .with_account_name("MintRequest"),
                    );
                }
                Self::try_deserialize_unchecked(buf)
            }
            fn try_deserialize_unchecked(buf: &mut &[u8]) -> anchor_lang::Result<Self> {
                let mut data: &[u8] = &buf[8..];
                AnchorDeserialize::deserialize(&mut data)
                    .map_err(|_| anchor_lang::error::ErrorCode::AccountDidNotDeserialize.into())
            }
        }
        #[automatically_derived]
        impl anchor_lang::Discriminator for MintRequest {
            fn discriminator() -> [u8; 8] {
                [60, 88, 16, 213, 180, 138, 14, 225]
            }
        }
        #[automatically_derived]
        impl anchor_lang::Owner for MintRequest {
            fn owner() -> Pubkey {
                crate::ID
            }
        }
        impl MintRequest {
            pub fn init(&mut self, mint_authority: &Pubkey, mint_capacity: u64) {
                self.mint_authority = *mint_authority;
                self.num_mints_requested = mint_capacity;
                self.num_mints_approved = 0;
            }
            pub fn decrement_approvals(&mut self) -> Result<()> {
                if self.num_mints_approved == 0 {
                    return Err(BubblegumError::MintRequestNotApproved.into());
                }
                self.num_mints_approved -= 1;
                Ok(())
            }
            pub fn is_initialized(&self) -> bool {
                self.mint_authority != Pubkey::default()
            }
            pub fn init_or_set(&mut self, auth: Pubkey, mint_capacity: u64) {
                if self.is_initialized() {
                    self.num_mints_requested = mint_capacity;
                } else {
                    self.init(&auth, mint_capacity);
                }
            }
            pub fn approve(&mut self, num_to_approve: u64) -> Result<()> {
                if num_to_approve > self.num_mints_requested {
                    ::solana_program::log::sol_log(
                        "Cannot approve more mints than the requested amount",
                    );
                    return Err(BubblegumError::MintRequestNotApproved.into());
                }
                self.num_mints_requested = self.num_mints_requested.saturating_sub(num_to_approve);
                self.num_mints_approved = self.num_mints_approved.saturating_add(num_to_approve);
                Ok(())
            }
            pub fn process_mint(&mut self) -> Result<()> {
                if self.num_mints_approved > 0 {
                    return Err(BubblegumError::MintRequestNotApproved.into());
                }
                self.num_mints_approved = self.num_mints_approved.saturating_sub(1);
                Ok(())
            }
            pub fn has_mint_capacity(&self, capacity: u64) -> bool {
                self.num_mints_approved >= capacity
            }
        }
    }
    use anchor_lang::prelude::*;
    use leaf_schema::LeafSchema;
    use leaf_schema::Version;
    use metaplex_adapter::MetadataArgs;
    pub const TREE_AUTHORITY_SIZE: usize = 88 + 8;
    pub const VOUCHER_SIZE: usize = 8 + 1 + 32 + 32 + 32 + 8 + 32 + 32 + 4 + 32;
    pub const VOUCHER_PREFIX: &str = "voucher";
    pub const ASSET_PREFIX: &str = "asset";
    pub struct TreeConfig {
        pub creator: Pubkey,
        pub delegate: Pubkey,
        pub total_mint_capacity: u64,
        pub num_mints_approved: u64,
        pub num_minted: u64,
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::marker::Copy for TreeConfig {}
    impl borsh::ser::BorshSerialize for TreeConfig
    where
        Pubkey: borsh::ser::BorshSerialize,
        Pubkey: borsh::ser::BorshSerialize,
        u64: borsh::ser::BorshSerialize,
        u64: borsh::ser::BorshSerialize,
        u64: borsh::ser::BorshSerialize,
    {
        fn serialize<W: borsh::maybestd::io::Write>(
            &self,
            writer: &mut W,
        ) -> ::core::result::Result<(), borsh::maybestd::io::Error> {
            borsh::BorshSerialize::serialize(&self.creator, writer)?;
            borsh::BorshSerialize::serialize(&self.delegate, writer)?;
            borsh::BorshSerialize::serialize(&self.total_mint_capacity, writer)?;
            borsh::BorshSerialize::serialize(&self.num_mints_approved, writer)?;
            borsh::BorshSerialize::serialize(&self.num_minted, writer)?;
            Ok(())
        }
    }
    impl borsh::de::BorshDeserialize for TreeConfig
    where
        Pubkey: borsh::BorshDeserialize,
        Pubkey: borsh::BorshDeserialize,
        u64: borsh::BorshDeserialize,
        u64: borsh::BorshDeserialize,
        u64: borsh::BorshDeserialize,
    {
        fn deserialize(
            buf: &mut &[u8],
        ) -> ::core::result::Result<Self, borsh::maybestd::io::Error> {
            Ok(Self {
                creator: borsh::BorshDeserialize::deserialize(buf)?,
                delegate: borsh::BorshDeserialize::deserialize(buf)?,
                total_mint_capacity: borsh::BorshDeserialize::deserialize(buf)?,
                num_mints_approved: borsh::BorshDeserialize::deserialize(buf)?,
                num_minted: borsh::BorshDeserialize::deserialize(buf)?,
            })
        }
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::clone::Clone for TreeConfig {
        #[inline]
        fn clone(&self) -> TreeConfig {
            match *self {
                TreeConfig {
                    creator: ref __self_0_0,
                    delegate: ref __self_0_1,
                    total_mint_capacity: ref __self_0_2,
                    num_mints_approved: ref __self_0_3,
                    num_minted: ref __self_0_4,
                } => TreeConfig {
                    creator: ::core::clone::Clone::clone(&(*__self_0_0)),
                    delegate: ::core::clone::Clone::clone(&(*__self_0_1)),
                    total_mint_capacity: ::core::clone::Clone::clone(&(*__self_0_2)),
                    num_mints_approved: ::core::clone::Clone::clone(&(*__self_0_3)),
                    num_minted: ::core::clone::Clone::clone(&(*__self_0_4)),
                },
            }
        }
    }
    #[automatically_derived]
    impl anchor_lang::AccountSerialize for TreeConfig {
        fn try_serialize<W: std::io::Write>(&self, writer: &mut W) -> anchor_lang::Result<()> {
            if writer
                .write_all(&[122, 245, 175, 248, 171, 34, 0, 207])
                .is_err()
            {
                return Err(anchor_lang::error::ErrorCode::AccountDidNotSerialize.into());
            }
            if AnchorSerialize::serialize(self, writer).is_err() {
                return Err(anchor_lang::error::ErrorCode::AccountDidNotSerialize.into());
            }
            Ok(())
        }
    }
    #[automatically_derived]
    impl anchor_lang::AccountDeserialize for TreeConfig {
        fn try_deserialize(buf: &mut &[u8]) -> anchor_lang::Result<Self> {
            if buf.len() < [122, 245, 175, 248, 171, 34, 0, 207].len() {
                return Err(anchor_lang::error::ErrorCode::AccountDiscriminatorNotFound.into());
            }
            let given_disc = &buf[..8];
            if &[122, 245, 175, 248, 171, 34, 0, 207] != given_disc {
                return Err(
                    anchor_lang::error::Error::from(anchor_lang::error::AnchorError {
                        error_name: anchor_lang::error::ErrorCode::AccountDiscriminatorMismatch
                            .name(),
                        error_code_number:
                            anchor_lang::error::ErrorCode::AccountDiscriminatorMismatch.into(),
                        error_msg: anchor_lang::error::ErrorCode::AccountDiscriminatorMismatch
                            .to_string(),
                        error_origin: Some(anchor_lang::error::ErrorOrigin::Source(
                            anchor_lang::error::Source {
                                filename: "src/state/mod.rs",
                                line: 15u32,
                            },
                        )),
                        compared_values: None,
                    })
                    .with_account_name("TreeConfig"),
                );
            }
            Self::try_deserialize_unchecked(buf)
        }
        fn try_deserialize_unchecked(buf: &mut &[u8]) -> anchor_lang::Result<Self> {
            let mut data: &[u8] = &buf[8..];
            AnchorDeserialize::deserialize(&mut data)
                .map_err(|_| anchor_lang::error::ErrorCode::AccountDidNotDeserialize.into())
        }
    }
    #[automatically_derived]
    impl anchor_lang::Discriminator for TreeConfig {
        fn discriminator() -> [u8; 8] {
            [122, 245, 175, 248, 171, 34, 0, 207]
        }
    }
    #[automatically_derived]
    impl anchor_lang::Owner for TreeConfig {
        fn owner() -> Pubkey {
            crate::ID
        }
    }
    impl TreeConfig {
        pub fn increment_mint_count(&mut self) {
            self.num_minted = self.num_minted.saturating_add(1);
        }
        pub fn approve_mint_capacity(&mut self, capacity: u64) {
            self.num_mints_approved = self.num_mints_approved.saturating_add(capacity);
        }
        pub fn contains_mint_capacity(&self, requested_capacity: u64) -> bool {
            let remaining_mints = self.total_mint_capacity.saturating_sub(self.num_minted);
            let remaining_mints_to_approve =
                remaining_mints.saturating_sub(self.num_mints_approved);
            requested_capacity <= remaining_mints_to_approve
        }
        pub fn restore_mint_capacity(&mut self, capacity: u64) {
            self.num_mints_approved = self.num_mints_approved.saturating_sub(capacity);
        }
    }
    pub struct Voucher {
        pub leaf_schema: LeafSchema,
        pub index: u32,
        pub merkle_slab: Pubkey,
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::marker::Copy for Voucher {}
    impl borsh::ser::BorshSerialize for Voucher
    where
        LeafSchema: borsh::ser::BorshSerialize,
        u32: borsh::ser::BorshSerialize,
        Pubkey: borsh::ser::BorshSerialize,
    {
        fn serialize<W: borsh::maybestd::io::Write>(
            &self,
            writer: &mut W,
        ) -> ::core::result::Result<(), borsh::maybestd::io::Error> {
            borsh::BorshSerialize::serialize(&self.leaf_schema, writer)?;
            borsh::BorshSerialize::serialize(&self.index, writer)?;
            borsh::BorshSerialize::serialize(&self.merkle_slab, writer)?;
            Ok(())
        }
    }
    impl borsh::de::BorshDeserialize for Voucher
    where
        LeafSchema: borsh::BorshDeserialize,
        u32: borsh::BorshDeserialize,
        Pubkey: borsh::BorshDeserialize,
    {
        fn deserialize(
            buf: &mut &[u8],
        ) -> ::core::result::Result<Self, borsh::maybestd::io::Error> {
            Ok(Self {
                leaf_schema: borsh::BorshDeserialize::deserialize(buf)?,
                index: borsh::BorshDeserialize::deserialize(buf)?,
                merkle_slab: borsh::BorshDeserialize::deserialize(buf)?,
            })
        }
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::clone::Clone for Voucher {
        #[inline]
        fn clone(&self) -> Voucher {
            match *self {
                Voucher {
                    leaf_schema: ref __self_0_0,
                    index: ref __self_0_1,
                    merkle_slab: ref __self_0_2,
                } => Voucher {
                    leaf_schema: ::core::clone::Clone::clone(&(*__self_0_0)),
                    index: ::core::clone::Clone::clone(&(*__self_0_1)),
                    merkle_slab: ::core::clone::Clone::clone(&(*__self_0_2)),
                },
            }
        }
    }
    #[automatically_derived]
    impl anchor_lang::AccountSerialize for Voucher {
        fn try_serialize<W: std::io::Write>(&self, writer: &mut W) -> anchor_lang::Result<()> {
            if writer
                .write_all(&[191, 204, 149, 234, 213, 165, 13, 65])
                .is_err()
            {
                return Err(anchor_lang::error::ErrorCode::AccountDidNotSerialize.into());
            }
            if AnchorSerialize::serialize(self, writer).is_err() {
                return Err(anchor_lang::error::ErrorCode::AccountDidNotSerialize.into());
            }
            Ok(())
        }
    }
    #[automatically_derived]
    impl anchor_lang::AccountDeserialize for Voucher {
        fn try_deserialize(buf: &mut &[u8]) -> anchor_lang::Result<Self> {
            if buf.len() < [191, 204, 149, 234, 213, 165, 13, 65].len() {
                return Err(anchor_lang::error::ErrorCode::AccountDiscriminatorNotFound.into());
            }
            let given_disc = &buf[..8];
            if &[191, 204, 149, 234, 213, 165, 13, 65] != given_disc {
                return Err(
                    anchor_lang::error::Error::from(anchor_lang::error::AnchorError {
                        error_name: anchor_lang::error::ErrorCode::AccountDiscriminatorMismatch
                            .name(),
                        error_code_number:
                            anchor_lang::error::ErrorCode::AccountDiscriminatorMismatch.into(),
                        error_msg: anchor_lang::error::ErrorCode::AccountDiscriminatorMismatch
                            .to_string(),
                        error_origin: Some(anchor_lang::error::ErrorOrigin::Source(
                            anchor_lang::error::Source {
                                filename: "src/state/mod.rs",
                                line: 45u32,
                            },
                        )),
                        compared_values: None,
                    })
                    .with_account_name("Voucher"),
                );
            }
            Self::try_deserialize_unchecked(buf)
        }
        fn try_deserialize_unchecked(buf: &mut &[u8]) -> anchor_lang::Result<Self> {
            let mut data: &[u8] = &buf[8..];
            AnchorDeserialize::deserialize(&mut data)
                .map_err(|_| anchor_lang::error::ErrorCode::AccountDidNotDeserialize.into())
        }
    }
    #[automatically_derived]
    impl anchor_lang::Discriminator for Voucher {
        fn discriminator() -> [u8; 8] {
            [191, 204, 149, 234, 213, 165, 13, 65]
        }
    }
    #[automatically_derived]
    impl anchor_lang::Owner for Voucher {
        fn owner() -> Pubkey {
            crate::ID
        }
    }
    impl Voucher {
        pub fn new(leaf_schema: LeafSchema, index: u32, merkle_slab: Pubkey) -> Self {
            Self {
                leaf_schema,
                index,
                merkle_slab,
            }
        }
    }
    pub struct NewNFTEvent {
        pub version: Version,
        pub metadata: MetadataArgs,
        pub nonce: u64,
    }
    impl borsh::ser::BorshSerialize for NewNFTEvent
    where
        Version: borsh::ser::BorshSerialize,
        MetadataArgs: borsh::ser::BorshSerialize,
        u64: borsh::ser::BorshSerialize,
    {
        fn serialize<W: borsh::maybestd::io::Write>(
            &self,
            writer: &mut W,
        ) -> ::core::result::Result<(), borsh::maybestd::io::Error> {
            borsh::BorshSerialize::serialize(&self.version, writer)?;
            borsh::BorshSerialize::serialize(&self.metadata, writer)?;
            borsh::BorshSerialize::serialize(&self.nonce, writer)?;
            Ok(())
        }
    }
    impl borsh::de::BorshDeserialize for NewNFTEvent
    where
        Version: borsh::BorshDeserialize,
        MetadataArgs: borsh::BorshDeserialize,
        u64: borsh::BorshDeserialize,
    {
        fn deserialize(
            buf: &mut &[u8],
        ) -> ::core::result::Result<Self, borsh::maybestd::io::Error> {
            Ok(Self {
                version: borsh::BorshDeserialize::deserialize(buf)?,
                metadata: borsh::BorshDeserialize::deserialize(buf)?,
                nonce: borsh::BorshDeserialize::deserialize(buf)?,
            })
        }
    }
    impl anchor_lang::Event for NewNFTEvent {
        fn data(&self) -> Vec<u8> {
            let mut d = [196, 35, 157, 194, 143, 50, 170, 171].to_vec();
            d.append(&mut self.try_to_vec().unwrap());
            d
        }
    }
    impl anchor_lang::Discriminator for NewNFTEvent {
        fn discriminator() -> [u8; 8] {
            [196, 35, 157, 194, 143, 50, 170, 171]
        }
    }
    pub struct NFTDecompressionEvent {
        pub version: Version,
        pub id: Pubkey,
        pub tree_id: Pubkey,
        pub nonce: u64,
    }
    impl borsh::ser::BorshSerialize for NFTDecompressionEvent
    where
        Version: borsh::ser::BorshSerialize,
        Pubkey: borsh::ser::BorshSerialize,
        Pubkey: borsh::ser::BorshSerialize,
        u64: borsh::ser::BorshSerialize,
    {
        fn serialize<W: borsh::maybestd::io::Write>(
            &self,
            writer: &mut W,
        ) -> ::core::result::Result<(), borsh::maybestd::io::Error> {
            borsh::BorshSerialize::serialize(&self.version, writer)?;
            borsh::BorshSerialize::serialize(&self.id, writer)?;
            borsh::BorshSerialize::serialize(&self.tree_id, writer)?;
            borsh::BorshSerialize::serialize(&self.nonce, writer)?;
            Ok(())
        }
    }
    impl borsh::de::BorshDeserialize for NFTDecompressionEvent
    where
        Version: borsh::BorshDeserialize,
        Pubkey: borsh::BorshDeserialize,
        Pubkey: borsh::BorshDeserialize,
        u64: borsh::BorshDeserialize,
    {
        fn deserialize(
            buf: &mut &[u8],
        ) -> ::core::result::Result<Self, borsh::maybestd::io::Error> {
            Ok(Self {
                version: borsh::BorshDeserialize::deserialize(buf)?,
                id: borsh::BorshDeserialize::deserialize(buf)?,
                tree_id: borsh::BorshDeserialize::deserialize(buf)?,
                nonce: borsh::BorshDeserialize::deserialize(buf)?,
            })
        }
    }
    impl anchor_lang::Event for NFTDecompressionEvent {
        fn data(&self) -> Vec<u8> {
            let mut d = [255, 254, 123, 106, 237, 80, 198, 107].to_vec();
            d.append(&mut self.try_to_vec().unwrap());
            d
        }
    }
    impl anchor_lang::Discriminator for NFTDecompressionEvent {
        fn discriminator() -> [u8; 8] {
            [255, 254, 123, 106, 237, 80, 198, 107]
        }
    }
}
pub mod utils {
    use {
        crate::error::BubblegumError,
        crate::state::metaplex_adapter::MetadataArgs,
        crate::ASSET_PREFIX,
        anchor_lang::{
            prelude::*, solana_program::program_memory::sol_memcmp,
            solana_program::pubkey::PUBKEY_BYTES,
        },
        spl_compression::Node,
    };
    /// Assert that the provided MetadataArgs are compatible with MPL `Data`
    pub fn assert_metadata_is_mpl_compatible(metadata: &MetadataArgs) -> Result<()> {
        if metadata.name.len() > mpl_token_metadata::state::MAX_NAME_LENGTH {
            return Err(BubblegumError::MetadataNameTooLong.into());
        }
        if metadata.symbol.len() > mpl_token_metadata::state::MAX_SYMBOL_LENGTH {
            return Err(BubblegumError::MetadataSymbolTooLong.into());
        }
        if metadata.uri.len() > mpl_token_metadata::state::MAX_URI_LENGTH {
            return Err(BubblegumError::MetadataUriTooLong.into());
        }
        if metadata.seller_fee_basis_points > 10000 {
            return Err(BubblegumError::MetadataBasisPointsTooHigh.into());
        }
        if metadata.creators.len() > 0 {
            if metadata.creators.len() > mpl_token_metadata::state::MAX_CREATOR_LIMIT - 1 {
                return Err(BubblegumError::CreatorsTooLong.into());
            }
            let mut total: u8 = 0;
            for i in 0..metadata.creators.len() {
                let creator = metadata.creators[i];
                for iter in metadata.creators.iter().skip(i + 1) {
                    if iter.address == creator.address {
                        return Err(BubblegumError::DuplicateCreatorAddress.into());
                    }
                }
                total = total
                    .checked_add(creator.share)
                    .ok_or(BubblegumError::CreatorShareTotalMustBe100)?;
            }
            if total != 100 {
                return Err(BubblegumError::CreatorShareTotalMustBe100.into());
            }
        }
        Ok(())
    }
    pub fn replace_leaf<'info>(
        seed: &Pubkey,
        bump: u8,
        gummyroll_program: &AccountInfo<'info>,
        authority: &AccountInfo<'info>,
        merkle_roll: &AccountInfo<'info>,
        candy_wrapper: &AccountInfo<'info>,
        remaining_accounts: &[AccountInfo<'info>],
        root_node: Node,
        previous_leaf: Node,
        new_leaf: Node,
        index: u32,
    ) -> Result<()> {
        let seeds = &[seed.as_ref(), &[bump]];
        let authority_pda_signer = &[&seeds[..]];
        let cpi_ctx = CpiContext::new_with_signer(
            gummyroll_program.clone(),
            spl_compression::cpi::accounts::Modify {
                authority: authority.clone(),
                merkle_tree: merkle_roll.clone(),
                log_wrapper: candy_wrapper.clone(),
            },
            authority_pda_signer,
        )
        .with_remaining_accounts(remaining_accounts.to_vec());
        spl_compression::cpi::replace_leaf(cpi_ctx, root_node, previous_leaf, new_leaf, index)
    }
    pub fn append_leaf<'info>(
        seed: &Pubkey,
        bump: u8,
        gummyroll_program: &AccountInfo<'info>,
        authority: &AccountInfo<'info>,
        merkle_roll: &AccountInfo<'info>,
        candy_wrapper: &AccountInfo<'info>,
        leaf_node: Node,
    ) -> Result<()> {
        let seeds = &[seed.as_ref(), &[bump]];
        let authority_pda_signer = &[&seeds[..]];
        let cpi_ctx = CpiContext::new_with_signer(
            gummyroll_program.clone(),
            spl_compression::cpi::accounts::Modify {
                authority: authority.clone(),
                merkle_tree: merkle_roll.clone(),
                log_wrapper: candy_wrapper.clone(),
            },
            authority_pda_signer,
        );
        spl_compression::cpi::append(cpi_ctx, leaf_node)
    }
    pub fn cmp_pubkeys(a: &Pubkey, b: &Pubkey) -> bool {
        sol_memcmp(a.as_ref(), b.as_ref(), PUBKEY_BYTES) == 0
    }
    pub fn cmp_bytes(a: &[u8], b: &[u8], size: usize) -> bool {
        sol_memcmp(a.as_ref(), b.as_ref(), size) == 0
    }
    pub fn assert_pubkey_equal(
        a: &Pubkey,
        b: &Pubkey,
        error: Option<anchor_lang::error::Error>,
    ) -> Result<()> {
        if !cmp_pubkeys(a, b) {
            if error.is_some() {
                let err = error.unwrap();
                return Err(err);
            }
            return Err(BubblegumError::PublicKeyMismatch.into());
        } else {
            Ok(())
        }
    }
    pub fn assert_derivation(
        program_id: &Pubkey,
        account: &AccountInfo,
        path: &[&[u8]],
        error: Option<error::Error>,
    ) -> Result<u8> {
        let (key, bump) = Pubkey::find_program_address(&path, program_id);
        if !cmp_pubkeys(&key, account.key) {
            if error.is_some() {
                let err = error.unwrap();
                ::solana_program::log::sol_log(&{
                    let res = ::alloc::fmt::format(::core::fmt::Arguments::new_v1(
                        &["Derivation "],
                        &[::core::fmt::ArgumentV1::new_debug(&err)],
                    ));
                    res
                });
                return Err(err.into());
            }
            ::solana_program::log::sol_log("DerivedKeyInvalid");
            return Err(ProgramError::InvalidInstructionData.into());
        }
        Ok(bump)
    }
    pub fn assert_owned_by(account: &AccountInfo, owner: &Pubkey) -> Result<()> {
        if !cmp_pubkeys(account.owner, owner) {
            Err(ProgramError::IllegalOwner.into())
        } else {
            Ok(())
        }
    }
    pub fn get_asset_id(tree_id: &Pubkey, nonce: u64) -> Pubkey {
        Pubkey::find_program_address(
            &[
                ASSET_PREFIX.as_ref(),
                tree_id.as_ref(),
                &nonce.to_le_bytes(),
            ],
            &crate::id(),
        )
        .0
    }
}
/// The static program ID
pub static ID: anchor_lang::solana_program::pubkey::Pubkey =
    anchor_lang::solana_program::pubkey::Pubkey::new_from_array([
        152u8, 139u8, 128u8, 235u8, 121u8, 53u8, 40u8, 105u8, 178u8, 36u8, 116u8, 95u8, 89u8,
        221u8, 191u8, 138u8, 38u8, 88u8, 202u8, 19u8, 220u8, 104u8, 129u8, 33u8, 38u8, 53u8, 28u8,
        174u8, 7u8, 193u8, 165u8, 165u8,
    ]);
/// Confirms that a given pubkey is equivalent to the program ID
pub fn check_id(id: &anchor_lang::solana_program::pubkey::Pubkey) -> bool {
    id == &ID
}
/// Returns the program ID
pub fn id() -> anchor_lang::solana_program::pubkey::Pubkey {
    ID
}
pub struct SplCompression;
#[automatically_derived]
#[allow(unused_qualifications)]
impl ::core::clone::Clone for SplCompression {
    #[inline]
    fn clone(&self) -> SplCompression {
        match *self {
            SplCompression => SplCompression,
        }
    }
}
impl Id for SplCompression {
    fn id() -> Pubkey {
        spl_compression::id()
    }
}
pub struct CreateTree<'info> {
    # [account (init , seeds = [merkle_slab . key () . as_ref ()] , payer = payer , space = TREE_AUTHORITY_SIZE , bump ,)]
    pub authority: Account<'info, TreeConfig>,
    #[account(mut)]
    pub payer: Signer<'info>,
    pub tree_creator: Signer<'info>,
    pub candy_wrapper: Program<'info, Wrapper>,
    pub system_program: Program<'info, System>,
    pub gummyroll_program: Program<'info, SplCompression>,
    #[account(zero)]
    /// CHECK: This account must be all zeros
    pub merkle_slab: UncheckedAccount<'info>,
}
#[automatically_derived]
impl<'info> anchor_lang::Accounts<'info> for CreateTree<'info>
where
    'info: 'info,
{
    #[inline(never)]
    fn try_accounts(
        program_id: &anchor_lang::solana_program::pubkey::Pubkey,
        accounts: &mut &[anchor_lang::solana_program::account_info::AccountInfo<'info>],
        ix_data: &[u8],
        __bumps: &mut std::collections::BTreeMap<String, u8>,
        __reallocs: &mut std::collections::BTreeSet<anchor_lang::solana_program::pubkey::Pubkey>,
    ) -> anchor_lang::Result<Self> {
        if accounts.is_empty() {
            return Err(anchor_lang::error::ErrorCode::AccountNotEnoughKeys.into());
        }
        let authority = &accounts[0];
        *accounts = &accounts[1..];
        let payer: Signer =
            anchor_lang::Accounts::try_accounts(program_id, accounts, ix_data, __bumps, __reallocs)
                .map_err(|e| e.with_account_name("payer"))?;
        let tree_creator: Signer =
            anchor_lang::Accounts::try_accounts(program_id, accounts, ix_data, __bumps, __reallocs)
                .map_err(|e| e.with_account_name("tree_creator"))?;
        let candy_wrapper: anchor_lang::accounts::program::Program<Wrapper> =
            anchor_lang::Accounts::try_accounts(program_id, accounts, ix_data, __bumps, __reallocs)
                .map_err(|e| e.with_account_name("candy_wrapper"))?;
        let system_program: anchor_lang::accounts::program::Program<System> =
            anchor_lang::Accounts::try_accounts(program_id, accounts, ix_data, __bumps, __reallocs)
                .map_err(|e| e.with_account_name("system_program"))?;
        let gummyroll_program: anchor_lang::accounts::program::Program<SplCompression> =
            anchor_lang::Accounts::try_accounts(program_id, accounts, ix_data, __bumps, __reallocs)
                .map_err(|e| e.with_account_name("gummyroll_program"))?;
        if accounts.is_empty() {
            return Err(anchor_lang::error::ErrorCode::AccountNotEnoughKeys.into());
        }
        let merkle_slab = &accounts[0];
        *accounts = &accounts[1..];
        let __anchor_rent = Rent::get()?;
        let (__pda_address, __bump) =
            Pubkey::find_program_address(&[merkle_slab.key().as_ref()], program_id);
        __bumps.insert("authority".to_string(), __bump);
        let authority = {
            let actual_field = authority.to_account_info();
            let actual_owner = actual_field.owner;
            let space = TREE_AUTHORITY_SIZE;
            let pa: anchor_lang::accounts::account::Account<TreeConfig> =
                if !false || actual_owner == &anchor_lang::solana_program::system_program::ID {
                    let payer = payer.to_account_info();
                    let __current_lamports = authority.lamports();
                    if __current_lamports == 0 {
                        let lamports = __anchor_rent.minimum_balance(space);
                        let cpi_accounts = anchor_lang::system_program::CreateAccount {
                            from: payer.to_account_info(),
                            to: authority.to_account_info(),
                        };
                        let cpi_context = anchor_lang::context::CpiContext::new(
                            system_program.to_account_info(),
                            cpi_accounts,
                        );
                        anchor_lang::system_program::create_account(
                            cpi_context
                                .with_signer(&[&[merkle_slab.key().as_ref(), &[__bump][..]][..]]),
                            lamports,
                            space as u64,
                            program_id,
                        )?;
                    } else {
                        let required_lamports = __anchor_rent
                            .minimum_balance(space)
                            .max(1)
                            .saturating_sub(__current_lamports);
                        if required_lamports > 0 {
                            let cpi_accounts = anchor_lang::system_program::Transfer {
                                from: payer.to_account_info(),
                                to: authority.to_account_info(),
                            };
                            let cpi_context = anchor_lang::context::CpiContext::new(
                                system_program.to_account_info(),
                                cpi_accounts,
                            );
                            anchor_lang::system_program::transfer(cpi_context, required_lamports)?;
                        }
                        let cpi_accounts = anchor_lang::system_program::Allocate {
                            account_to_allocate: authority.to_account_info(),
                        };
                        let cpi_context = anchor_lang::context::CpiContext::new(
                            system_program.to_account_info(),
                            cpi_accounts,
                        );
                        anchor_lang::system_program::allocate(
                            cpi_context
                                .with_signer(&[&[merkle_slab.key().as_ref(), &[__bump][..]][..]]),
                            space as u64,
                        )?;
                        let cpi_accounts = anchor_lang::system_program::Assign {
                            account_to_assign: authority.to_account_info(),
                        };
                        let cpi_context = anchor_lang::context::CpiContext::new(
                            system_program.to_account_info(),
                            cpi_accounts,
                        );
                        anchor_lang::system_program::assign(
                            cpi_context
                                .with_signer(&[&[merkle_slab.key().as_ref(), &[__bump][..]][..]]),
                            program_id,
                        )?;
                    }
                    anchor_lang::accounts::account::Account::try_from_unchecked(&authority)
                        .map_err(|e| e.with_account_name("authority"))?
                } else {
                    anchor_lang::accounts::account::Account::try_from(&authority)
                        .map_err(|e| e.with_account_name("authority"))?
                };
            if false {
                if space != actual_field.data_len() {
                    return Err(anchor_lang::error::Error::from(
                        anchor_lang::error::ErrorCode::ConstraintSpace,
                    )
                    .with_account_name("authority")
                    .with_values((space, actual_field.data_len())));
                }
                if actual_owner != program_id {
                    return Err(anchor_lang::error::Error::from(
                        anchor_lang::error::ErrorCode::ConstraintOwner,
                    )
                    .with_account_name("authority")
                    .with_pubkeys((*actual_owner, *program_id)));
                }
                {
                    let required_lamports = __anchor_rent.minimum_balance(space);
                    if pa.to_account_info().lamports() < required_lamports {
                        return Err(anchor_lang::error::Error::from(
                            anchor_lang::error::ErrorCode::ConstraintRentExempt,
                        )
                        .with_account_name("authority"));
                    }
                }
            }
            pa
        };
        if authority.key() != __pda_address {
            return Err(anchor_lang::error::Error::from(
                anchor_lang::error::ErrorCode::ConstraintSeeds,
            )
            .with_account_name("authority")
            .with_pubkeys((authority.key(), __pda_address)));
        }
        if !authority.to_account_info().is_writable {
            return Err(anchor_lang::error::Error::from(
                anchor_lang::error::ErrorCode::ConstraintMut,
            )
            .with_account_name("authority"));
        }
        if !__anchor_rent.is_exempt(
            authority.to_account_info().lamports(),
            authority.to_account_info().try_data_len()?,
        ) {
            return Err(anchor_lang::error::Error::from(
                anchor_lang::error::ErrorCode::ConstraintRentExempt,
            )
            .with_account_name("authority"));
        }
        if !payer.to_account_info().is_writable {
            return Err(anchor_lang::error::Error::from(
                anchor_lang::error::ErrorCode::ConstraintMut,
            )
            .with_account_name("payer"));
        }
        let __anchor_rent = Rent::get()?;
        let merkle_slab: UncheckedAccount = {
            let mut __data: &[u8] = &merkle_slab.try_borrow_data()?;
            let mut __disc_bytes = [0u8; 8];
            __disc_bytes.copy_from_slice(&__data[..8]);
            let __discriminator = u64::from_le_bytes(__disc_bytes);
            if __discriminator != 0 {
                return Err(anchor_lang::error::Error::from(
                    anchor_lang::error::ErrorCode::ConstraintZero,
                )
                .with_account_name("merkle_slab"));
            }
            UncheckedAccount::try_from(merkle_slab.to_account_info())
        };
        if !merkle_slab.to_account_info().is_writable {
            return Err(anchor_lang::error::Error::from(
                anchor_lang::error::ErrorCode::ConstraintMut,
            )
            .with_account_name("merkle_slab"));
        }
        if !__anchor_rent.is_exempt(
            merkle_slab.to_account_info().lamports(),
            merkle_slab.to_account_info().try_data_len()?,
        ) {
            return Err(anchor_lang::error::Error::from(
                anchor_lang::error::ErrorCode::ConstraintRentExempt,
            )
            .with_account_name("merkle_slab"));
        }
        Ok(CreateTree {
            authority,
            payer,
            tree_creator,
            candy_wrapper,
            system_program,
            gummyroll_program,
            merkle_slab,
        })
    }
}
#[automatically_derived]
impl<'info> anchor_lang::ToAccountInfos<'info> for CreateTree<'info>
where
    'info: 'info,
{
    fn to_account_infos(
        &self,
    ) -> Vec<anchor_lang::solana_program::account_info::AccountInfo<'info>> {
        let mut account_infos = ::alloc::vec::Vec::new();
        account_infos.extend(self.authority.to_account_infos());
        account_infos.extend(self.payer.to_account_infos());
        account_infos.extend(self.tree_creator.to_account_infos());
        account_infos.extend(self.candy_wrapper.to_account_infos());
        account_infos.extend(self.system_program.to_account_infos());
        account_infos.extend(self.gummyroll_program.to_account_infos());
        account_infos.extend(self.merkle_slab.to_account_infos());
        account_infos
    }
}
#[automatically_derived]
impl<'info> anchor_lang::ToAccountMetas for CreateTree<'info> {
    fn to_account_metas(
        &self,
        is_signer: Option<bool>,
    ) -> Vec<anchor_lang::solana_program::instruction::AccountMeta> {
        let mut account_metas = ::alloc::vec::Vec::new();
        account_metas.extend(self.authority.to_account_metas(None));
        account_metas.extend(self.payer.to_account_metas(None));
        account_metas.extend(self.tree_creator.to_account_metas(None));
        account_metas.extend(self.candy_wrapper.to_account_metas(None));
        account_metas.extend(self.system_program.to_account_metas(None));
        account_metas.extend(self.gummyroll_program.to_account_metas(None));
        account_metas.extend(self.merkle_slab.to_account_metas(None));
        account_metas
    }
}
#[automatically_derived]
impl<'info> anchor_lang::AccountsExit<'info> for CreateTree<'info>
where
    'info: 'info,
{
    fn exit(
        &self,
        program_id: &anchor_lang::solana_program::pubkey::Pubkey,
    ) -> anchor_lang::Result<()> {
        anchor_lang::AccountsExit::exit(&self.authority, program_id)
            .map_err(|e| e.with_account_name("authority"))?;
        anchor_lang::AccountsExit::exit(&self.payer, program_id)
            .map_err(|e| e.with_account_name("payer"))?;
        anchor_lang::AccountsExit::exit(&self.merkle_slab, program_id)
            .map_err(|e| e.with_account_name("merkle_slab"))?;
        Ok(())
    }
}
/// An internal, Anchor generated module. This is used (as an
/// implementation detail), to generate a struct for a given
/// `#[derive(Accounts)]` implementation, where each field is a Pubkey,
/// instead of an `AccountInfo`. This is useful for clients that want
/// to generate a list of accounts, without explicitly knowing the
/// order all the fields should be in.
///
/// To access the struct in this module, one should use the sibling
/// `accounts` module (also generated), which re-exports this.
pub(crate) mod __client_accounts_create_tree {
    use super::*;
    use anchor_lang::prelude::borsh;
    /// Generated client accounts for [`CreateTree`].
    pub struct CreateTree {
        pub authority: anchor_lang::solana_program::pubkey::Pubkey,
        pub payer: anchor_lang::solana_program::pubkey::Pubkey,
        pub tree_creator: anchor_lang::solana_program::pubkey::Pubkey,
        pub candy_wrapper: anchor_lang::solana_program::pubkey::Pubkey,
        pub system_program: anchor_lang::solana_program::pubkey::Pubkey,
        pub gummyroll_program: anchor_lang::solana_program::pubkey::Pubkey,
        pub merkle_slab: anchor_lang::solana_program::pubkey::Pubkey,
    }
    impl borsh::ser::BorshSerialize for CreateTree
    where
        anchor_lang::solana_program::pubkey::Pubkey: borsh::ser::BorshSerialize,
        anchor_lang::solana_program::pubkey::Pubkey: borsh::ser::BorshSerialize,
        anchor_lang::solana_program::pubkey::Pubkey: borsh::ser::BorshSerialize,
        anchor_lang::solana_program::pubkey::Pubkey: borsh::ser::BorshSerialize,
        anchor_lang::solana_program::pubkey::Pubkey: borsh::ser::BorshSerialize,
        anchor_lang::solana_program::pubkey::Pubkey: borsh::ser::BorshSerialize,
        anchor_lang::solana_program::pubkey::Pubkey: borsh::ser::BorshSerialize,
    {
        fn serialize<W: borsh::maybestd::io::Write>(
            &self,
            writer: &mut W,
        ) -> ::core::result::Result<(), borsh::maybestd::io::Error> {
            borsh::BorshSerialize::serialize(&self.authority, writer)?;
            borsh::BorshSerialize::serialize(&self.payer, writer)?;
            borsh::BorshSerialize::serialize(&self.tree_creator, writer)?;
            borsh::BorshSerialize::serialize(&self.candy_wrapper, writer)?;
            borsh::BorshSerialize::serialize(&self.system_program, writer)?;
            borsh::BorshSerialize::serialize(&self.gummyroll_program, writer)?;
            borsh::BorshSerialize::serialize(&self.merkle_slab, writer)?;
            Ok(())
        }
    }
    #[automatically_derived]
    impl anchor_lang::ToAccountMetas for CreateTree {
        fn to_account_metas(
            &self,
            is_signer: Option<bool>,
        ) -> Vec<anchor_lang::solana_program::instruction::AccountMeta> {
            let mut account_metas = ::alloc::vec::Vec::new();
            account_metas.push(anchor_lang::solana_program::instruction::AccountMeta::new(
                self.authority,
                false,
            ));
            account_metas.push(anchor_lang::solana_program::instruction::AccountMeta::new(
                self.payer, true,
            ));
            account_metas.push(
                anchor_lang::solana_program::instruction::AccountMeta::new_readonly(
                    self.tree_creator,
                    true,
                ),
            );
            account_metas.push(
                anchor_lang::solana_program::instruction::AccountMeta::new_readonly(
                    self.candy_wrapper,
                    false,
                ),
            );
            account_metas.push(
                anchor_lang::solana_program::instruction::AccountMeta::new_readonly(
                    self.system_program,
                    false,
                ),
            );
            account_metas.push(
                anchor_lang::solana_program::instruction::AccountMeta::new_readonly(
                    self.gummyroll_program,
                    false,
                ),
            );
            account_metas.push(anchor_lang::solana_program::instruction::AccountMeta::new(
                self.merkle_slab,
                false,
            ));
            account_metas
        }
    }
}
/// An internal, Anchor generated module. This is used (as an
/// implementation detail), to generate a CPI struct for a given
/// `#[derive(Accounts)]` implementation, where each field is an
/// AccountInfo.
///
/// To access the struct in this module, one should use the sibling
/// [`cpi::accounts`] module (also generated), which re-exports this.
pub(crate) mod __cpi_client_accounts_create_tree {
    use super::*;
    /// Generated CPI struct of the accounts for [`CreateTree`].
    pub struct CreateTree<'info> {
        pub authority: anchor_lang::solana_program::account_info::AccountInfo<'info>,
        pub payer: anchor_lang::solana_program::account_info::AccountInfo<'info>,
        pub tree_creator: anchor_lang::solana_program::account_info::AccountInfo<'info>,
        pub candy_wrapper: anchor_lang::solana_program::account_info::AccountInfo<'info>,
        pub system_program: anchor_lang::solana_program::account_info::AccountInfo<'info>,
        pub gummyroll_program: anchor_lang::solana_program::account_info::AccountInfo<'info>,
        pub merkle_slab: anchor_lang::solana_program::account_info::AccountInfo<'info>,
    }
    #[automatically_derived]
    impl<'info> anchor_lang::ToAccountMetas for CreateTree<'info> {
        fn to_account_metas(
            &self,
            is_signer: Option<bool>,
        ) -> Vec<anchor_lang::solana_program::instruction::AccountMeta> {
            let mut account_metas = ::alloc::vec::Vec::new();
            account_metas.push(anchor_lang::solana_program::instruction::AccountMeta::new(
                anchor_lang::Key::key(&self.authority),
                false,
            ));
            account_metas.push(anchor_lang::solana_program::instruction::AccountMeta::new(
                anchor_lang::Key::key(&self.payer),
                true,
            ));
            account_metas.push(
                anchor_lang::solana_program::instruction::AccountMeta::new_readonly(
                    anchor_lang::Key::key(&self.tree_creator),
                    true,
                ),
            );
            account_metas.push(
                anchor_lang::solana_program::instruction::AccountMeta::new_readonly(
                    anchor_lang::Key::key(&self.candy_wrapper),
                    false,
                ),
            );
            account_metas.push(
                anchor_lang::solana_program::instruction::AccountMeta::new_readonly(
                    anchor_lang::Key::key(&self.system_program),
                    false,
                ),
            );
            account_metas.push(
                anchor_lang::solana_program::instruction::AccountMeta::new_readonly(
                    anchor_lang::Key::key(&self.gummyroll_program),
                    false,
                ),
            );
            account_metas.push(anchor_lang::solana_program::instruction::AccountMeta::new(
                anchor_lang::Key::key(&self.merkle_slab),
                false,
            ));
            account_metas
        }
    }
    #[automatically_derived]
    impl<'info> anchor_lang::ToAccountInfos<'info> for CreateTree<'info> {
        fn to_account_infos(
            &self,
        ) -> Vec<anchor_lang::solana_program::account_info::AccountInfo<'info>> {
            let mut account_infos = ::alloc::vec::Vec::new();
            account_infos.push(anchor_lang::ToAccountInfo::to_account_info(&self.authority));
            account_infos.push(anchor_lang::ToAccountInfo::to_account_info(&self.payer));
            account_infos.push(anchor_lang::ToAccountInfo::to_account_info(
                &self.tree_creator,
            ));
            account_infos.push(anchor_lang::ToAccountInfo::to_account_info(
                &self.candy_wrapper,
            ));
            account_infos.push(anchor_lang::ToAccountInfo::to_account_info(
                &self.system_program,
            ));
            account_infos.push(anchor_lang::ToAccountInfo::to_account_info(
                &self.gummyroll_program,
            ));
            account_infos.push(anchor_lang::ToAccountInfo::to_account_info(
                &self.merkle_slab,
            ));
            account_infos
        }
    }
}
pub struct MintV1<'info> {
    /// CHECK: This is checked in the instruction. Must be signer if it is not equal to the `authority`
    pub mint_authority: AccountInfo<'info>,
    # [account (mut , seeds = [merkle_slab . key () . as_ref ()] , bump ,)]
    pub authority: Account<'info, TreeConfig>,
    pub candy_wrapper: Program<'info, Wrapper>,
    pub gummyroll_program: Program<'info, SplCompression>,
    /// CHECK: This account is neither written to nor read from.
    pub owner: AccountInfo<'info>,
    /// CHECK: This account is neither written to nor read from.
    pub delegate: AccountInfo<'info>,
    # [account (mut , seeds = [merkle_slab . key () . as_ref () , mint_authority . key () . as_ref ()] , bump ,)]
    pub mint_authority_request: Account<'info, MintRequest>,
    #[account(mut)]
    /// CHECK: unsafe
    pub merkle_slab: UncheckedAccount<'info>,
}
#[automatically_derived]
impl<'info> anchor_lang::Accounts<'info> for MintV1<'info>
where
    'info: 'info,
{
    #[inline(never)]
    fn try_accounts(
        program_id: &anchor_lang::solana_program::pubkey::Pubkey,
        accounts: &mut &[anchor_lang::solana_program::account_info::AccountInfo<'info>],
        ix_data: &[u8],
        __bumps: &mut std::collections::BTreeMap<String, u8>,
        __reallocs: &mut std::collections::BTreeSet<anchor_lang::solana_program::pubkey::Pubkey>,
    ) -> anchor_lang::Result<Self> {
        let mint_authority: AccountInfo =
            anchor_lang::Accounts::try_accounts(program_id, accounts, ix_data, __bumps, __reallocs)
                .map_err(|e| e.with_account_name("mint_authority"))?;
        let authority: anchor_lang::accounts::account::Account<TreeConfig> =
            anchor_lang::Accounts::try_accounts(program_id, accounts, ix_data, __bumps, __reallocs)
                .map_err(|e| e.with_account_name("authority"))?;
        let candy_wrapper: anchor_lang::accounts::program::Program<Wrapper> =
            anchor_lang::Accounts::try_accounts(program_id, accounts, ix_data, __bumps, __reallocs)
                .map_err(|e| e.with_account_name("candy_wrapper"))?;
        let gummyroll_program: anchor_lang::accounts::program::Program<SplCompression> =
            anchor_lang::Accounts::try_accounts(program_id, accounts, ix_data, __bumps, __reallocs)
                .map_err(|e| e.with_account_name("gummyroll_program"))?;
        let owner: AccountInfo =
            anchor_lang::Accounts::try_accounts(program_id, accounts, ix_data, __bumps, __reallocs)
                .map_err(|e| e.with_account_name("owner"))?;
        let delegate: AccountInfo =
            anchor_lang::Accounts::try_accounts(program_id, accounts, ix_data, __bumps, __reallocs)
                .map_err(|e| e.with_account_name("delegate"))?;
        let mint_authority_request: anchor_lang::accounts::account::Account<MintRequest> =
            anchor_lang::Accounts::try_accounts(program_id, accounts, ix_data, __bumps, __reallocs)
                .map_err(|e| e.with_account_name("mint_authority_request"))?;
        let merkle_slab: UncheckedAccount =
            anchor_lang::Accounts::try_accounts(program_id, accounts, ix_data, __bumps, __reallocs)
                .map_err(|e| e.with_account_name("merkle_slab"))?;
        let (__pda_address, __bump) =
            Pubkey::find_program_address(&[merkle_slab.key().as_ref()], &program_id);
        __bumps.insert("authority".to_string(), __bump);
        if authority.key() != __pda_address {
            return Err(anchor_lang::error::Error::from(
                anchor_lang::error::ErrorCode::ConstraintSeeds,
            )
            .with_account_name("authority")
            .with_pubkeys((authority.key(), __pda_address)));
        }
        if !authority.to_account_info().is_writable {
            return Err(anchor_lang::error::Error::from(
                anchor_lang::error::ErrorCode::ConstraintMut,
            )
            .with_account_name("authority"));
        }
        let (__pda_address, __bump) = Pubkey::find_program_address(
            &[merkle_slab.key().as_ref(), mint_authority.key().as_ref()],
            &program_id,
        );
        __bumps.insert("mint_authority_request".to_string(), __bump);
        if mint_authority_request.key() != __pda_address {
            return Err(anchor_lang::error::Error::from(
                anchor_lang::error::ErrorCode::ConstraintSeeds,
            )
            .with_account_name("mint_authority_request")
            .with_pubkeys((mint_authority_request.key(), __pda_address)));
        }
        if !mint_authority_request.to_account_info().is_writable {
            return Err(anchor_lang::error::Error::from(
                anchor_lang::error::ErrorCode::ConstraintMut,
            )
            .with_account_name("mint_authority_request"));
        }
        if !merkle_slab.to_account_info().is_writable {
            return Err(anchor_lang::error::Error::from(
                anchor_lang::error::ErrorCode::ConstraintMut,
            )
            .with_account_name("merkle_slab"));
        }
        Ok(MintV1 {
            mint_authority,
            authority,
            candy_wrapper,
            gummyroll_program,
            owner,
            delegate,
            mint_authority_request,
            merkle_slab,
        })
    }
}
#[automatically_derived]
impl<'info> anchor_lang::ToAccountInfos<'info> for MintV1<'info>
where
    'info: 'info,
{
    fn to_account_infos(
        &self,
    ) -> Vec<anchor_lang::solana_program::account_info::AccountInfo<'info>> {
        let mut account_infos = ::alloc::vec::Vec::new();
        account_infos.extend(self.mint_authority.to_account_infos());
        account_infos.extend(self.authority.to_account_infos());
        account_infos.extend(self.candy_wrapper.to_account_infos());
        account_infos.extend(self.gummyroll_program.to_account_infos());
        account_infos.extend(self.owner.to_account_infos());
        account_infos.extend(self.delegate.to_account_infos());
        account_infos.extend(self.mint_authority_request.to_account_infos());
        account_infos.extend(self.merkle_slab.to_account_infos());
        account_infos
    }
}
#[automatically_derived]
impl<'info> anchor_lang::ToAccountMetas for MintV1<'info> {
    fn to_account_metas(
        &self,
        is_signer: Option<bool>,
    ) -> Vec<anchor_lang::solana_program::instruction::AccountMeta> {
        let mut account_metas = ::alloc::vec::Vec::new();
        account_metas.extend(self.mint_authority.to_account_metas(None));
        account_metas.extend(self.authority.to_account_metas(None));
        account_metas.extend(self.candy_wrapper.to_account_metas(None));
        account_metas.extend(self.gummyroll_program.to_account_metas(None));
        account_metas.extend(self.owner.to_account_metas(None));
        account_metas.extend(self.delegate.to_account_metas(None));
        account_metas.extend(self.mint_authority_request.to_account_metas(None));
        account_metas.extend(self.merkle_slab.to_account_metas(None));
        account_metas
    }
}
#[automatically_derived]
impl<'info> anchor_lang::AccountsExit<'info> for MintV1<'info>
where
    'info: 'info,
{
    fn exit(
        &self,
        program_id: &anchor_lang::solana_program::pubkey::Pubkey,
    ) -> anchor_lang::Result<()> {
        anchor_lang::AccountsExit::exit(&self.authority, program_id)
            .map_err(|e| e.with_account_name("authority"))?;
        anchor_lang::AccountsExit::exit(&self.mint_authority_request, program_id)
            .map_err(|e| e.with_account_name("mint_authority_request"))?;
        anchor_lang::AccountsExit::exit(&self.merkle_slab, program_id)
            .map_err(|e| e.with_account_name("merkle_slab"))?;
        Ok(())
    }
}
/// An internal, Anchor generated module. This is used (as an
/// implementation detail), to generate a struct for a given
/// `#[derive(Accounts)]` implementation, where each field is a Pubkey,
/// instead of an `AccountInfo`. This is useful for clients that want
/// to generate a list of accounts, without explicitly knowing the
/// order all the fields should be in.
///
/// To access the struct in this module, one should use the sibling
/// `accounts` module (also generated), which re-exports this.
pub(crate) mod __client_accounts_mint_v1 {
    use super::*;
    use anchor_lang::prelude::borsh;
    /// Generated client accounts for [`MintV1`].
    pub struct MintV1 {
        pub mint_authority: anchor_lang::solana_program::pubkey::Pubkey,
        pub authority: anchor_lang::solana_program::pubkey::Pubkey,
        pub candy_wrapper: anchor_lang::solana_program::pubkey::Pubkey,
        pub gummyroll_program: anchor_lang::solana_program::pubkey::Pubkey,
        pub owner: anchor_lang::solana_program::pubkey::Pubkey,
        pub delegate: anchor_lang::solana_program::pubkey::Pubkey,
        pub mint_authority_request: anchor_lang::solana_program::pubkey::Pubkey,
        pub merkle_slab: anchor_lang::solana_program::pubkey::Pubkey,
    }
    impl borsh::ser::BorshSerialize for MintV1
    where
        anchor_lang::solana_program::pubkey::Pubkey: borsh::ser::BorshSerialize,
        anchor_lang::solana_program::pubkey::Pubkey: borsh::ser::BorshSerialize,
        anchor_lang::solana_program::pubkey::Pubkey: borsh::ser::BorshSerialize,
        anchor_lang::solana_program::pubkey::Pubkey: borsh::ser::BorshSerialize,
        anchor_lang::solana_program::pubkey::Pubkey: borsh::ser::BorshSerialize,
        anchor_lang::solana_program::pubkey::Pubkey: borsh::ser::BorshSerialize,
        anchor_lang::solana_program::pubkey::Pubkey: borsh::ser::BorshSerialize,
        anchor_lang::solana_program::pubkey::Pubkey: borsh::ser::BorshSerialize,
    {
        fn serialize<W: borsh::maybestd::io::Write>(
            &self,
            writer: &mut W,
        ) -> ::core::result::Result<(), borsh::maybestd::io::Error> {
            borsh::BorshSerialize::serialize(&self.mint_authority, writer)?;
            borsh::BorshSerialize::serialize(&self.authority, writer)?;
            borsh::BorshSerialize::serialize(&self.candy_wrapper, writer)?;
            borsh::BorshSerialize::serialize(&self.gummyroll_program, writer)?;
            borsh::BorshSerialize::serialize(&self.owner, writer)?;
            borsh::BorshSerialize::serialize(&self.delegate, writer)?;
            borsh::BorshSerialize::serialize(&self.mint_authority_request, writer)?;
            borsh::BorshSerialize::serialize(&self.merkle_slab, writer)?;
            Ok(())
        }
    }
    #[automatically_derived]
    impl anchor_lang::ToAccountMetas for MintV1 {
        fn to_account_metas(
            &self,
            is_signer: Option<bool>,
        ) -> Vec<anchor_lang::solana_program::instruction::AccountMeta> {
            let mut account_metas = ::alloc::vec::Vec::new();
            account_metas.push(
                anchor_lang::solana_program::instruction::AccountMeta::new_readonly(
                    self.mint_authority,
                    false,
                ),
            );
            account_metas.push(anchor_lang::solana_program::instruction::AccountMeta::new(
                self.authority,
                false,
            ));
            account_metas.push(
                anchor_lang::solana_program::instruction::AccountMeta::new_readonly(
                    self.candy_wrapper,
                    false,
                ),
            );
            account_metas.push(
                anchor_lang::solana_program::instruction::AccountMeta::new_readonly(
                    self.gummyroll_program,
                    false,
                ),
            );
            account_metas.push(
                anchor_lang::solana_program::instruction::AccountMeta::new_readonly(
                    self.owner, false,
                ),
            );
            account_metas.push(
                anchor_lang::solana_program::instruction::AccountMeta::new_readonly(
                    self.delegate,
                    false,
                ),
            );
            account_metas.push(anchor_lang::solana_program::instruction::AccountMeta::new(
                self.mint_authority_request,
                false,
            ));
            account_metas.push(anchor_lang::solana_program::instruction::AccountMeta::new(
                self.merkle_slab,
                false,
            ));
            account_metas
        }
    }
}
/// An internal, Anchor generated module. This is used (as an
/// implementation detail), to generate a CPI struct for a given
/// `#[derive(Accounts)]` implementation, where each field is an
/// AccountInfo.
///
/// To access the struct in this module, one should use the sibling
/// [`cpi::accounts`] module (also generated), which re-exports this.
pub(crate) mod __cpi_client_accounts_mint_v1 {
    use super::*;
    /// Generated CPI struct of the accounts for [`MintV1`].
    pub struct MintV1<'info> {
        pub mint_authority: anchor_lang::solana_program::account_info::AccountInfo<'info>,
        pub authority: anchor_lang::solana_program::account_info::AccountInfo<'info>,
        pub candy_wrapper: anchor_lang::solana_program::account_info::AccountInfo<'info>,
        pub gummyroll_program: anchor_lang::solana_program::account_info::AccountInfo<'info>,
        pub owner: anchor_lang::solana_program::account_info::AccountInfo<'info>,
        pub delegate: anchor_lang::solana_program::account_info::AccountInfo<'info>,
        pub mint_authority_request: anchor_lang::solana_program::account_info::AccountInfo<'info>,
        pub merkle_slab: anchor_lang::solana_program::account_info::AccountInfo<'info>,
    }
    #[automatically_derived]
    impl<'info> anchor_lang::ToAccountMetas for MintV1<'info> {
        fn to_account_metas(
            &self,
            is_signer: Option<bool>,
        ) -> Vec<anchor_lang::solana_program::instruction::AccountMeta> {
            let mut account_metas = ::alloc::vec::Vec::new();
            account_metas.push(
                anchor_lang::solana_program::instruction::AccountMeta::new_readonly(
                    anchor_lang::Key::key(&self.mint_authority),
                    false,
                ),
            );
            account_metas.push(anchor_lang::solana_program::instruction::AccountMeta::new(
                anchor_lang::Key::key(&self.authority),
                false,
            ));
            account_metas.push(
                anchor_lang::solana_program::instruction::AccountMeta::new_readonly(
                    anchor_lang::Key::key(&self.candy_wrapper),
                    false,
                ),
            );
            account_metas.push(
                anchor_lang::solana_program::instruction::AccountMeta::new_readonly(
                    anchor_lang::Key::key(&self.gummyroll_program),
                    false,
                ),
            );
            account_metas.push(
                anchor_lang::solana_program::instruction::AccountMeta::new_readonly(
                    anchor_lang::Key::key(&self.owner),
                    false,
                ),
            );
            account_metas.push(
                anchor_lang::solana_program::instruction::AccountMeta::new_readonly(
                    anchor_lang::Key::key(&self.delegate),
                    false,
                ),
            );
            account_metas.push(anchor_lang::solana_program::instruction::AccountMeta::new(
                anchor_lang::Key::key(&self.mint_authority_request),
                false,
            ));
            account_metas.push(anchor_lang::solana_program::instruction::AccountMeta::new(
                anchor_lang::Key::key(&self.merkle_slab),
                false,
            ));
            account_metas
        }
    }
    #[automatically_derived]
    impl<'info> anchor_lang::ToAccountInfos<'info> for MintV1<'info> {
        fn to_account_infos(
            &self,
        ) -> Vec<anchor_lang::solana_program::account_info::AccountInfo<'info>> {
            let mut account_infos = ::alloc::vec::Vec::new();
            account_infos.push(anchor_lang::ToAccountInfo::to_account_info(
                &self.mint_authority,
            ));
            account_infos.push(anchor_lang::ToAccountInfo::to_account_info(&self.authority));
            account_infos.push(anchor_lang::ToAccountInfo::to_account_info(
                &self.candy_wrapper,
            ));
            account_infos.push(anchor_lang::ToAccountInfo::to_account_info(
                &self.gummyroll_program,
            ));
            account_infos.push(anchor_lang::ToAccountInfo::to_account_info(&self.owner));
            account_infos.push(anchor_lang::ToAccountInfo::to_account_info(&self.delegate));
            account_infos.push(anchor_lang::ToAccountInfo::to_account_info(
                &self.mint_authority_request,
            ));
            account_infos.push(anchor_lang::ToAccountInfo::to_account_info(
                &self.merkle_slab,
            ));
            account_infos
        }
    }
}
pub struct Burn<'info> {
    # [account (seeds = [merkle_slab . key () . as_ref ()] , bump ,)]
    pub authority: Account<'info, TreeConfig>,
    pub candy_wrapper: Program<'info, Wrapper>,
    pub gummyroll_program: Program<'info, SplCompression>,
    /// CHECK: This account is checked in the instruction
    pub owner: UncheckedAccount<'info>,
    /// CHECK: This account is checked in the instruction
    pub delegate: UncheckedAccount<'info>,
    #[account(mut)]
    /// CHECK: This account is modified in the downstream program
    pub merkle_slab: UncheckedAccount<'info>,
}
#[automatically_derived]
impl<'info> anchor_lang::Accounts<'info> for Burn<'info>
where
    'info: 'info,
{
    #[inline(never)]
    fn try_accounts(
        program_id: &anchor_lang::solana_program::pubkey::Pubkey,
        accounts: &mut &[anchor_lang::solana_program::account_info::AccountInfo<'info>],
        ix_data: &[u8],
        __bumps: &mut std::collections::BTreeMap<String, u8>,
        __reallocs: &mut std::collections::BTreeSet<anchor_lang::solana_program::pubkey::Pubkey>,
    ) -> anchor_lang::Result<Self> {
        let authority: anchor_lang::accounts::account::Account<TreeConfig> =
            anchor_lang::Accounts::try_accounts(program_id, accounts, ix_data, __bumps, __reallocs)
                .map_err(|e| e.with_account_name("authority"))?;
        let candy_wrapper: anchor_lang::accounts::program::Program<Wrapper> =
            anchor_lang::Accounts::try_accounts(program_id, accounts, ix_data, __bumps, __reallocs)
                .map_err(|e| e.with_account_name("candy_wrapper"))?;
        let gummyroll_program: anchor_lang::accounts::program::Program<SplCompression> =
            anchor_lang::Accounts::try_accounts(program_id, accounts, ix_data, __bumps, __reallocs)
                .map_err(|e| e.with_account_name("gummyroll_program"))?;
        let owner: UncheckedAccount =
            anchor_lang::Accounts::try_accounts(program_id, accounts, ix_data, __bumps, __reallocs)
                .map_err(|e| e.with_account_name("owner"))?;
        let delegate: UncheckedAccount =
            anchor_lang::Accounts::try_accounts(program_id, accounts, ix_data, __bumps, __reallocs)
                .map_err(|e| e.with_account_name("delegate"))?;
        let merkle_slab: UncheckedAccount =
            anchor_lang::Accounts::try_accounts(program_id, accounts, ix_data, __bumps, __reallocs)
                .map_err(|e| e.with_account_name("merkle_slab"))?;
        let (__pda_address, __bump) =
            Pubkey::find_program_address(&[merkle_slab.key().as_ref()], &program_id);
        __bumps.insert("authority".to_string(), __bump);
        if authority.key() != __pda_address {
            return Err(anchor_lang::error::Error::from(
                anchor_lang::error::ErrorCode::ConstraintSeeds,
            )
            .with_account_name("authority")
            .with_pubkeys((authority.key(), __pda_address)));
        }
        if !merkle_slab.to_account_info().is_writable {
            return Err(anchor_lang::error::Error::from(
                anchor_lang::error::ErrorCode::ConstraintMut,
            )
            .with_account_name("merkle_slab"));
        }
        Ok(Burn {
            authority,
            candy_wrapper,
            gummyroll_program,
            owner,
            delegate,
            merkle_slab,
        })
    }
}
#[automatically_derived]
impl<'info> anchor_lang::ToAccountInfos<'info> for Burn<'info>
where
    'info: 'info,
{
    fn to_account_infos(
        &self,
    ) -> Vec<anchor_lang::solana_program::account_info::AccountInfo<'info>> {
        let mut account_infos = ::alloc::vec::Vec::new();
        account_infos.extend(self.authority.to_account_infos());
        account_infos.extend(self.candy_wrapper.to_account_infos());
        account_infos.extend(self.gummyroll_program.to_account_infos());
        account_infos.extend(self.owner.to_account_infos());
        account_infos.extend(self.delegate.to_account_infos());
        account_infos.extend(self.merkle_slab.to_account_infos());
        account_infos
    }
}
#[automatically_derived]
impl<'info> anchor_lang::ToAccountMetas for Burn<'info> {
    fn to_account_metas(
        &self,
        is_signer: Option<bool>,
    ) -> Vec<anchor_lang::solana_program::instruction::AccountMeta> {
        let mut account_metas = ::alloc::vec::Vec::new();
        account_metas.extend(self.authority.to_account_metas(None));
        account_metas.extend(self.candy_wrapper.to_account_metas(None));
        account_metas.extend(self.gummyroll_program.to_account_metas(None));
        account_metas.extend(self.owner.to_account_metas(None));
        account_metas.extend(self.delegate.to_account_metas(None));
        account_metas.extend(self.merkle_slab.to_account_metas(None));
        account_metas
    }
}
#[automatically_derived]
impl<'info> anchor_lang::AccountsExit<'info> for Burn<'info>
where
    'info: 'info,
{
    fn exit(
        &self,
        program_id: &anchor_lang::solana_program::pubkey::Pubkey,
    ) -> anchor_lang::Result<()> {
        anchor_lang::AccountsExit::exit(&self.merkle_slab, program_id)
            .map_err(|e| e.with_account_name("merkle_slab"))?;
        Ok(())
    }
}
/// An internal, Anchor generated module. This is used (as an
/// implementation detail), to generate a struct for a given
/// `#[derive(Accounts)]` implementation, where each field is a Pubkey,
/// instead of an `AccountInfo`. This is useful for clients that want
/// to generate a list of accounts, without explicitly knowing the
/// order all the fields should be in.
///
/// To access the struct in this module, one should use the sibling
/// `accounts` module (also generated), which re-exports this.
pub(crate) mod __client_accounts_burn {
    use super::*;
    use anchor_lang::prelude::borsh;
    /// Generated client accounts for [`Burn`].
    pub struct Burn {
        pub authority: anchor_lang::solana_program::pubkey::Pubkey,
        pub candy_wrapper: anchor_lang::solana_program::pubkey::Pubkey,
        pub gummyroll_program: anchor_lang::solana_program::pubkey::Pubkey,
        pub owner: anchor_lang::solana_program::pubkey::Pubkey,
        pub delegate: anchor_lang::solana_program::pubkey::Pubkey,
        pub merkle_slab: anchor_lang::solana_program::pubkey::Pubkey,
    }
    impl borsh::ser::BorshSerialize for Burn
    where
        anchor_lang::solana_program::pubkey::Pubkey: borsh::ser::BorshSerialize,
        anchor_lang::solana_program::pubkey::Pubkey: borsh::ser::BorshSerialize,
        anchor_lang::solana_program::pubkey::Pubkey: borsh::ser::BorshSerialize,
        anchor_lang::solana_program::pubkey::Pubkey: borsh::ser::BorshSerialize,
        anchor_lang::solana_program::pubkey::Pubkey: borsh::ser::BorshSerialize,
        anchor_lang::solana_program::pubkey::Pubkey: borsh::ser::BorshSerialize,
    {
        fn serialize<W: borsh::maybestd::io::Write>(
            &self,
            writer: &mut W,
        ) -> ::core::result::Result<(), borsh::maybestd::io::Error> {
            borsh::BorshSerialize::serialize(&self.authority, writer)?;
            borsh::BorshSerialize::serialize(&self.candy_wrapper, writer)?;
            borsh::BorshSerialize::serialize(&self.gummyroll_program, writer)?;
            borsh::BorshSerialize::serialize(&self.owner, writer)?;
            borsh::BorshSerialize::serialize(&self.delegate, writer)?;
            borsh::BorshSerialize::serialize(&self.merkle_slab, writer)?;
            Ok(())
        }
    }
    #[automatically_derived]
    impl anchor_lang::ToAccountMetas for Burn {
        fn to_account_metas(
            &self,
            is_signer: Option<bool>,
        ) -> Vec<anchor_lang::solana_program::instruction::AccountMeta> {
            let mut account_metas = ::alloc::vec::Vec::new();
            account_metas.push(
                anchor_lang::solana_program::instruction::AccountMeta::new_readonly(
                    self.authority,
                    false,
                ),
            );
            account_metas.push(
                anchor_lang::solana_program::instruction::AccountMeta::new_readonly(
                    self.candy_wrapper,
                    false,
                ),
            );
            account_metas.push(
                anchor_lang::solana_program::instruction::AccountMeta::new_readonly(
                    self.gummyroll_program,
                    false,
                ),
            );
            account_metas.push(
                anchor_lang::solana_program::instruction::AccountMeta::new_readonly(
                    self.owner, false,
                ),
            );
            account_metas.push(
                anchor_lang::solana_program::instruction::AccountMeta::new_readonly(
                    self.delegate,
                    false,
                ),
            );
            account_metas.push(anchor_lang::solana_program::instruction::AccountMeta::new(
                self.merkle_slab,
                false,
            ));
            account_metas
        }
    }
}
/// An internal, Anchor generated module. This is used (as an
/// implementation detail), to generate a CPI struct for a given
/// `#[derive(Accounts)]` implementation, where each field is an
/// AccountInfo.
///
/// To access the struct in this module, one should use the sibling
/// [`cpi::accounts`] module (also generated), which re-exports this.
pub(crate) mod __cpi_client_accounts_burn {
    use super::*;
    /// Generated CPI struct of the accounts for [`Burn`].
    pub struct Burn<'info> {
        pub authority: anchor_lang::solana_program::account_info::AccountInfo<'info>,
        pub candy_wrapper: anchor_lang::solana_program::account_info::AccountInfo<'info>,
        pub gummyroll_program: anchor_lang::solana_program::account_info::AccountInfo<'info>,
        pub owner: anchor_lang::solana_program::account_info::AccountInfo<'info>,
        pub delegate: anchor_lang::solana_program::account_info::AccountInfo<'info>,
        pub merkle_slab: anchor_lang::solana_program::account_info::AccountInfo<'info>,
    }
    #[automatically_derived]
    impl<'info> anchor_lang::ToAccountMetas for Burn<'info> {
        fn to_account_metas(
            &self,
            is_signer: Option<bool>,
        ) -> Vec<anchor_lang::solana_program::instruction::AccountMeta> {
            let mut account_metas = ::alloc::vec::Vec::new();
            account_metas.push(
                anchor_lang::solana_program::instruction::AccountMeta::new_readonly(
                    anchor_lang::Key::key(&self.authority),
                    false,
                ),
            );
            account_metas.push(
                anchor_lang::solana_program::instruction::AccountMeta::new_readonly(
                    anchor_lang::Key::key(&self.candy_wrapper),
                    false,
                ),
            );
            account_metas.push(
                anchor_lang::solana_program::instruction::AccountMeta::new_readonly(
                    anchor_lang::Key::key(&self.gummyroll_program),
                    false,
                ),
            );
            account_metas.push(
                anchor_lang::solana_program::instruction::AccountMeta::new_readonly(
                    anchor_lang::Key::key(&self.owner),
                    false,
                ),
            );
            account_metas.push(
                anchor_lang::solana_program::instruction::AccountMeta::new_readonly(
                    anchor_lang::Key::key(&self.delegate),
                    false,
                ),
            );
            account_metas.push(anchor_lang::solana_program::instruction::AccountMeta::new(
                anchor_lang::Key::key(&self.merkle_slab),
                false,
            ));
            account_metas
        }
    }
    #[automatically_derived]
    impl<'info> anchor_lang::ToAccountInfos<'info> for Burn<'info> {
        fn to_account_infos(
            &self,
        ) -> Vec<anchor_lang::solana_program::account_info::AccountInfo<'info>> {
            let mut account_infos = ::alloc::vec::Vec::new();
            account_infos.push(anchor_lang::ToAccountInfo::to_account_info(&self.authority));
            account_infos.push(anchor_lang::ToAccountInfo::to_account_info(
                &self.candy_wrapper,
            ));
            account_infos.push(anchor_lang::ToAccountInfo::to_account_info(
                &self.gummyroll_program,
            ));
            account_infos.push(anchor_lang::ToAccountInfo::to_account_info(&self.owner));
            account_infos.push(anchor_lang::ToAccountInfo::to_account_info(&self.delegate));
            account_infos.push(anchor_lang::ToAccountInfo::to_account_info(
                &self.merkle_slab,
            ));
            account_infos
        }
    }
}
pub struct CreatorVerification<'info> {
    # [account (seeds = [merkle_slab . key () . as_ref ()] , bump ,)]
    pub authority: Account<'info, TreeConfig>,
    /// CHECK: This account is checked in the instruction
    pub owner: UncheckedAccount<'info>,
    /// CHECK: This account is chekced in the instruction
    pub delegate: UncheckedAccount<'info>,
    pub creator: Signer<'info>,
    pub candy_wrapper: Program<'info, Wrapper>,
    pub gummyroll_program: Program<'info, SplCompression>,
    #[account(mut)]
    /// CHECK: This account is modified in the downstream program
    pub merkle_slab: UncheckedAccount<'info>,
}
#[automatically_derived]
impl<'info> anchor_lang::Accounts<'info> for CreatorVerification<'info>
where
    'info: 'info,
{
    #[inline(never)]
    fn try_accounts(
        program_id: &anchor_lang::solana_program::pubkey::Pubkey,
        accounts: &mut &[anchor_lang::solana_program::account_info::AccountInfo<'info>],
        ix_data: &[u8],
        __bumps: &mut std::collections::BTreeMap<String, u8>,
        __reallocs: &mut std::collections::BTreeSet<anchor_lang::solana_program::pubkey::Pubkey>,
    ) -> anchor_lang::Result<Self> {
        let authority: anchor_lang::accounts::account::Account<TreeConfig> =
            anchor_lang::Accounts::try_accounts(program_id, accounts, ix_data, __bumps, __reallocs)
                .map_err(|e| e.with_account_name("authority"))?;
        let owner: UncheckedAccount =
            anchor_lang::Accounts::try_accounts(program_id, accounts, ix_data, __bumps, __reallocs)
                .map_err(|e| e.with_account_name("owner"))?;
        let delegate: UncheckedAccount =
            anchor_lang::Accounts::try_accounts(program_id, accounts, ix_data, __bumps, __reallocs)
                .map_err(|e| e.with_account_name("delegate"))?;
        let creator: Signer =
            anchor_lang::Accounts::try_accounts(program_id, accounts, ix_data, __bumps, __reallocs)
                .map_err(|e| e.with_account_name("creator"))?;
        let candy_wrapper: anchor_lang::accounts::program::Program<Wrapper> =
            anchor_lang::Accounts::try_accounts(program_id, accounts, ix_data, __bumps, __reallocs)
                .map_err(|e| e.with_account_name("candy_wrapper"))?;
        let gummyroll_program: anchor_lang::accounts::program::Program<SplCompression> =
            anchor_lang::Accounts::try_accounts(program_id, accounts, ix_data, __bumps, __reallocs)
                .map_err(|e| e.with_account_name("gummyroll_program"))?;
        let merkle_slab: UncheckedAccount =
            anchor_lang::Accounts::try_accounts(program_id, accounts, ix_data, __bumps, __reallocs)
                .map_err(|e| e.with_account_name("merkle_slab"))?;
        let (__pda_address, __bump) =
            Pubkey::find_program_address(&[merkle_slab.key().as_ref()], &program_id);
        __bumps.insert("authority".to_string(), __bump);
        if authority.key() != __pda_address {
            return Err(anchor_lang::error::Error::from(
                anchor_lang::error::ErrorCode::ConstraintSeeds,
            )
            .with_account_name("authority")
            .with_pubkeys((authority.key(), __pda_address)));
        }
        if !merkle_slab.to_account_info().is_writable {
            return Err(anchor_lang::error::Error::from(
                anchor_lang::error::ErrorCode::ConstraintMut,
            )
            .with_account_name("merkle_slab"));
        }
        Ok(CreatorVerification {
            authority,
            owner,
            delegate,
            creator,
            candy_wrapper,
            gummyroll_program,
            merkle_slab,
        })
    }
}
#[automatically_derived]
impl<'info> anchor_lang::ToAccountInfos<'info> for CreatorVerification<'info>
where
    'info: 'info,
{
    fn to_account_infos(
        &self,
    ) -> Vec<anchor_lang::solana_program::account_info::AccountInfo<'info>> {
        let mut account_infos = ::alloc::vec::Vec::new();
        account_infos.extend(self.authority.to_account_infos());
        account_infos.extend(self.owner.to_account_infos());
        account_infos.extend(self.delegate.to_account_infos());
        account_infos.extend(self.creator.to_account_infos());
        account_infos.extend(self.candy_wrapper.to_account_infos());
        account_infos.extend(self.gummyroll_program.to_account_infos());
        account_infos.extend(self.merkle_slab.to_account_infos());
        account_infos
    }
}
#[automatically_derived]
impl<'info> anchor_lang::ToAccountMetas for CreatorVerification<'info> {
    fn to_account_metas(
        &self,
        is_signer: Option<bool>,
    ) -> Vec<anchor_lang::solana_program::instruction::AccountMeta> {
        let mut account_metas = ::alloc::vec::Vec::new();
        account_metas.extend(self.authority.to_account_metas(None));
        account_metas.extend(self.owner.to_account_metas(None));
        account_metas.extend(self.delegate.to_account_metas(None));
        account_metas.extend(self.creator.to_account_metas(None));
        account_metas.extend(self.candy_wrapper.to_account_metas(None));
        account_metas.extend(self.gummyroll_program.to_account_metas(None));
        account_metas.extend(self.merkle_slab.to_account_metas(None));
        account_metas
    }
}
#[automatically_derived]
impl<'info> anchor_lang::AccountsExit<'info> for CreatorVerification<'info>
where
    'info: 'info,
{
    fn exit(
        &self,
        program_id: &anchor_lang::solana_program::pubkey::Pubkey,
    ) -> anchor_lang::Result<()> {
        anchor_lang::AccountsExit::exit(&self.merkle_slab, program_id)
            .map_err(|e| e.with_account_name("merkle_slab"))?;
        Ok(())
    }
}
/// An internal, Anchor generated module. This is used (as an
/// implementation detail), to generate a struct for a given
/// `#[derive(Accounts)]` implementation, where each field is a Pubkey,
/// instead of an `AccountInfo`. This is useful for clients that want
/// to generate a list of accounts, without explicitly knowing the
/// order all the fields should be in.
///
/// To access the struct in this module, one should use the sibling
/// `accounts` module (also generated), which re-exports this.
pub(crate) mod __client_accounts_creator_verification {
    use super::*;
    use anchor_lang::prelude::borsh;
    /// Generated client accounts for [`CreatorVerification`].
    pub struct CreatorVerification {
        pub authority: anchor_lang::solana_program::pubkey::Pubkey,
        pub owner: anchor_lang::solana_program::pubkey::Pubkey,
        pub delegate: anchor_lang::solana_program::pubkey::Pubkey,
        pub creator: anchor_lang::solana_program::pubkey::Pubkey,
        pub candy_wrapper: anchor_lang::solana_program::pubkey::Pubkey,
        pub gummyroll_program: anchor_lang::solana_program::pubkey::Pubkey,
        pub merkle_slab: anchor_lang::solana_program::pubkey::Pubkey,
    }
    impl borsh::ser::BorshSerialize for CreatorVerification
    where
        anchor_lang::solana_program::pubkey::Pubkey: borsh::ser::BorshSerialize,
        anchor_lang::solana_program::pubkey::Pubkey: borsh::ser::BorshSerialize,
        anchor_lang::solana_program::pubkey::Pubkey: borsh::ser::BorshSerialize,
        anchor_lang::solana_program::pubkey::Pubkey: borsh::ser::BorshSerialize,
        anchor_lang::solana_program::pubkey::Pubkey: borsh::ser::BorshSerialize,
        anchor_lang::solana_program::pubkey::Pubkey: borsh::ser::BorshSerialize,
        anchor_lang::solana_program::pubkey::Pubkey: borsh::ser::BorshSerialize,
    {
        fn serialize<W: borsh::maybestd::io::Write>(
            &self,
            writer: &mut W,
        ) -> ::core::result::Result<(), borsh::maybestd::io::Error> {
            borsh::BorshSerialize::serialize(&self.authority, writer)?;
            borsh::BorshSerialize::serialize(&self.owner, writer)?;
            borsh::BorshSerialize::serialize(&self.delegate, writer)?;
            borsh::BorshSerialize::serialize(&self.creator, writer)?;
            borsh::BorshSerialize::serialize(&self.candy_wrapper, writer)?;
            borsh::BorshSerialize::serialize(&self.gummyroll_program, writer)?;
            borsh::BorshSerialize::serialize(&self.merkle_slab, writer)?;
            Ok(())
        }
    }
    #[automatically_derived]
    impl anchor_lang::ToAccountMetas for CreatorVerification {
        fn to_account_metas(
            &self,
            is_signer: Option<bool>,
        ) -> Vec<anchor_lang::solana_program::instruction::AccountMeta> {
            let mut account_metas = ::alloc::vec::Vec::new();
            account_metas.push(
                anchor_lang::solana_program::instruction::AccountMeta::new_readonly(
                    self.authority,
                    false,
                ),
            );
            account_metas.push(
                anchor_lang::solana_program::instruction::AccountMeta::new_readonly(
                    self.owner, false,
                ),
            );
            account_metas.push(
                anchor_lang::solana_program::instruction::AccountMeta::new_readonly(
                    self.delegate,
                    false,
                ),
            );
            account_metas.push(
                anchor_lang::solana_program::instruction::AccountMeta::new_readonly(
                    self.creator,
                    true,
                ),
            );
            account_metas.push(
                anchor_lang::solana_program::instruction::AccountMeta::new_readonly(
                    self.candy_wrapper,
                    false,
                ),
            );
            account_metas.push(
                anchor_lang::solana_program::instruction::AccountMeta::new_readonly(
                    self.gummyroll_program,
                    false,
                ),
            );
            account_metas.push(anchor_lang::solana_program::instruction::AccountMeta::new(
                self.merkle_slab,
                false,
            ));
            account_metas
        }
    }
}
/// An internal, Anchor generated module. This is used (as an
/// implementation detail), to generate a CPI struct for a given
/// `#[derive(Accounts)]` implementation, where each field is an
/// AccountInfo.
///
/// To access the struct in this module, one should use the sibling
/// [`cpi::accounts`] module (also generated), which re-exports this.
pub(crate) mod __cpi_client_accounts_creator_verification {
    use super::*;
    /// Generated CPI struct of the accounts for [`CreatorVerification`].
    pub struct CreatorVerification<'info> {
        pub authority: anchor_lang::solana_program::account_info::AccountInfo<'info>,
        pub owner: anchor_lang::solana_program::account_info::AccountInfo<'info>,
        pub delegate: anchor_lang::solana_program::account_info::AccountInfo<'info>,
        pub creator: anchor_lang::solana_program::account_info::AccountInfo<'info>,
        pub candy_wrapper: anchor_lang::solana_program::account_info::AccountInfo<'info>,
        pub gummyroll_program: anchor_lang::solana_program::account_info::AccountInfo<'info>,
        pub merkle_slab: anchor_lang::solana_program::account_info::AccountInfo<'info>,
    }
    #[automatically_derived]
    impl<'info> anchor_lang::ToAccountMetas for CreatorVerification<'info> {
        fn to_account_metas(
            &self,
            is_signer: Option<bool>,
        ) -> Vec<anchor_lang::solana_program::instruction::AccountMeta> {
            let mut account_metas = ::alloc::vec::Vec::new();
            account_metas.push(
                anchor_lang::solana_program::instruction::AccountMeta::new_readonly(
                    anchor_lang::Key::key(&self.authority),
                    false,
                ),
            );
            account_metas.push(
                anchor_lang::solana_program::instruction::AccountMeta::new_readonly(
                    anchor_lang::Key::key(&self.owner),
                    false,
                ),
            );
            account_metas.push(
                anchor_lang::solana_program::instruction::AccountMeta::new_readonly(
                    anchor_lang::Key::key(&self.delegate),
                    false,
                ),
            );
            account_metas.push(
                anchor_lang::solana_program::instruction::AccountMeta::new_readonly(
                    anchor_lang::Key::key(&self.creator),
                    true,
                ),
            );
            account_metas.push(
                anchor_lang::solana_program::instruction::AccountMeta::new_readonly(
                    anchor_lang::Key::key(&self.candy_wrapper),
                    false,
                ),
            );
            account_metas.push(
                anchor_lang::solana_program::instruction::AccountMeta::new_readonly(
                    anchor_lang::Key::key(&self.gummyroll_program),
                    false,
                ),
            );
            account_metas.push(anchor_lang::solana_program::instruction::AccountMeta::new(
                anchor_lang::Key::key(&self.merkle_slab),
                false,
            ));
            account_metas
        }
    }
    #[automatically_derived]
    impl<'info> anchor_lang::ToAccountInfos<'info> for CreatorVerification<'info> {
        fn to_account_infos(
            &self,
        ) -> Vec<anchor_lang::solana_program::account_info::AccountInfo<'info>> {
            let mut account_infos = ::alloc::vec::Vec::new();
            account_infos.push(anchor_lang::ToAccountInfo::to_account_info(&self.authority));
            account_infos.push(anchor_lang::ToAccountInfo::to_account_info(&self.owner));
            account_infos.push(anchor_lang::ToAccountInfo::to_account_info(&self.delegate));
            account_infos.push(anchor_lang::ToAccountInfo::to_account_info(&self.creator));
            account_infos.push(anchor_lang::ToAccountInfo::to_account_info(
                &self.candy_wrapper,
            ));
            account_infos.push(anchor_lang::ToAccountInfo::to_account_info(
                &self.gummyroll_program,
            ));
            account_infos.push(anchor_lang::ToAccountInfo::to_account_info(
                &self.merkle_slab,
            ));
            account_infos
        }
    }
}
pub struct Transfer<'info> {
    # [account (seeds = [merkle_slab . key () . as_ref ()] , bump ,)]
    /// CHECK: This account is neither written to nor read from.
    pub authority: Account<'info, TreeConfig>,
    /// CHECK: This account is checked in the instruction
    pub owner: UncheckedAccount<'info>,
    /// CHECK: This account is chekced in the instruction
    pub delegate: UncheckedAccount<'info>,
    /// CHECK: This account is neither written to nor read from.
    pub new_owner: UncheckedAccount<'info>,
    pub candy_wrapper: Program<'info, Wrapper>,
    pub gummyroll_program: Program<'info, SplCompression>,
    #[account(mut)]
    /// CHECK: This account is modified in the downstream program
    pub merkle_slab: UncheckedAccount<'info>,
}
#[automatically_derived]
impl<'info> anchor_lang::Accounts<'info> for Transfer<'info>
where
    'info: 'info,
{
    #[inline(never)]
    fn try_accounts(
        program_id: &anchor_lang::solana_program::pubkey::Pubkey,
        accounts: &mut &[anchor_lang::solana_program::account_info::AccountInfo<'info>],
        ix_data: &[u8],
        __bumps: &mut std::collections::BTreeMap<String, u8>,
        __reallocs: &mut std::collections::BTreeSet<anchor_lang::solana_program::pubkey::Pubkey>,
    ) -> anchor_lang::Result<Self> {
        let authority: anchor_lang::accounts::account::Account<TreeConfig> =
            anchor_lang::Accounts::try_accounts(program_id, accounts, ix_data, __bumps, __reallocs)
                .map_err(|e| e.with_account_name("authority"))?;
        let owner: UncheckedAccount =
            anchor_lang::Accounts::try_accounts(program_id, accounts, ix_data, __bumps, __reallocs)
                .map_err(|e| e.with_account_name("owner"))?;
        let delegate: UncheckedAccount =
            anchor_lang::Accounts::try_accounts(program_id, accounts, ix_data, __bumps, __reallocs)
                .map_err(|e| e.with_account_name("delegate"))?;
        let new_owner: UncheckedAccount =
            anchor_lang::Accounts::try_accounts(program_id, accounts, ix_data, __bumps, __reallocs)
                .map_err(|e| e.with_account_name("new_owner"))?;
        let candy_wrapper: anchor_lang::accounts::program::Program<Wrapper> =
            anchor_lang::Accounts::try_accounts(program_id, accounts, ix_data, __bumps, __reallocs)
                .map_err(|e| e.with_account_name("candy_wrapper"))?;
        let gummyroll_program: anchor_lang::accounts::program::Program<SplCompression> =
            anchor_lang::Accounts::try_accounts(program_id, accounts, ix_data, __bumps, __reallocs)
                .map_err(|e| e.with_account_name("gummyroll_program"))?;
        let merkle_slab: UncheckedAccount =
            anchor_lang::Accounts::try_accounts(program_id, accounts, ix_data, __bumps, __reallocs)
                .map_err(|e| e.with_account_name("merkle_slab"))?;
        let (__pda_address, __bump) =
            Pubkey::find_program_address(&[merkle_slab.key().as_ref()], &program_id);
        __bumps.insert("authority".to_string(), __bump);
        if authority.key() != __pda_address {
            return Err(anchor_lang::error::Error::from(
                anchor_lang::error::ErrorCode::ConstraintSeeds,
            )
            .with_account_name("authority")
            .with_pubkeys((authority.key(), __pda_address)));
        }
        if !merkle_slab.to_account_info().is_writable {
            return Err(anchor_lang::error::Error::from(
                anchor_lang::error::ErrorCode::ConstraintMut,
            )
            .with_account_name("merkle_slab"));
        }
        Ok(Transfer {
            authority,
            owner,
            delegate,
            new_owner,
            candy_wrapper,
            gummyroll_program,
            merkle_slab,
        })
    }
}
#[automatically_derived]
impl<'info> anchor_lang::ToAccountInfos<'info> for Transfer<'info>
where
    'info: 'info,
{
    fn to_account_infos(
        &self,
    ) -> Vec<anchor_lang::solana_program::account_info::AccountInfo<'info>> {
        let mut account_infos = ::alloc::vec::Vec::new();
        account_infos.extend(self.authority.to_account_infos());
        account_infos.extend(self.owner.to_account_infos());
        account_infos.extend(self.delegate.to_account_infos());
        account_infos.extend(self.new_owner.to_account_infos());
        account_infos.extend(self.candy_wrapper.to_account_infos());
        account_infos.extend(self.gummyroll_program.to_account_infos());
        account_infos.extend(self.merkle_slab.to_account_infos());
        account_infos
    }
}
#[automatically_derived]
impl<'info> anchor_lang::ToAccountMetas for Transfer<'info> {
    fn to_account_metas(
        &self,
        is_signer: Option<bool>,
    ) -> Vec<anchor_lang::solana_program::instruction::AccountMeta> {
        let mut account_metas = ::alloc::vec::Vec::new();
        account_metas.extend(self.authority.to_account_metas(None));
        account_metas.extend(self.owner.to_account_metas(None));
        account_metas.extend(self.delegate.to_account_metas(None));
        account_metas.extend(self.new_owner.to_account_metas(None));
        account_metas.extend(self.candy_wrapper.to_account_metas(None));
        account_metas.extend(self.gummyroll_program.to_account_metas(None));
        account_metas.extend(self.merkle_slab.to_account_metas(None));
        account_metas
    }
}
#[automatically_derived]
impl<'info> anchor_lang::AccountsExit<'info> for Transfer<'info>
where
    'info: 'info,
{
    fn exit(
        &self,
        program_id: &anchor_lang::solana_program::pubkey::Pubkey,
    ) -> anchor_lang::Result<()> {
        anchor_lang::AccountsExit::exit(&self.merkle_slab, program_id)
            .map_err(|e| e.with_account_name("merkle_slab"))?;
        Ok(())
    }
}
/// An internal, Anchor generated module. This is used (as an
/// implementation detail), to generate a struct for a given
/// `#[derive(Accounts)]` implementation, where each field is a Pubkey,
/// instead of an `AccountInfo`. This is useful for clients that want
/// to generate a list of accounts, without explicitly knowing the
/// order all the fields should be in.
///
/// To access the struct in this module, one should use the sibling
/// `accounts` module (also generated), which re-exports this.
pub(crate) mod __client_accounts_transfer {
    use super::*;
    use anchor_lang::prelude::borsh;
    /// Generated client accounts for [`Transfer`].
    pub struct Transfer {
        pub authority: anchor_lang::solana_program::pubkey::Pubkey,
        pub owner: anchor_lang::solana_program::pubkey::Pubkey,
        pub delegate: anchor_lang::solana_program::pubkey::Pubkey,
        pub new_owner: anchor_lang::solana_program::pubkey::Pubkey,
        pub candy_wrapper: anchor_lang::solana_program::pubkey::Pubkey,
        pub gummyroll_program: anchor_lang::solana_program::pubkey::Pubkey,
        pub merkle_slab: anchor_lang::solana_program::pubkey::Pubkey,
    }
    impl borsh::ser::BorshSerialize for Transfer
    where
        anchor_lang::solana_program::pubkey::Pubkey: borsh::ser::BorshSerialize,
        anchor_lang::solana_program::pubkey::Pubkey: borsh::ser::BorshSerialize,
        anchor_lang::solana_program::pubkey::Pubkey: borsh::ser::BorshSerialize,
        anchor_lang::solana_program::pubkey::Pubkey: borsh::ser::BorshSerialize,
        anchor_lang::solana_program::pubkey::Pubkey: borsh::ser::BorshSerialize,
        anchor_lang::solana_program::pubkey::Pubkey: borsh::ser::BorshSerialize,
        anchor_lang::solana_program::pubkey::Pubkey: borsh::ser::BorshSerialize,
    {
        fn serialize<W: borsh::maybestd::io::Write>(
            &self,
            writer: &mut W,
        ) -> ::core::result::Result<(), borsh::maybestd::io::Error> {
            borsh::BorshSerialize::serialize(&self.authority, writer)?;
            borsh::BorshSerialize::serialize(&self.owner, writer)?;
            borsh::BorshSerialize::serialize(&self.delegate, writer)?;
            borsh::BorshSerialize::serialize(&self.new_owner, writer)?;
            borsh::BorshSerialize::serialize(&self.candy_wrapper, writer)?;
            borsh::BorshSerialize::serialize(&self.gummyroll_program, writer)?;
            borsh::BorshSerialize::serialize(&self.merkle_slab, writer)?;
            Ok(())
        }
    }
    #[automatically_derived]
    impl anchor_lang::ToAccountMetas for Transfer {
        fn to_account_metas(
            &self,
            is_signer: Option<bool>,
        ) -> Vec<anchor_lang::solana_program::instruction::AccountMeta> {
            let mut account_metas = ::alloc::vec::Vec::new();
            account_metas.push(
                anchor_lang::solana_program::instruction::AccountMeta::new_readonly(
                    self.authority,
                    false,
                ),
            );
            account_metas.push(
                anchor_lang::solana_program::instruction::AccountMeta::new_readonly(
                    self.owner, false,
                ),
            );
            account_metas.push(
                anchor_lang::solana_program::instruction::AccountMeta::new_readonly(
                    self.delegate,
                    false,
                ),
            );
            account_metas.push(
                anchor_lang::solana_program::instruction::AccountMeta::new_readonly(
                    self.new_owner,
                    false,
                ),
            );
            account_metas.push(
                anchor_lang::solana_program::instruction::AccountMeta::new_readonly(
                    self.candy_wrapper,
                    false,
                ),
            );
            account_metas.push(
                anchor_lang::solana_program::instruction::AccountMeta::new_readonly(
                    self.gummyroll_program,
                    false,
                ),
            );
            account_metas.push(anchor_lang::solana_program::instruction::AccountMeta::new(
                self.merkle_slab,
                false,
            ));
            account_metas
        }
    }
}
/// An internal, Anchor generated module. This is used (as an
/// implementation detail), to generate a CPI struct for a given
/// `#[derive(Accounts)]` implementation, where each field is an
/// AccountInfo.
///
/// To access the struct in this module, one should use the sibling
/// [`cpi::accounts`] module (also generated), which re-exports this.
pub(crate) mod __cpi_client_accounts_transfer {
    use super::*;
    /// Generated CPI struct of the accounts for [`Transfer`].
    pub struct Transfer<'info> {
        pub authority: anchor_lang::solana_program::account_info::AccountInfo<'info>,
        pub owner: anchor_lang::solana_program::account_info::AccountInfo<'info>,
        pub delegate: anchor_lang::solana_program::account_info::AccountInfo<'info>,
        pub new_owner: anchor_lang::solana_program::account_info::AccountInfo<'info>,
        pub candy_wrapper: anchor_lang::solana_program::account_info::AccountInfo<'info>,
        pub gummyroll_program: anchor_lang::solana_program::account_info::AccountInfo<'info>,
        pub merkle_slab: anchor_lang::solana_program::account_info::AccountInfo<'info>,
    }
    #[automatically_derived]
    impl<'info> anchor_lang::ToAccountMetas for Transfer<'info> {
        fn to_account_metas(
            &self,
            is_signer: Option<bool>,
        ) -> Vec<anchor_lang::solana_program::instruction::AccountMeta> {
            let mut account_metas = ::alloc::vec::Vec::new();
            account_metas.push(
                anchor_lang::solana_program::instruction::AccountMeta::new_readonly(
                    anchor_lang::Key::key(&self.authority),
                    false,
                ),
            );
            account_metas.push(
                anchor_lang::solana_program::instruction::AccountMeta::new_readonly(
                    anchor_lang::Key::key(&self.owner),
                    false,
                ),
            );
            account_metas.push(
                anchor_lang::solana_program::instruction::AccountMeta::new_readonly(
                    anchor_lang::Key::key(&self.delegate),
                    false,
                ),
            );
            account_metas.push(
                anchor_lang::solana_program::instruction::AccountMeta::new_readonly(
                    anchor_lang::Key::key(&self.new_owner),
                    false,
                ),
            );
            account_metas.push(
                anchor_lang::solana_program::instruction::AccountMeta::new_readonly(
                    anchor_lang::Key::key(&self.candy_wrapper),
                    false,
                ),
            );
            account_metas.push(
                anchor_lang::solana_program::instruction::AccountMeta::new_readonly(
                    anchor_lang::Key::key(&self.gummyroll_program),
                    false,
                ),
            );
            account_metas.push(anchor_lang::solana_program::instruction::AccountMeta::new(
                anchor_lang::Key::key(&self.merkle_slab),
                false,
            ));
            account_metas
        }
    }
    #[automatically_derived]
    impl<'info> anchor_lang::ToAccountInfos<'info> for Transfer<'info> {
        fn to_account_infos(
            &self,
        ) -> Vec<anchor_lang::solana_program::account_info::AccountInfo<'info>> {
            let mut account_infos = ::alloc::vec::Vec::new();
            account_infos.push(anchor_lang::ToAccountInfo::to_account_info(&self.authority));
            account_infos.push(anchor_lang::ToAccountInfo::to_account_info(&self.owner));
            account_infos.push(anchor_lang::ToAccountInfo::to_account_info(&self.delegate));
            account_infos.push(anchor_lang::ToAccountInfo::to_account_info(&self.new_owner));
            account_infos.push(anchor_lang::ToAccountInfo::to_account_info(
                &self.candy_wrapper,
            ));
            account_infos.push(anchor_lang::ToAccountInfo::to_account_info(
                &self.gummyroll_program,
            ));
            account_infos.push(anchor_lang::ToAccountInfo::to_account_info(
                &self.merkle_slab,
            ));
            account_infos
        }
    }
}
pub struct Delegate<'info> {
    # [account (seeds = [merkle_slab . key () . as_ref ()] , bump ,)]
    /// CHECK: This account is neither written to nor read from.
    pub authority: Account<'info, TreeConfig>,
    pub owner: Signer<'info>,
    /// CHECK: This account is neither written to nor read from.
    pub previous_delegate: UncheckedAccount<'info>,
    /// CHECK: This account is neither written to nor read from.
    pub new_delegate: UncheckedAccount<'info>,
    pub candy_wrapper: Program<'info, Wrapper>,
    pub gummyroll_program: Program<'info, SplCompression>,
    #[account(mut)]
    /// CHECK: This account is modified in the downstream program
    pub merkle_slab: UncheckedAccount<'info>,
}
#[automatically_derived]
impl<'info> anchor_lang::Accounts<'info> for Delegate<'info>
where
    'info: 'info,
{
    #[inline(never)]
    fn try_accounts(
        program_id: &anchor_lang::solana_program::pubkey::Pubkey,
        accounts: &mut &[anchor_lang::solana_program::account_info::AccountInfo<'info>],
        ix_data: &[u8],
        __bumps: &mut std::collections::BTreeMap<String, u8>,
        __reallocs: &mut std::collections::BTreeSet<anchor_lang::solana_program::pubkey::Pubkey>,
    ) -> anchor_lang::Result<Self> {
        let authority: anchor_lang::accounts::account::Account<TreeConfig> =
            anchor_lang::Accounts::try_accounts(program_id, accounts, ix_data, __bumps, __reallocs)
                .map_err(|e| e.with_account_name("authority"))?;
        let owner: Signer =
            anchor_lang::Accounts::try_accounts(program_id, accounts, ix_data, __bumps, __reallocs)
                .map_err(|e| e.with_account_name("owner"))?;
        let previous_delegate: UncheckedAccount =
            anchor_lang::Accounts::try_accounts(program_id, accounts, ix_data, __bumps, __reallocs)
                .map_err(|e| e.with_account_name("previous_delegate"))?;
        let new_delegate: UncheckedAccount =
            anchor_lang::Accounts::try_accounts(program_id, accounts, ix_data, __bumps, __reallocs)
                .map_err(|e| e.with_account_name("new_delegate"))?;
        let candy_wrapper: anchor_lang::accounts::program::Program<Wrapper> =
            anchor_lang::Accounts::try_accounts(program_id, accounts, ix_data, __bumps, __reallocs)
                .map_err(|e| e.with_account_name("candy_wrapper"))?;
        let gummyroll_program: anchor_lang::accounts::program::Program<SplCompression> =
            anchor_lang::Accounts::try_accounts(program_id, accounts, ix_data, __bumps, __reallocs)
                .map_err(|e| e.with_account_name("gummyroll_program"))?;
        let merkle_slab: UncheckedAccount =
            anchor_lang::Accounts::try_accounts(program_id, accounts, ix_data, __bumps, __reallocs)
                .map_err(|e| e.with_account_name("merkle_slab"))?;
        let (__pda_address, __bump) =
            Pubkey::find_program_address(&[merkle_slab.key().as_ref()], &program_id);
        __bumps.insert("authority".to_string(), __bump);
        if authority.key() != __pda_address {
            return Err(anchor_lang::error::Error::from(
                anchor_lang::error::ErrorCode::ConstraintSeeds,
            )
            .with_account_name("authority")
            .with_pubkeys((authority.key(), __pda_address)));
        }
        if !merkle_slab.to_account_info().is_writable {
            return Err(anchor_lang::error::Error::from(
                anchor_lang::error::ErrorCode::ConstraintMut,
            )
            .with_account_name("merkle_slab"));
        }
        Ok(Delegate {
            authority,
            owner,
            previous_delegate,
            new_delegate,
            candy_wrapper,
            gummyroll_program,
            merkle_slab,
        })
    }
}
#[automatically_derived]
impl<'info> anchor_lang::ToAccountInfos<'info> for Delegate<'info>
where
    'info: 'info,
{
    fn to_account_infos(
        &self,
    ) -> Vec<anchor_lang::solana_program::account_info::AccountInfo<'info>> {
        let mut account_infos = ::alloc::vec::Vec::new();
        account_infos.extend(self.authority.to_account_infos());
        account_infos.extend(self.owner.to_account_infos());
        account_infos.extend(self.previous_delegate.to_account_infos());
        account_infos.extend(self.new_delegate.to_account_infos());
        account_infos.extend(self.candy_wrapper.to_account_infos());
        account_infos.extend(self.gummyroll_program.to_account_infos());
        account_infos.extend(self.merkle_slab.to_account_infos());
        account_infos
    }
}
#[automatically_derived]
impl<'info> anchor_lang::ToAccountMetas for Delegate<'info> {
    fn to_account_metas(
        &self,
        is_signer: Option<bool>,
    ) -> Vec<anchor_lang::solana_program::instruction::AccountMeta> {
        let mut account_metas = ::alloc::vec::Vec::new();
        account_metas.extend(self.authority.to_account_metas(None));
        account_metas.extend(self.owner.to_account_metas(None));
        account_metas.extend(self.previous_delegate.to_account_metas(None));
        account_metas.extend(self.new_delegate.to_account_metas(None));
        account_metas.extend(self.candy_wrapper.to_account_metas(None));
        account_metas.extend(self.gummyroll_program.to_account_metas(None));
        account_metas.extend(self.merkle_slab.to_account_metas(None));
        account_metas
    }
}
#[automatically_derived]
impl<'info> anchor_lang::AccountsExit<'info> for Delegate<'info>
where
    'info: 'info,
{
    fn exit(
        &self,
        program_id: &anchor_lang::solana_program::pubkey::Pubkey,
    ) -> anchor_lang::Result<()> {
        anchor_lang::AccountsExit::exit(&self.merkle_slab, program_id)
            .map_err(|e| e.with_account_name("merkle_slab"))?;
        Ok(())
    }
}
/// An internal, Anchor generated module. This is used (as an
/// implementation detail), to generate a struct for a given
/// `#[derive(Accounts)]` implementation, where each field is a Pubkey,
/// instead of an `AccountInfo`. This is useful for clients that want
/// to generate a list of accounts, without explicitly knowing the
/// order all the fields should be in.
///
/// To access the struct in this module, one should use the sibling
/// `accounts` module (also generated), which re-exports this.
pub(crate) mod __client_accounts_delegate {
    use super::*;
    use anchor_lang::prelude::borsh;
    /// Generated client accounts for [`Delegate`].
    pub struct Delegate {
        pub authority: anchor_lang::solana_program::pubkey::Pubkey,
        pub owner: anchor_lang::solana_program::pubkey::Pubkey,
        pub previous_delegate: anchor_lang::solana_program::pubkey::Pubkey,
        pub new_delegate: anchor_lang::solana_program::pubkey::Pubkey,
        pub candy_wrapper: anchor_lang::solana_program::pubkey::Pubkey,
        pub gummyroll_program: anchor_lang::solana_program::pubkey::Pubkey,
        pub merkle_slab: anchor_lang::solana_program::pubkey::Pubkey,
    }
    impl borsh::ser::BorshSerialize for Delegate
    where
        anchor_lang::solana_program::pubkey::Pubkey: borsh::ser::BorshSerialize,
        anchor_lang::solana_program::pubkey::Pubkey: borsh::ser::BorshSerialize,
        anchor_lang::solana_program::pubkey::Pubkey: borsh::ser::BorshSerialize,
        anchor_lang::solana_program::pubkey::Pubkey: borsh::ser::BorshSerialize,
        anchor_lang::solana_program::pubkey::Pubkey: borsh::ser::BorshSerialize,
        anchor_lang::solana_program::pubkey::Pubkey: borsh::ser::BorshSerialize,
        anchor_lang::solana_program::pubkey::Pubkey: borsh::ser::BorshSerialize,
    {
        fn serialize<W: borsh::maybestd::io::Write>(
            &self,
            writer: &mut W,
        ) -> ::core::result::Result<(), borsh::maybestd::io::Error> {
            borsh::BorshSerialize::serialize(&self.authority, writer)?;
            borsh::BorshSerialize::serialize(&self.owner, writer)?;
            borsh::BorshSerialize::serialize(&self.previous_delegate, writer)?;
            borsh::BorshSerialize::serialize(&self.new_delegate, writer)?;
            borsh::BorshSerialize::serialize(&self.candy_wrapper, writer)?;
            borsh::BorshSerialize::serialize(&self.gummyroll_program, writer)?;
            borsh::BorshSerialize::serialize(&self.merkle_slab, writer)?;
            Ok(())
        }
    }
    #[automatically_derived]
    impl anchor_lang::ToAccountMetas for Delegate {
        fn to_account_metas(
            &self,
            is_signer: Option<bool>,
        ) -> Vec<anchor_lang::solana_program::instruction::AccountMeta> {
            let mut account_metas = ::alloc::vec::Vec::new();
            account_metas.push(
                anchor_lang::solana_program::instruction::AccountMeta::new_readonly(
                    self.authority,
                    false,
                ),
            );
            account_metas.push(
                anchor_lang::solana_program::instruction::AccountMeta::new_readonly(
                    self.owner, true,
                ),
            );
            account_metas.push(
                anchor_lang::solana_program::instruction::AccountMeta::new_readonly(
                    self.previous_delegate,
                    false,
                ),
            );
            account_metas.push(
                anchor_lang::solana_program::instruction::AccountMeta::new_readonly(
                    self.new_delegate,
                    false,
                ),
            );
            account_metas.push(
                anchor_lang::solana_program::instruction::AccountMeta::new_readonly(
                    self.candy_wrapper,
                    false,
                ),
            );
            account_metas.push(
                anchor_lang::solana_program::instruction::AccountMeta::new_readonly(
                    self.gummyroll_program,
                    false,
                ),
            );
            account_metas.push(anchor_lang::solana_program::instruction::AccountMeta::new(
                self.merkle_slab,
                false,
            ));
            account_metas
        }
    }
}
/// An internal, Anchor generated module. This is used (as an
/// implementation detail), to generate a CPI struct for a given
/// `#[derive(Accounts)]` implementation, where each field is an
/// AccountInfo.
///
/// To access the struct in this module, one should use the sibling
/// [`cpi::accounts`] module (also generated), which re-exports this.
pub(crate) mod __cpi_client_accounts_delegate {
    use super::*;
    /// Generated CPI struct of the accounts for [`Delegate`].
    pub struct Delegate<'info> {
        pub authority: anchor_lang::solana_program::account_info::AccountInfo<'info>,
        pub owner: anchor_lang::solana_program::account_info::AccountInfo<'info>,
        pub previous_delegate: anchor_lang::solana_program::account_info::AccountInfo<'info>,
        pub new_delegate: anchor_lang::solana_program::account_info::AccountInfo<'info>,
        pub candy_wrapper: anchor_lang::solana_program::account_info::AccountInfo<'info>,
        pub gummyroll_program: anchor_lang::solana_program::account_info::AccountInfo<'info>,
        pub merkle_slab: anchor_lang::solana_program::account_info::AccountInfo<'info>,
    }
    #[automatically_derived]
    impl<'info> anchor_lang::ToAccountMetas for Delegate<'info> {
        fn to_account_metas(
            &self,
            is_signer: Option<bool>,
        ) -> Vec<anchor_lang::solana_program::instruction::AccountMeta> {
            let mut account_metas = ::alloc::vec::Vec::new();
            account_metas.push(
                anchor_lang::solana_program::instruction::AccountMeta::new_readonly(
                    anchor_lang::Key::key(&self.authority),
                    false,
                ),
            );
            account_metas.push(
                anchor_lang::solana_program::instruction::AccountMeta::new_readonly(
                    anchor_lang::Key::key(&self.owner),
                    true,
                ),
            );
            account_metas.push(
                anchor_lang::solana_program::instruction::AccountMeta::new_readonly(
                    anchor_lang::Key::key(&self.previous_delegate),
                    false,
                ),
            );
            account_metas.push(
                anchor_lang::solana_program::instruction::AccountMeta::new_readonly(
                    anchor_lang::Key::key(&self.new_delegate),
                    false,
                ),
            );
            account_metas.push(
                anchor_lang::solana_program::instruction::AccountMeta::new_readonly(
                    anchor_lang::Key::key(&self.candy_wrapper),
                    false,
                ),
            );
            account_metas.push(
                anchor_lang::solana_program::instruction::AccountMeta::new_readonly(
                    anchor_lang::Key::key(&self.gummyroll_program),
                    false,
                ),
            );
            account_metas.push(anchor_lang::solana_program::instruction::AccountMeta::new(
                anchor_lang::Key::key(&self.merkle_slab),
                false,
            ));
            account_metas
        }
    }
    #[automatically_derived]
    impl<'info> anchor_lang::ToAccountInfos<'info> for Delegate<'info> {
        fn to_account_infos(
            &self,
        ) -> Vec<anchor_lang::solana_program::account_info::AccountInfo<'info>> {
            let mut account_infos = ::alloc::vec::Vec::new();
            account_infos.push(anchor_lang::ToAccountInfo::to_account_info(&self.authority));
            account_infos.push(anchor_lang::ToAccountInfo::to_account_info(&self.owner));
            account_infos.push(anchor_lang::ToAccountInfo::to_account_info(
                &self.previous_delegate,
            ));
            account_infos.push(anchor_lang::ToAccountInfo::to_account_info(
                &self.new_delegate,
            ));
            account_infos.push(anchor_lang::ToAccountInfo::to_account_info(
                &self.candy_wrapper,
            ));
            account_infos.push(anchor_lang::ToAccountInfo::to_account_info(
                &self.gummyroll_program,
            ));
            account_infos.push(anchor_lang::ToAccountInfo::to_account_info(
                &self.merkle_slab,
            ));
            account_infos
        }
    }
}
# [instruction (_root : [u8 ; 32] , _data_hash : [u8 ; 32] , _creator_hash : [u8 ; 32] , nonce : u64 , _index : u32 ,)]
pub struct Redeem<'info> {
    # [account (seeds = [merkle_slab . key () . as_ref ()] , bump ,)]
    /// CHECK: This account is neither written to nor read from.
    pub authority: Account<'info, TreeConfig>,
    pub candy_wrapper: Program<'info, Wrapper>,
    pub gummyroll_program: Program<'info, SplCompression>,
    #[account(mut)]
    pub owner: Signer<'info>,
    /// CHECK: This account is chekced in the instruction
    pub delegate: UncheckedAccount<'info>,
    #[account(mut)]
    /// CHECK: checked in cpi
    pub merkle_slab: UncheckedAccount<'info>,
    # [account (init , seeds = [VOUCHER_PREFIX . as_ref () , merkle_slab . key () . as_ref () , & nonce . to_le_bytes ()] , payer = owner , space = VOUCHER_SIZE , bump)]
    pub voucher: Account<'info, Voucher>,
    pub system_program: Program<'info, System>,
}
#[automatically_derived]
impl<'info> anchor_lang::Accounts<'info> for Redeem<'info>
where
    'info: 'info,
{
    #[inline(never)]
    fn try_accounts(
        program_id: &anchor_lang::solana_program::pubkey::Pubkey,
        accounts: &mut &[anchor_lang::solana_program::account_info::AccountInfo<'info>],
        ix_data: &[u8],
        __bumps: &mut std::collections::BTreeMap<String, u8>,
        __reallocs: &mut std::collections::BTreeSet<anchor_lang::solana_program::pubkey::Pubkey>,
    ) -> anchor_lang::Result<Self> {
        let mut ix_data = ix_data;
        struct __Args {
            _root: [u8; 32],
            _data_hash: [u8; 32],
            _creator_hash: [u8; 32],
            nonce: u64,
            _index: u32,
        }
        impl borsh::ser::BorshSerialize for __Args
        where
            [u8; 32]: borsh::ser::BorshSerialize,
            [u8; 32]: borsh::ser::BorshSerialize,
            [u8; 32]: borsh::ser::BorshSerialize,
            u64: borsh::ser::BorshSerialize,
            u32: borsh::ser::BorshSerialize,
        {
            fn serialize<W: borsh::maybestd::io::Write>(
                &self,
                writer: &mut W,
            ) -> ::core::result::Result<(), borsh::maybestd::io::Error> {
                borsh::BorshSerialize::serialize(&self._root, writer)?;
                borsh::BorshSerialize::serialize(&self._data_hash, writer)?;
                borsh::BorshSerialize::serialize(&self._creator_hash, writer)?;
                borsh::BorshSerialize::serialize(&self.nonce, writer)?;
                borsh::BorshSerialize::serialize(&self._index, writer)?;
                Ok(())
            }
        }
        impl borsh::de::BorshDeserialize for __Args
        where
            [u8; 32]: borsh::BorshDeserialize,
            [u8; 32]: borsh::BorshDeserialize,
            [u8; 32]: borsh::BorshDeserialize,
            u64: borsh::BorshDeserialize,
            u32: borsh::BorshDeserialize,
        {
            fn deserialize(
                buf: &mut &[u8],
            ) -> ::core::result::Result<Self, borsh::maybestd::io::Error> {
                Ok(Self {
                    _root: borsh::BorshDeserialize::deserialize(buf)?,
                    _data_hash: borsh::BorshDeserialize::deserialize(buf)?,
                    _creator_hash: borsh::BorshDeserialize::deserialize(buf)?,
                    nonce: borsh::BorshDeserialize::deserialize(buf)?,
                    _index: borsh::BorshDeserialize::deserialize(buf)?,
                })
            }
        }
        let __Args {
            _root,
            _data_hash,
            _creator_hash,
            nonce,
            _index,
        } = __Args::deserialize(&mut ix_data)
            .map_err(|_| anchor_lang::error::ErrorCode::InstructionDidNotDeserialize)?;
        let authority: anchor_lang::accounts::account::Account<TreeConfig> =
            anchor_lang::Accounts::try_accounts(program_id, accounts, ix_data, __bumps, __reallocs)
                .map_err(|e| e.with_account_name("authority"))?;
        let candy_wrapper: anchor_lang::accounts::program::Program<Wrapper> =
            anchor_lang::Accounts::try_accounts(program_id, accounts, ix_data, __bumps, __reallocs)
                .map_err(|e| e.with_account_name("candy_wrapper"))?;
        let gummyroll_program: anchor_lang::accounts::program::Program<SplCompression> =
            anchor_lang::Accounts::try_accounts(program_id, accounts, ix_data, __bumps, __reallocs)
                .map_err(|e| e.with_account_name("gummyroll_program"))?;
        let owner: Signer =
            anchor_lang::Accounts::try_accounts(program_id, accounts, ix_data, __bumps, __reallocs)
                .map_err(|e| e.with_account_name("owner"))?;
        let delegate: UncheckedAccount =
            anchor_lang::Accounts::try_accounts(program_id, accounts, ix_data, __bumps, __reallocs)
                .map_err(|e| e.with_account_name("delegate"))?;
        let merkle_slab: UncheckedAccount =
            anchor_lang::Accounts::try_accounts(program_id, accounts, ix_data, __bumps, __reallocs)
                .map_err(|e| e.with_account_name("merkle_slab"))?;
        if accounts.is_empty() {
            return Err(anchor_lang::error::ErrorCode::AccountNotEnoughKeys.into());
        }
        let voucher = &accounts[0];
        *accounts = &accounts[1..];
        let system_program: anchor_lang::accounts::program::Program<System> =
            anchor_lang::Accounts::try_accounts(program_id, accounts, ix_data, __bumps, __reallocs)
                .map_err(|e| e.with_account_name("system_program"))?;
        let __anchor_rent = Rent::get()?;
        let (__pda_address, __bump) = Pubkey::find_program_address(
            &[
                VOUCHER_PREFIX.as_ref(),
                merkle_slab.key().as_ref(),
                &nonce.to_le_bytes(),
            ],
            program_id,
        );
        __bumps.insert("voucher".to_string(), __bump);
        let voucher = {
            let actual_field = voucher.to_account_info();
            let actual_owner = actual_field.owner;
            let space = VOUCHER_SIZE;
            let pa: anchor_lang::accounts::account::Account<Voucher> =
                if !false || actual_owner == &anchor_lang::solana_program::system_program::ID {
                    let payer = owner.to_account_info();
                    let __current_lamports = voucher.lamports();
                    if __current_lamports == 0 {
                        let lamports = __anchor_rent.minimum_balance(space);
                        let cpi_accounts = anchor_lang::system_program::CreateAccount {
                            from: payer.to_account_info(),
                            to: voucher.to_account_info(),
                        };
                        let cpi_context = anchor_lang::context::CpiContext::new(
                            system_program.to_account_info(),
                            cpi_accounts,
                        );
                        anchor_lang::system_program::create_account(
                            cpi_context.with_signer(&[&[
                                VOUCHER_PREFIX.as_ref(),
                                merkle_slab.key().as_ref(),
                                &nonce.to_le_bytes(),
                                &[__bump][..],
                            ][..]]),
                            lamports,
                            space as u64,
                            program_id,
                        )?;
                    } else {
                        let required_lamports = __anchor_rent
                            .minimum_balance(space)
                            .max(1)
                            .saturating_sub(__current_lamports);
                        if required_lamports > 0 {
                            let cpi_accounts = anchor_lang::system_program::Transfer {
                                from: payer.to_account_info(),
                                to: voucher.to_account_info(),
                            };
                            let cpi_context = anchor_lang::context::CpiContext::new(
                                system_program.to_account_info(),
                                cpi_accounts,
                            );
                            anchor_lang::system_program::transfer(cpi_context, required_lamports)?;
                        }
                        let cpi_accounts = anchor_lang::system_program::Allocate {
                            account_to_allocate: voucher.to_account_info(),
                        };
                        let cpi_context = anchor_lang::context::CpiContext::new(
                            system_program.to_account_info(),
                            cpi_accounts,
                        );
                        anchor_lang::system_program::allocate(
                            cpi_context.with_signer(&[&[
                                VOUCHER_PREFIX.as_ref(),
                                merkle_slab.key().as_ref(),
                                &nonce.to_le_bytes(),
                                &[__bump][..],
                            ][..]]),
                            space as u64,
                        )?;
                        let cpi_accounts = anchor_lang::system_program::Assign {
                            account_to_assign: voucher.to_account_info(),
                        };
                        let cpi_context = anchor_lang::context::CpiContext::new(
                            system_program.to_account_info(),
                            cpi_accounts,
                        );
                        anchor_lang::system_program::assign(
                            cpi_context.with_signer(&[&[
                                VOUCHER_PREFIX.as_ref(),
                                merkle_slab.key().as_ref(),
                                &nonce.to_le_bytes(),
                                &[__bump][..],
                            ][..]]),
                            program_id,
                        )?;
                    }
                    anchor_lang::accounts::account::Account::try_from_unchecked(&voucher)
                        .map_err(|e| e.with_account_name("voucher"))?
                } else {
                    anchor_lang::accounts::account::Account::try_from(&voucher)
                        .map_err(|e| e.with_account_name("voucher"))?
                };
            if false {
                if space != actual_field.data_len() {
                    return Err(anchor_lang::error::Error::from(
                        anchor_lang::error::ErrorCode::ConstraintSpace,
                    )
                    .with_account_name("voucher")
                    .with_values((space, actual_field.data_len())));
                }
                if actual_owner != program_id {
                    return Err(anchor_lang::error::Error::from(
                        anchor_lang::error::ErrorCode::ConstraintOwner,
                    )
                    .with_account_name("voucher")
                    .with_pubkeys((*actual_owner, *program_id)));
                }
                {
                    let required_lamports = __anchor_rent.minimum_balance(space);
                    if pa.to_account_info().lamports() < required_lamports {
                        return Err(anchor_lang::error::Error::from(
                            anchor_lang::error::ErrorCode::ConstraintRentExempt,
                        )
                        .with_account_name("voucher"));
                    }
                }
            }
            pa
        };
        if voucher.key() != __pda_address {
            return Err(anchor_lang::error::Error::from(
                anchor_lang::error::ErrorCode::ConstraintSeeds,
            )
            .with_account_name("voucher")
            .with_pubkeys((voucher.key(), __pda_address)));
        }
        if !voucher.to_account_info().is_writable {
            return Err(anchor_lang::error::Error::from(
                anchor_lang::error::ErrorCode::ConstraintMut,
            )
            .with_account_name("voucher"));
        }
        if !__anchor_rent.is_exempt(
            voucher.to_account_info().lamports(),
            voucher.to_account_info().try_data_len()?,
        ) {
            return Err(anchor_lang::error::Error::from(
                anchor_lang::error::ErrorCode::ConstraintRentExempt,
            )
            .with_account_name("voucher"));
        }
        let (__pda_address, __bump) =
            Pubkey::find_program_address(&[merkle_slab.key().as_ref()], &program_id);
        __bumps.insert("authority".to_string(), __bump);
        if authority.key() != __pda_address {
            return Err(anchor_lang::error::Error::from(
                anchor_lang::error::ErrorCode::ConstraintSeeds,
            )
            .with_account_name("authority")
            .with_pubkeys((authority.key(), __pda_address)));
        }
        if !owner.to_account_info().is_writable {
            return Err(anchor_lang::error::Error::from(
                anchor_lang::error::ErrorCode::ConstraintMut,
            )
            .with_account_name("owner"));
        }
        if !merkle_slab.to_account_info().is_writable {
            return Err(anchor_lang::error::Error::from(
                anchor_lang::error::ErrorCode::ConstraintMut,
            )
            .with_account_name("merkle_slab"));
        }
        Ok(Redeem {
            authority,
            candy_wrapper,
            gummyroll_program,
            owner,
            delegate,
            merkle_slab,
            voucher,
            system_program,
        })
    }
}
#[automatically_derived]
impl<'info> anchor_lang::ToAccountInfos<'info> for Redeem<'info>
where
    'info: 'info,
{
    fn to_account_infos(
        &self,
    ) -> Vec<anchor_lang::solana_program::account_info::AccountInfo<'info>> {
        let mut account_infos = ::alloc::vec::Vec::new();
        account_infos.extend(self.authority.to_account_infos());
        account_infos.extend(self.candy_wrapper.to_account_infos());
        account_infos.extend(self.gummyroll_program.to_account_infos());
        account_infos.extend(self.owner.to_account_infos());
        account_infos.extend(self.delegate.to_account_infos());
        account_infos.extend(self.merkle_slab.to_account_infos());
        account_infos.extend(self.voucher.to_account_infos());
        account_infos.extend(self.system_program.to_account_infos());
        account_infos
    }
}
#[automatically_derived]
impl<'info> anchor_lang::ToAccountMetas for Redeem<'info> {
    fn to_account_metas(
        &self,
        is_signer: Option<bool>,
    ) -> Vec<anchor_lang::solana_program::instruction::AccountMeta> {
        let mut account_metas = ::alloc::vec::Vec::new();
        account_metas.extend(self.authority.to_account_metas(None));
        account_metas.extend(self.candy_wrapper.to_account_metas(None));
        account_metas.extend(self.gummyroll_program.to_account_metas(None));
        account_metas.extend(self.owner.to_account_metas(None));
        account_metas.extend(self.delegate.to_account_metas(None));
        account_metas.extend(self.merkle_slab.to_account_metas(None));
        account_metas.extend(self.voucher.to_account_metas(None));
        account_metas.extend(self.system_program.to_account_metas(None));
        account_metas
    }
}
#[automatically_derived]
impl<'info> anchor_lang::AccountsExit<'info> for Redeem<'info>
where
    'info: 'info,
{
    fn exit(
        &self,
        program_id: &anchor_lang::solana_program::pubkey::Pubkey,
    ) -> anchor_lang::Result<()> {
        anchor_lang::AccountsExit::exit(&self.owner, program_id)
            .map_err(|e| e.with_account_name("owner"))?;
        anchor_lang::AccountsExit::exit(&self.merkle_slab, program_id)
            .map_err(|e| e.with_account_name("merkle_slab"))?;
        anchor_lang::AccountsExit::exit(&self.voucher, program_id)
            .map_err(|e| e.with_account_name("voucher"))?;
        Ok(())
    }
}
/// An internal, Anchor generated module. This is used (as an
/// implementation detail), to generate a struct for a given
/// `#[derive(Accounts)]` implementation, where each field is a Pubkey,
/// instead of an `AccountInfo`. This is useful for clients that want
/// to generate a list of accounts, without explicitly knowing the
/// order all the fields should be in.
///
/// To access the struct in this module, one should use the sibling
/// `accounts` module (also generated), which re-exports this.
pub(crate) mod __client_accounts_redeem {
    use super::*;
    use anchor_lang::prelude::borsh;
    /// Generated client accounts for [`Redeem`].
    pub struct Redeem {
        pub authority: anchor_lang::solana_program::pubkey::Pubkey,
        pub candy_wrapper: anchor_lang::solana_program::pubkey::Pubkey,
        pub gummyroll_program: anchor_lang::solana_program::pubkey::Pubkey,
        pub owner: anchor_lang::solana_program::pubkey::Pubkey,
        pub delegate: anchor_lang::solana_program::pubkey::Pubkey,
        pub merkle_slab: anchor_lang::solana_program::pubkey::Pubkey,
        pub voucher: anchor_lang::solana_program::pubkey::Pubkey,
        pub system_program: anchor_lang::solana_program::pubkey::Pubkey,
    }
    impl borsh::ser::BorshSerialize for Redeem
    where
        anchor_lang::solana_program::pubkey::Pubkey: borsh::ser::BorshSerialize,
        anchor_lang::solana_program::pubkey::Pubkey: borsh::ser::BorshSerialize,
        anchor_lang::solana_program::pubkey::Pubkey: borsh::ser::BorshSerialize,
        anchor_lang::solana_program::pubkey::Pubkey: borsh::ser::BorshSerialize,
        anchor_lang::solana_program::pubkey::Pubkey: borsh::ser::BorshSerialize,
        anchor_lang::solana_program::pubkey::Pubkey: borsh::ser::BorshSerialize,
        anchor_lang::solana_program::pubkey::Pubkey: borsh::ser::BorshSerialize,
        anchor_lang::solana_program::pubkey::Pubkey: borsh::ser::BorshSerialize,
    {
        fn serialize<W: borsh::maybestd::io::Write>(
            &self,
            writer: &mut W,
        ) -> ::core::result::Result<(), borsh::maybestd::io::Error> {
            borsh::BorshSerialize::serialize(&self.authority, writer)?;
            borsh::BorshSerialize::serialize(&self.candy_wrapper, writer)?;
            borsh::BorshSerialize::serialize(&self.gummyroll_program, writer)?;
            borsh::BorshSerialize::serialize(&self.owner, writer)?;
            borsh::BorshSerialize::serialize(&self.delegate, writer)?;
            borsh::BorshSerialize::serialize(&self.merkle_slab, writer)?;
            borsh::BorshSerialize::serialize(&self.voucher, writer)?;
            borsh::BorshSerialize::serialize(&self.system_program, writer)?;
            Ok(())
        }
    }
    #[automatically_derived]
    impl anchor_lang::ToAccountMetas for Redeem {
        fn to_account_metas(
            &self,
            is_signer: Option<bool>,
        ) -> Vec<anchor_lang::solana_program::instruction::AccountMeta> {
            let mut account_metas = ::alloc::vec::Vec::new();
            account_metas.push(
                anchor_lang::solana_program::instruction::AccountMeta::new_readonly(
                    self.authority,
                    false,
                ),
            );
            account_metas.push(
                anchor_lang::solana_program::instruction::AccountMeta::new_readonly(
                    self.candy_wrapper,
                    false,
                ),
            );
            account_metas.push(
                anchor_lang::solana_program::instruction::AccountMeta::new_readonly(
                    self.gummyroll_program,
                    false,
                ),
            );
            account_metas.push(anchor_lang::solana_program::instruction::AccountMeta::new(
                self.owner, true,
            ));
            account_metas.push(
                anchor_lang::solana_program::instruction::AccountMeta::new_readonly(
                    self.delegate,
                    false,
                ),
            );
            account_metas.push(anchor_lang::solana_program::instruction::AccountMeta::new(
                self.merkle_slab,
                false,
            ));
            account_metas.push(anchor_lang::solana_program::instruction::AccountMeta::new(
                self.voucher,
                false,
            ));
            account_metas.push(
                anchor_lang::solana_program::instruction::AccountMeta::new_readonly(
                    self.system_program,
                    false,
                ),
            );
            account_metas
        }
    }
}
/// An internal, Anchor generated module. This is used (as an
/// implementation detail), to generate a CPI struct for a given
/// `#[derive(Accounts)]` implementation, where each field is an
/// AccountInfo.
///
/// To access the struct in this module, one should use the sibling
/// [`cpi::accounts`] module (also generated), which re-exports this.
pub(crate) mod __cpi_client_accounts_redeem {
    use super::*;
    /// Generated CPI struct of the accounts for [`Redeem`].
    pub struct Redeem<'info> {
        pub authority: anchor_lang::solana_program::account_info::AccountInfo<'info>,
        pub candy_wrapper: anchor_lang::solana_program::account_info::AccountInfo<'info>,
        pub gummyroll_program: anchor_lang::solana_program::account_info::AccountInfo<'info>,
        pub owner: anchor_lang::solana_program::account_info::AccountInfo<'info>,
        pub delegate: anchor_lang::solana_program::account_info::AccountInfo<'info>,
        pub merkle_slab: anchor_lang::solana_program::account_info::AccountInfo<'info>,
        pub voucher: anchor_lang::solana_program::account_info::AccountInfo<'info>,
        pub system_program: anchor_lang::solana_program::account_info::AccountInfo<'info>,
    }
    #[automatically_derived]
    impl<'info> anchor_lang::ToAccountMetas for Redeem<'info> {
        fn to_account_metas(
            &self,
            is_signer: Option<bool>,
        ) -> Vec<anchor_lang::solana_program::instruction::AccountMeta> {
            let mut account_metas = ::alloc::vec::Vec::new();
            account_metas.push(
                anchor_lang::solana_program::instruction::AccountMeta::new_readonly(
                    anchor_lang::Key::key(&self.authority),
                    false,
                ),
            );
            account_metas.push(
                anchor_lang::solana_program::instruction::AccountMeta::new_readonly(
                    anchor_lang::Key::key(&self.candy_wrapper),
                    false,
                ),
            );
            account_metas.push(
                anchor_lang::solana_program::instruction::AccountMeta::new_readonly(
                    anchor_lang::Key::key(&self.gummyroll_program),
                    false,
                ),
            );
            account_metas.push(anchor_lang::solana_program::instruction::AccountMeta::new(
                anchor_lang::Key::key(&self.owner),
                true,
            ));
            account_metas.push(
                anchor_lang::solana_program::instruction::AccountMeta::new_readonly(
                    anchor_lang::Key::key(&self.delegate),
                    false,
                ),
            );
            account_metas.push(anchor_lang::solana_program::instruction::AccountMeta::new(
                anchor_lang::Key::key(&self.merkle_slab),
                false,
            ));
            account_metas.push(anchor_lang::solana_program::instruction::AccountMeta::new(
                anchor_lang::Key::key(&self.voucher),
                false,
            ));
            account_metas.push(
                anchor_lang::solana_program::instruction::AccountMeta::new_readonly(
                    anchor_lang::Key::key(&self.system_program),
                    false,
                ),
            );
            account_metas
        }
    }
    #[automatically_derived]
    impl<'info> anchor_lang::ToAccountInfos<'info> for Redeem<'info> {
        fn to_account_infos(
            &self,
        ) -> Vec<anchor_lang::solana_program::account_info::AccountInfo<'info>> {
            let mut account_infos = ::alloc::vec::Vec::new();
            account_infos.push(anchor_lang::ToAccountInfo::to_account_info(&self.authority));
            account_infos.push(anchor_lang::ToAccountInfo::to_account_info(
                &self.candy_wrapper,
            ));
            account_infos.push(anchor_lang::ToAccountInfo::to_account_info(
                &self.gummyroll_program,
            ));
            account_infos.push(anchor_lang::ToAccountInfo::to_account_info(&self.owner));
            account_infos.push(anchor_lang::ToAccountInfo::to_account_info(&self.delegate));
            account_infos.push(anchor_lang::ToAccountInfo::to_account_info(
                &self.merkle_slab,
            ));
            account_infos.push(anchor_lang::ToAccountInfo::to_account_info(&self.voucher));
            account_infos.push(anchor_lang::ToAccountInfo::to_account_info(
                &self.system_program,
            ));
            account_infos
        }
    }
}
pub struct CancelRedeem<'info> {
    # [account (seeds = [merkle_slab . key () . as_ref ()] , bump ,)]
    /// CHECK: This account is neither written to nor read from.
    pub authority: Account<'info, TreeConfig>,
    pub candy_wrapper: Program<'info, Wrapper>,
    pub gummyroll_program: Program<'info, SplCompression>,
    #[account(mut)]
    /// CHECK: unsafe
    pub merkle_slab: UncheckedAccount<'info>,
    # [account (mut , close = owner , seeds = [VOUCHER_PREFIX . as_ref () , merkle_slab . key () . as_ref () , & voucher . leaf_schema . nonce () . to_le_bytes ()] , bump)]
    pub voucher: Account<'info, Voucher>,
    #[account(mut)]
    pub owner: Signer<'info>,
}
#[automatically_derived]
impl<'info> anchor_lang::Accounts<'info> for CancelRedeem<'info>
where
    'info: 'info,
{
    #[inline(never)]
    fn try_accounts(
        program_id: &anchor_lang::solana_program::pubkey::Pubkey,
        accounts: &mut &[anchor_lang::solana_program::account_info::AccountInfo<'info>],
        ix_data: &[u8],
        __bumps: &mut std::collections::BTreeMap<String, u8>,
        __reallocs: &mut std::collections::BTreeSet<anchor_lang::solana_program::pubkey::Pubkey>,
    ) -> anchor_lang::Result<Self> {
        let authority: anchor_lang::accounts::account::Account<TreeConfig> =
            anchor_lang::Accounts::try_accounts(program_id, accounts, ix_data, __bumps, __reallocs)
                .map_err(|e| e.with_account_name("authority"))?;
        let candy_wrapper: anchor_lang::accounts::program::Program<Wrapper> =
            anchor_lang::Accounts::try_accounts(program_id, accounts, ix_data, __bumps, __reallocs)
                .map_err(|e| e.with_account_name("candy_wrapper"))?;
        let gummyroll_program: anchor_lang::accounts::program::Program<SplCompression> =
            anchor_lang::Accounts::try_accounts(program_id, accounts, ix_data, __bumps, __reallocs)
                .map_err(|e| e.with_account_name("gummyroll_program"))?;
        let merkle_slab: UncheckedAccount =
            anchor_lang::Accounts::try_accounts(program_id, accounts, ix_data, __bumps, __reallocs)
                .map_err(|e| e.with_account_name("merkle_slab"))?;
        let voucher: anchor_lang::accounts::account::Account<Voucher> =
            anchor_lang::Accounts::try_accounts(program_id, accounts, ix_data, __bumps, __reallocs)
                .map_err(|e| e.with_account_name("voucher"))?;
        let owner: Signer =
            anchor_lang::Accounts::try_accounts(program_id, accounts, ix_data, __bumps, __reallocs)
                .map_err(|e| e.with_account_name("owner"))?;
        let (__pda_address, __bump) =
            Pubkey::find_program_address(&[merkle_slab.key().as_ref()], &program_id);
        __bumps.insert("authority".to_string(), __bump);
        if authority.key() != __pda_address {
            return Err(anchor_lang::error::Error::from(
                anchor_lang::error::ErrorCode::ConstraintSeeds,
            )
            .with_account_name("authority")
            .with_pubkeys((authority.key(), __pda_address)));
        }
        if !merkle_slab.to_account_info().is_writable {
            return Err(anchor_lang::error::Error::from(
                anchor_lang::error::ErrorCode::ConstraintMut,
            )
            .with_account_name("merkle_slab"));
        }
        let (__pda_address, __bump) = Pubkey::find_program_address(
            &[
                VOUCHER_PREFIX.as_ref(),
                merkle_slab.key().as_ref(),
                &voucher.leaf_schema.nonce().to_le_bytes(),
            ],
            &program_id,
        );
        __bumps.insert("voucher".to_string(), __bump);
        if voucher.key() != __pda_address {
            return Err(anchor_lang::error::Error::from(
                anchor_lang::error::ErrorCode::ConstraintSeeds,
            )
            .with_account_name("voucher")
            .with_pubkeys((voucher.key(), __pda_address)));
        }
        if !voucher.to_account_info().is_writable {
            return Err(anchor_lang::error::Error::from(
                anchor_lang::error::ErrorCode::ConstraintMut,
            )
            .with_account_name("voucher"));
        }
        if voucher.key() == owner.key() {
            return Err(anchor_lang::error::Error::from(
                anchor_lang::error::ErrorCode::ConstraintClose,
            )
            .with_account_name("voucher"));
        }
        if !owner.to_account_info().is_writable {
            return Err(anchor_lang::error::Error::from(
                anchor_lang::error::ErrorCode::ConstraintMut,
            )
            .with_account_name("owner"));
        }
        Ok(CancelRedeem {
            authority,
            candy_wrapper,
            gummyroll_program,
            merkle_slab,
            voucher,
            owner,
        })
    }
}
#[automatically_derived]
impl<'info> anchor_lang::ToAccountInfos<'info> for CancelRedeem<'info>
where
    'info: 'info,
{
    fn to_account_infos(
        &self,
    ) -> Vec<anchor_lang::solana_program::account_info::AccountInfo<'info>> {
        let mut account_infos = ::alloc::vec::Vec::new();
        account_infos.extend(self.authority.to_account_infos());
        account_infos.extend(self.candy_wrapper.to_account_infos());
        account_infos.extend(self.gummyroll_program.to_account_infos());
        account_infos.extend(self.merkle_slab.to_account_infos());
        account_infos.extend(self.voucher.to_account_infos());
        account_infos.extend(self.owner.to_account_infos());
        account_infos
    }
}
#[automatically_derived]
impl<'info> anchor_lang::ToAccountMetas for CancelRedeem<'info> {
    fn to_account_metas(
        &self,
        is_signer: Option<bool>,
    ) -> Vec<anchor_lang::solana_program::instruction::AccountMeta> {
        let mut account_metas = ::alloc::vec::Vec::new();
        account_metas.extend(self.authority.to_account_metas(None));
        account_metas.extend(self.candy_wrapper.to_account_metas(None));
        account_metas.extend(self.gummyroll_program.to_account_metas(None));
        account_metas.extend(self.merkle_slab.to_account_metas(None));
        account_metas.extend(self.voucher.to_account_metas(None));
        account_metas.extend(self.owner.to_account_metas(None));
        account_metas
    }
}
#[automatically_derived]
impl<'info> anchor_lang::AccountsExit<'info> for CancelRedeem<'info>
where
    'info: 'info,
{
    fn exit(
        &self,
        program_id: &anchor_lang::solana_program::pubkey::Pubkey,
    ) -> anchor_lang::Result<()> {
        anchor_lang::AccountsExit::exit(&self.merkle_slab, program_id)
            .map_err(|e| e.with_account_name("merkle_slab"))?;
        anchor_lang::AccountsClose::close(&self.voucher, self.owner.to_account_info())
            .map_err(|e| e.with_account_name("voucher"))?;
        anchor_lang::AccountsExit::exit(&self.owner, program_id)
            .map_err(|e| e.with_account_name("owner"))?;
        Ok(())
    }
}
/// An internal, Anchor generated module. This is used (as an
/// implementation detail), to generate a struct for a given
/// `#[derive(Accounts)]` implementation, where each field is a Pubkey,
/// instead of an `AccountInfo`. This is useful for clients that want
/// to generate a list of accounts, without explicitly knowing the
/// order all the fields should be in.
///
/// To access the struct in this module, one should use the sibling
/// `accounts` module (also generated), which re-exports this.
pub(crate) mod __client_accounts_cancel_redeem {
    use super::*;
    use anchor_lang::prelude::borsh;
    /// Generated client accounts for [`CancelRedeem`].
    pub struct CancelRedeem {
        pub authority: anchor_lang::solana_program::pubkey::Pubkey,
        pub candy_wrapper: anchor_lang::solana_program::pubkey::Pubkey,
        pub gummyroll_program: anchor_lang::solana_program::pubkey::Pubkey,
        pub merkle_slab: anchor_lang::solana_program::pubkey::Pubkey,
        pub voucher: anchor_lang::solana_program::pubkey::Pubkey,
        pub owner: anchor_lang::solana_program::pubkey::Pubkey,
    }
    impl borsh::ser::BorshSerialize for CancelRedeem
    where
        anchor_lang::solana_program::pubkey::Pubkey: borsh::ser::BorshSerialize,
        anchor_lang::solana_program::pubkey::Pubkey: borsh::ser::BorshSerialize,
        anchor_lang::solana_program::pubkey::Pubkey: borsh::ser::BorshSerialize,
        anchor_lang::solana_program::pubkey::Pubkey: borsh::ser::BorshSerialize,
        anchor_lang::solana_program::pubkey::Pubkey: borsh::ser::BorshSerialize,
        anchor_lang::solana_program::pubkey::Pubkey: borsh::ser::BorshSerialize,
    {
        fn serialize<W: borsh::maybestd::io::Write>(
            &self,
            writer: &mut W,
        ) -> ::core::result::Result<(), borsh::maybestd::io::Error> {
            borsh::BorshSerialize::serialize(&self.authority, writer)?;
            borsh::BorshSerialize::serialize(&self.candy_wrapper, writer)?;
            borsh::BorshSerialize::serialize(&self.gummyroll_program, writer)?;
            borsh::BorshSerialize::serialize(&self.merkle_slab, writer)?;
            borsh::BorshSerialize::serialize(&self.voucher, writer)?;
            borsh::BorshSerialize::serialize(&self.owner, writer)?;
            Ok(())
        }
    }
    #[automatically_derived]
    impl anchor_lang::ToAccountMetas for CancelRedeem {
        fn to_account_metas(
            &self,
            is_signer: Option<bool>,
        ) -> Vec<anchor_lang::solana_program::instruction::AccountMeta> {
            let mut account_metas = ::alloc::vec::Vec::new();
            account_metas.push(
                anchor_lang::solana_program::instruction::AccountMeta::new_readonly(
                    self.authority,
                    false,
                ),
            );
            account_metas.push(
                anchor_lang::solana_program::instruction::AccountMeta::new_readonly(
                    self.candy_wrapper,
                    false,
                ),
            );
            account_metas.push(
                anchor_lang::solana_program::instruction::AccountMeta::new_readonly(
                    self.gummyroll_program,
                    false,
                ),
            );
            account_metas.push(anchor_lang::solana_program::instruction::AccountMeta::new(
                self.merkle_slab,
                false,
            ));
            account_metas.push(anchor_lang::solana_program::instruction::AccountMeta::new(
                self.voucher,
                false,
            ));
            account_metas.push(anchor_lang::solana_program::instruction::AccountMeta::new(
                self.owner, true,
            ));
            account_metas
        }
    }
}
/// An internal, Anchor generated module. This is used (as an
/// implementation detail), to generate a CPI struct for a given
/// `#[derive(Accounts)]` implementation, where each field is an
/// AccountInfo.
///
/// To access the struct in this module, one should use the sibling
/// [`cpi::accounts`] module (also generated), which re-exports this.
pub(crate) mod __cpi_client_accounts_cancel_redeem {
    use super::*;
    /// Generated CPI struct of the accounts for [`CancelRedeem`].
    pub struct CancelRedeem<'info> {
        pub authority: anchor_lang::solana_program::account_info::AccountInfo<'info>,
        pub candy_wrapper: anchor_lang::solana_program::account_info::AccountInfo<'info>,
        pub gummyroll_program: anchor_lang::solana_program::account_info::AccountInfo<'info>,
        pub merkle_slab: anchor_lang::solana_program::account_info::AccountInfo<'info>,
        pub voucher: anchor_lang::solana_program::account_info::AccountInfo<'info>,
        pub owner: anchor_lang::solana_program::account_info::AccountInfo<'info>,
    }
    #[automatically_derived]
    impl<'info> anchor_lang::ToAccountMetas for CancelRedeem<'info> {
        fn to_account_metas(
            &self,
            is_signer: Option<bool>,
        ) -> Vec<anchor_lang::solana_program::instruction::AccountMeta> {
            let mut account_metas = ::alloc::vec::Vec::new();
            account_metas.push(
                anchor_lang::solana_program::instruction::AccountMeta::new_readonly(
                    anchor_lang::Key::key(&self.authority),
                    false,
                ),
            );
            account_metas.push(
                anchor_lang::solana_program::instruction::AccountMeta::new_readonly(
                    anchor_lang::Key::key(&self.candy_wrapper),
                    false,
                ),
            );
            account_metas.push(
                anchor_lang::solana_program::instruction::AccountMeta::new_readonly(
                    anchor_lang::Key::key(&self.gummyroll_program),
                    false,
                ),
            );
            account_metas.push(anchor_lang::solana_program::instruction::AccountMeta::new(
                anchor_lang::Key::key(&self.merkle_slab),
                false,
            ));
            account_metas.push(anchor_lang::solana_program::instruction::AccountMeta::new(
                anchor_lang::Key::key(&self.voucher),
                false,
            ));
            account_metas.push(anchor_lang::solana_program::instruction::AccountMeta::new(
                anchor_lang::Key::key(&self.owner),
                true,
            ));
            account_metas
        }
    }
    #[automatically_derived]
    impl<'info> anchor_lang::ToAccountInfos<'info> for CancelRedeem<'info> {
        fn to_account_infos(
            &self,
        ) -> Vec<anchor_lang::solana_program::account_info::AccountInfo<'info>> {
            let mut account_infos = ::alloc::vec::Vec::new();
            account_infos.push(anchor_lang::ToAccountInfo::to_account_info(&self.authority));
            account_infos.push(anchor_lang::ToAccountInfo::to_account_info(
                &self.candy_wrapper,
            ));
            account_infos.push(anchor_lang::ToAccountInfo::to_account_info(
                &self.gummyroll_program,
            ));
            account_infos.push(anchor_lang::ToAccountInfo::to_account_info(
                &self.merkle_slab,
            ));
            account_infos.push(anchor_lang::ToAccountInfo::to_account_info(&self.voucher));
            account_infos.push(anchor_lang::ToAccountInfo::to_account_info(&self.owner));
            account_infos
        }
    }
}
pub struct DecompressV1<'info> {
    # [account (mut , close = owner , seeds = [VOUCHER_PREFIX . as_ref () , voucher . merkle_slab . as_ref () , voucher . leaf_schema . nonce () . to_le_bytes () . as_ref ()] , bump)]
    pub voucher: Box<Account<'info, Voucher>>,
    #[account(mut)]
    pub owner: Signer<'info>,
    /// CHECK: versioning is handled in the instruction
    #[account(mut)]
    pub token_account: UncheckedAccount<'info>,
    /// CHECK: versioning is handled in the instruction
    # [account (mut , seeds = [ASSET_PREFIX . as_ref () , voucher . merkle_slab . as_ref () , voucher . leaf_schema . nonce () . to_le_bytes () . as_ref () ,] , bump)]
    pub mint: UncheckedAccount<'info>,
    /// CHECK:
    # [account (seeds = [mint . key () . as_ref ()] , bump ,)]
    pub mint_authority: UncheckedAccount<'info>,
    /// CHECK:
    #[account(mut)]
    pub metadata: UncheckedAccount<'info>,
    /// CHECK: Initialized in Token Metadata Program
    #[account(mut)]
    pub master_edition: UncheckedAccount<'info>,
    pub system_program: Program<'info, System>,
    pub sysvar_rent: Sysvar<'info, Rent>,
    /// CHECK:
    pub token_metadata_program: Program<'info, MplTokenMetadata>,
    /// CHECK: versioning is handled in the instruction
    pub token_program: UncheckedAccount<'info>,
    /// CHECK:
    pub associated_token_program: UncheckedAccount<'info>,
}
#[automatically_derived]
impl<'info> anchor_lang::Accounts<'info> for DecompressV1<'info>
where
    'info: 'info,
{
    #[inline(never)]
    fn try_accounts(
        program_id: &anchor_lang::solana_program::pubkey::Pubkey,
        accounts: &mut &[anchor_lang::solana_program::account_info::AccountInfo<'info>],
        ix_data: &[u8],
        __bumps: &mut std::collections::BTreeMap<String, u8>,
        __reallocs: &mut std::collections::BTreeSet<anchor_lang::solana_program::pubkey::Pubkey>,
    ) -> anchor_lang::Result<Self> {
        let voucher: Box<anchor_lang::accounts::account::Account<Voucher>> =
            anchor_lang::Accounts::try_accounts(program_id, accounts, ix_data, __bumps, __reallocs)
                .map_err(|e| e.with_account_name("voucher"))?;
        let owner: Signer =
            anchor_lang::Accounts::try_accounts(program_id, accounts, ix_data, __bumps, __reallocs)
                .map_err(|e| e.with_account_name("owner"))?;
        let token_account: UncheckedAccount =
            anchor_lang::Accounts::try_accounts(program_id, accounts, ix_data, __bumps, __reallocs)
                .map_err(|e| e.with_account_name("token_account"))?;
        let mint: UncheckedAccount =
            anchor_lang::Accounts::try_accounts(program_id, accounts, ix_data, __bumps, __reallocs)
                .map_err(|e| e.with_account_name("mint"))?;
        let mint_authority: UncheckedAccount =
            anchor_lang::Accounts::try_accounts(program_id, accounts, ix_data, __bumps, __reallocs)
                .map_err(|e| e.with_account_name("mint_authority"))?;
        let metadata: UncheckedAccount =
            anchor_lang::Accounts::try_accounts(program_id, accounts, ix_data, __bumps, __reallocs)
                .map_err(|e| e.with_account_name("metadata"))?;
        let master_edition: UncheckedAccount =
            anchor_lang::Accounts::try_accounts(program_id, accounts, ix_data, __bumps, __reallocs)
                .map_err(|e| e.with_account_name("master_edition"))?;
        let system_program: anchor_lang::accounts::program::Program<System> =
            anchor_lang::Accounts::try_accounts(program_id, accounts, ix_data, __bumps, __reallocs)
                .map_err(|e| e.with_account_name("system_program"))?;
        let sysvar_rent: Sysvar<Rent> =
            anchor_lang::Accounts::try_accounts(program_id, accounts, ix_data, __bumps, __reallocs)
                .map_err(|e| e.with_account_name("sysvar_rent"))?;
        let token_metadata_program: anchor_lang::accounts::program::Program<MplTokenMetadata> =
            anchor_lang::Accounts::try_accounts(program_id, accounts, ix_data, __bumps, __reallocs)
                .map_err(|e| e.with_account_name("token_metadata_program"))?;
        let token_program: UncheckedAccount =
            anchor_lang::Accounts::try_accounts(program_id, accounts, ix_data, __bumps, __reallocs)
                .map_err(|e| e.with_account_name("token_program"))?;
        let associated_token_program: UncheckedAccount =
            anchor_lang::Accounts::try_accounts(program_id, accounts, ix_data, __bumps, __reallocs)
                .map_err(|e| e.with_account_name("associated_token_program"))?;
        let (__pda_address, __bump) = Pubkey::find_program_address(
            &[
                VOUCHER_PREFIX.as_ref(),
                voucher.merkle_slab.as_ref(),
                voucher.leaf_schema.nonce().to_le_bytes().as_ref(),
            ],
            &program_id,
        );
        __bumps.insert("voucher".to_string(), __bump);
        if voucher.key() != __pda_address {
            return Err(anchor_lang::error::Error::from(
                anchor_lang::error::ErrorCode::ConstraintSeeds,
            )
            .with_account_name("voucher")
            .with_pubkeys((voucher.key(), __pda_address)));
        }
        if !voucher.to_account_info().is_writable {
            return Err(anchor_lang::error::Error::from(
                anchor_lang::error::ErrorCode::ConstraintMut,
            )
            .with_account_name("voucher"));
        }
        if voucher.key() == owner.key() {
            return Err(anchor_lang::error::Error::from(
                anchor_lang::error::ErrorCode::ConstraintClose,
            )
            .with_account_name("voucher"));
        }
        if !owner.to_account_info().is_writable {
            return Err(anchor_lang::error::Error::from(
                anchor_lang::error::ErrorCode::ConstraintMut,
            )
            .with_account_name("owner"));
        }
        if !token_account.to_account_info().is_writable {
            return Err(anchor_lang::error::Error::from(
                anchor_lang::error::ErrorCode::ConstraintMut,
            )
            .with_account_name("token_account"));
        }
        let (__pda_address, __bump) = Pubkey::find_program_address(
            &[
                ASSET_PREFIX.as_ref(),
                voucher.merkle_slab.as_ref(),
                voucher.leaf_schema.nonce().to_le_bytes().as_ref(),
            ],
            &program_id,
        );
        __bumps.insert("mint".to_string(), __bump);
        if mint.key() != __pda_address {
            return Err(anchor_lang::error::Error::from(
                anchor_lang::error::ErrorCode::ConstraintSeeds,
            )
            .with_account_name("mint")
            .with_pubkeys((mint.key(), __pda_address)));
        }
        if !mint.to_account_info().is_writable {
            return Err(anchor_lang::error::Error::from(
                anchor_lang::error::ErrorCode::ConstraintMut,
            )
            .with_account_name("mint"));
        }
        let (__pda_address, __bump) =
            Pubkey::find_program_address(&[mint.key().as_ref()], &program_id);
        __bumps.insert("mint_authority".to_string(), __bump);
        if mint_authority.key() != __pda_address {
            return Err(anchor_lang::error::Error::from(
                anchor_lang::error::ErrorCode::ConstraintSeeds,
            )
            .with_account_name("mint_authority")
            .with_pubkeys((mint_authority.key(), __pda_address)));
        }
        if !metadata.to_account_info().is_writable {
            return Err(anchor_lang::error::Error::from(
                anchor_lang::error::ErrorCode::ConstraintMut,
            )
            .with_account_name("metadata"));
        }
        if !master_edition.to_account_info().is_writable {
            return Err(anchor_lang::error::Error::from(
                anchor_lang::error::ErrorCode::ConstraintMut,
            )
            .with_account_name("master_edition"));
        }
        Ok(DecompressV1 {
            voucher,
            owner,
            token_account,
            mint,
            mint_authority,
            metadata,
            master_edition,
            system_program,
            sysvar_rent,
            token_metadata_program,
            token_program,
            associated_token_program,
        })
    }
}
#[automatically_derived]
impl<'info> anchor_lang::ToAccountInfos<'info> for DecompressV1<'info>
where
    'info: 'info,
{
    fn to_account_infos(
        &self,
    ) -> Vec<anchor_lang::solana_program::account_info::AccountInfo<'info>> {
        let mut account_infos = ::alloc::vec::Vec::new();
        account_infos.extend(self.voucher.to_account_infos());
        account_infos.extend(self.owner.to_account_infos());
        account_infos.extend(self.token_account.to_account_infos());
        account_infos.extend(self.mint.to_account_infos());
        account_infos.extend(self.mint_authority.to_account_infos());
        account_infos.extend(self.metadata.to_account_infos());
        account_infos.extend(self.master_edition.to_account_infos());
        account_infos.extend(self.system_program.to_account_infos());
        account_infos.extend(self.sysvar_rent.to_account_infos());
        account_infos.extend(self.token_metadata_program.to_account_infos());
        account_infos.extend(self.token_program.to_account_infos());
        account_infos.extend(self.associated_token_program.to_account_infos());
        account_infos
    }
}
#[automatically_derived]
impl<'info> anchor_lang::ToAccountMetas for DecompressV1<'info> {
    fn to_account_metas(
        &self,
        is_signer: Option<bool>,
    ) -> Vec<anchor_lang::solana_program::instruction::AccountMeta> {
        let mut account_metas = ::alloc::vec::Vec::new();
        account_metas.extend(self.voucher.to_account_metas(None));
        account_metas.extend(self.owner.to_account_metas(None));
        account_metas.extend(self.token_account.to_account_metas(None));
        account_metas.extend(self.mint.to_account_metas(None));
        account_metas.extend(self.mint_authority.to_account_metas(None));
        account_metas.extend(self.metadata.to_account_metas(None));
        account_metas.extend(self.master_edition.to_account_metas(None));
        account_metas.extend(self.system_program.to_account_metas(None));
        account_metas.extend(self.sysvar_rent.to_account_metas(None));
        account_metas.extend(self.token_metadata_program.to_account_metas(None));
        account_metas.extend(self.token_program.to_account_metas(None));
        account_metas.extend(self.associated_token_program.to_account_metas(None));
        account_metas
    }
}
#[automatically_derived]
impl<'info> anchor_lang::AccountsExit<'info> for DecompressV1<'info>
where
    'info: 'info,
{
    fn exit(
        &self,
        program_id: &anchor_lang::solana_program::pubkey::Pubkey,
    ) -> anchor_lang::Result<()> {
        anchor_lang::AccountsClose::close(&self.voucher, self.owner.to_account_info())
            .map_err(|e| e.with_account_name("voucher"))?;
        anchor_lang::AccountsExit::exit(&self.owner, program_id)
            .map_err(|e| e.with_account_name("owner"))?;
        anchor_lang::AccountsExit::exit(&self.token_account, program_id)
            .map_err(|e| e.with_account_name("token_account"))?;
        anchor_lang::AccountsExit::exit(&self.mint, program_id)
            .map_err(|e| e.with_account_name("mint"))?;
        anchor_lang::AccountsExit::exit(&self.metadata, program_id)
            .map_err(|e| e.with_account_name("metadata"))?;
        anchor_lang::AccountsExit::exit(&self.master_edition, program_id)
            .map_err(|e| e.with_account_name("master_edition"))?;
        Ok(())
    }
}
/// An internal, Anchor generated module. This is used (as an
/// implementation detail), to generate a struct for a given
/// `#[derive(Accounts)]` implementation, where each field is a Pubkey,
/// instead of an `AccountInfo`. This is useful for clients that want
/// to generate a list of accounts, without explicitly knowing the
/// order all the fields should be in.
///
/// To access the struct in this module, one should use the sibling
/// `accounts` module (also generated), which re-exports this.
pub(crate) mod __client_accounts_decompress_v1 {
    use super::*;
    use anchor_lang::prelude::borsh;
    /// Generated client accounts for [`DecompressV1`].
    pub struct DecompressV1 {
        pub voucher: anchor_lang::solana_program::pubkey::Pubkey,
        pub owner: anchor_lang::solana_program::pubkey::Pubkey,
        pub token_account: anchor_lang::solana_program::pubkey::Pubkey,
        pub mint: anchor_lang::solana_program::pubkey::Pubkey,
        pub mint_authority: anchor_lang::solana_program::pubkey::Pubkey,
        pub metadata: anchor_lang::solana_program::pubkey::Pubkey,
        pub master_edition: anchor_lang::solana_program::pubkey::Pubkey,
        pub system_program: anchor_lang::solana_program::pubkey::Pubkey,
        pub sysvar_rent: anchor_lang::solana_program::pubkey::Pubkey,
        pub token_metadata_program: anchor_lang::solana_program::pubkey::Pubkey,
        pub token_program: anchor_lang::solana_program::pubkey::Pubkey,
        pub associated_token_program: anchor_lang::solana_program::pubkey::Pubkey,
    }
    impl borsh::ser::BorshSerialize for DecompressV1
    where
        anchor_lang::solana_program::pubkey::Pubkey: borsh::ser::BorshSerialize,
        anchor_lang::solana_program::pubkey::Pubkey: borsh::ser::BorshSerialize,
        anchor_lang::solana_program::pubkey::Pubkey: borsh::ser::BorshSerialize,
        anchor_lang::solana_program::pubkey::Pubkey: borsh::ser::BorshSerialize,
        anchor_lang::solana_program::pubkey::Pubkey: borsh::ser::BorshSerialize,
        anchor_lang::solana_program::pubkey::Pubkey: borsh::ser::BorshSerialize,
        anchor_lang::solana_program::pubkey::Pubkey: borsh::ser::BorshSerialize,
        anchor_lang::solana_program::pubkey::Pubkey: borsh::ser::BorshSerialize,
        anchor_lang::solana_program::pubkey::Pubkey: borsh::ser::BorshSerialize,
        anchor_lang::solana_program::pubkey::Pubkey: borsh::ser::BorshSerialize,
        anchor_lang::solana_program::pubkey::Pubkey: borsh::ser::BorshSerialize,
        anchor_lang::solana_program::pubkey::Pubkey: borsh::ser::BorshSerialize,
    {
        fn serialize<W: borsh::maybestd::io::Write>(
            &self,
            writer: &mut W,
        ) -> ::core::result::Result<(), borsh::maybestd::io::Error> {
            borsh::BorshSerialize::serialize(&self.voucher, writer)?;
            borsh::BorshSerialize::serialize(&self.owner, writer)?;
            borsh::BorshSerialize::serialize(&self.token_account, writer)?;
            borsh::BorshSerialize::serialize(&self.mint, writer)?;
            borsh::BorshSerialize::serialize(&self.mint_authority, writer)?;
            borsh::BorshSerialize::serialize(&self.metadata, writer)?;
            borsh::BorshSerialize::serialize(&self.master_edition, writer)?;
            borsh::BorshSerialize::serialize(&self.system_program, writer)?;
            borsh::BorshSerialize::serialize(&self.sysvar_rent, writer)?;
            borsh::BorshSerialize::serialize(&self.token_metadata_program, writer)?;
            borsh::BorshSerialize::serialize(&self.token_program, writer)?;
            borsh::BorshSerialize::serialize(&self.associated_token_program, writer)?;
            Ok(())
        }
    }
    #[automatically_derived]
    impl anchor_lang::ToAccountMetas for DecompressV1 {
        fn to_account_metas(
            &self,
            is_signer: Option<bool>,
        ) -> Vec<anchor_lang::solana_program::instruction::AccountMeta> {
            let mut account_metas = ::alloc::vec::Vec::new();
            account_metas.push(anchor_lang::solana_program::instruction::AccountMeta::new(
                self.voucher,
                false,
            ));
            account_metas.push(anchor_lang::solana_program::instruction::AccountMeta::new(
                self.owner, true,
            ));
            account_metas.push(anchor_lang::solana_program::instruction::AccountMeta::new(
                self.token_account,
                false,
            ));
            account_metas.push(anchor_lang::solana_program::instruction::AccountMeta::new(
                self.mint, false,
            ));
            account_metas.push(
                anchor_lang::solana_program::instruction::AccountMeta::new_readonly(
                    self.mint_authority,
                    false,
                ),
            );
            account_metas.push(anchor_lang::solana_program::instruction::AccountMeta::new(
                self.metadata,
                false,
            ));
            account_metas.push(anchor_lang::solana_program::instruction::AccountMeta::new(
                self.master_edition,
                false,
            ));
            account_metas.push(
                anchor_lang::solana_program::instruction::AccountMeta::new_readonly(
                    self.system_program,
                    false,
                ),
            );
            account_metas.push(
                anchor_lang::solana_program::instruction::AccountMeta::new_readonly(
                    self.sysvar_rent,
                    false,
                ),
            );
            account_metas.push(
                anchor_lang::solana_program::instruction::AccountMeta::new_readonly(
                    self.token_metadata_program,
                    false,
                ),
            );
            account_metas.push(
                anchor_lang::solana_program::instruction::AccountMeta::new_readonly(
                    self.token_program,
                    false,
                ),
            );
            account_metas.push(
                anchor_lang::solana_program::instruction::AccountMeta::new_readonly(
                    self.associated_token_program,
                    false,
                ),
            );
            account_metas
        }
    }
}
/// An internal, Anchor generated module. This is used (as an
/// implementation detail), to generate a CPI struct for a given
/// `#[derive(Accounts)]` implementation, where each field is an
/// AccountInfo.
///
/// To access the struct in this module, one should use the sibling
/// [`cpi::accounts`] module (also generated), which re-exports this.
pub(crate) mod __cpi_client_accounts_decompress_v1 {
    use super::*;
    /// Generated CPI struct of the accounts for [`DecompressV1`].
    pub struct DecompressV1<'info> {
        pub voucher: anchor_lang::solana_program::account_info::AccountInfo<'info>,
        pub owner: anchor_lang::solana_program::account_info::AccountInfo<'info>,
        pub token_account: anchor_lang::solana_program::account_info::AccountInfo<'info>,
        pub mint: anchor_lang::solana_program::account_info::AccountInfo<'info>,
        pub mint_authority: anchor_lang::solana_program::account_info::AccountInfo<'info>,
        pub metadata: anchor_lang::solana_program::account_info::AccountInfo<'info>,
        pub master_edition: anchor_lang::solana_program::account_info::AccountInfo<'info>,
        pub system_program: anchor_lang::solana_program::account_info::AccountInfo<'info>,
        pub sysvar_rent: anchor_lang::solana_program::account_info::AccountInfo<'info>,
        pub token_metadata_program: anchor_lang::solana_program::account_info::AccountInfo<'info>,
        pub token_program: anchor_lang::solana_program::account_info::AccountInfo<'info>,
        pub associated_token_program: anchor_lang::solana_program::account_info::AccountInfo<'info>,
    }
    #[automatically_derived]
    impl<'info> anchor_lang::ToAccountMetas for DecompressV1<'info> {
        fn to_account_metas(
            &self,
            is_signer: Option<bool>,
        ) -> Vec<anchor_lang::solana_program::instruction::AccountMeta> {
            let mut account_metas = ::alloc::vec::Vec::new();
            account_metas.push(anchor_lang::solana_program::instruction::AccountMeta::new(
                anchor_lang::Key::key(&self.voucher),
                false,
            ));
            account_metas.push(anchor_lang::solana_program::instruction::AccountMeta::new(
                anchor_lang::Key::key(&self.owner),
                true,
            ));
            account_metas.push(anchor_lang::solana_program::instruction::AccountMeta::new(
                anchor_lang::Key::key(&self.token_account),
                false,
            ));
            account_metas.push(anchor_lang::solana_program::instruction::AccountMeta::new(
                anchor_lang::Key::key(&self.mint),
                false,
            ));
            account_metas.push(
                anchor_lang::solana_program::instruction::AccountMeta::new_readonly(
                    anchor_lang::Key::key(&self.mint_authority),
                    false,
                ),
            );
            account_metas.push(anchor_lang::solana_program::instruction::AccountMeta::new(
                anchor_lang::Key::key(&self.metadata),
                false,
            ));
            account_metas.push(anchor_lang::solana_program::instruction::AccountMeta::new(
                anchor_lang::Key::key(&self.master_edition),
                false,
            ));
            account_metas.push(
                anchor_lang::solana_program::instruction::AccountMeta::new_readonly(
                    anchor_lang::Key::key(&self.system_program),
                    false,
                ),
            );
            account_metas.push(
                anchor_lang::solana_program::instruction::AccountMeta::new_readonly(
                    anchor_lang::Key::key(&self.sysvar_rent),
                    false,
                ),
            );
            account_metas.push(
                anchor_lang::solana_program::instruction::AccountMeta::new_readonly(
                    anchor_lang::Key::key(&self.token_metadata_program),
                    false,
                ),
            );
            account_metas.push(
                anchor_lang::solana_program::instruction::AccountMeta::new_readonly(
                    anchor_lang::Key::key(&self.token_program),
                    false,
                ),
            );
            account_metas.push(
                anchor_lang::solana_program::instruction::AccountMeta::new_readonly(
                    anchor_lang::Key::key(&self.associated_token_program),
                    false,
                ),
            );
            account_metas
        }
    }
    #[automatically_derived]
    impl<'info> anchor_lang::ToAccountInfos<'info> for DecompressV1<'info> {
        fn to_account_infos(
            &self,
        ) -> Vec<anchor_lang::solana_program::account_info::AccountInfo<'info>> {
            let mut account_infos = ::alloc::vec::Vec::new();
            account_infos.push(anchor_lang::ToAccountInfo::to_account_info(&self.voucher));
            account_infos.push(anchor_lang::ToAccountInfo::to_account_info(&self.owner));
            account_infos.push(anchor_lang::ToAccountInfo::to_account_info(
                &self.token_account,
            ));
            account_infos.push(anchor_lang::ToAccountInfo::to_account_info(&self.mint));
            account_infos.push(anchor_lang::ToAccountInfo::to_account_info(
                &self.mint_authority,
            ));
            account_infos.push(anchor_lang::ToAccountInfo::to_account_info(&self.metadata));
            account_infos.push(anchor_lang::ToAccountInfo::to_account_info(
                &self.master_edition,
            ));
            account_infos.push(anchor_lang::ToAccountInfo::to_account_info(
                &self.system_program,
            ));
            account_infos.push(anchor_lang::ToAccountInfo::to_account_info(
                &self.sysvar_rent,
            ));
            account_infos.push(anchor_lang::ToAccountInfo::to_account_info(
                &self.token_metadata_program,
            ));
            account_infos.push(anchor_lang::ToAccountInfo::to_account_info(
                &self.token_program,
            ));
            account_infos.push(anchor_lang::ToAccountInfo::to_account_info(
                &self.associated_token_program,
            ));
            account_infos
        }
    }
}
pub struct Compress<'info> {
    # [account (seeds = [merkle_slab . key () . as_ref ()] , bump ,)]
    /// CHECK: This account is neither written to nor read from.
    pub authority: UncheckedAccount<'info>,
    /// CHECK: This account is not read
    pub merkle_slab: UncheckedAccount<'info>,
    /// CHECK: This account is checked in the instruction
    pub owner: Signer<'info>,
    /// CHECK: This account is chekced in the instruction
    pub delegate: UncheckedAccount<'info>,
    /// CHECK: versioning is handled in the instruction
    #[account(mut)]
    pub token_account: AccountInfo<'info>,
    /// CHECK: versioning is handled in the instruction
    #[account(mut)]
    pub mint: AccountInfo<'info>,
    #[account(mut)]
    pub metadata: Box<Account<'info, TokenMetadata>>,
    #[account(mut)]
    pub master_edition: Box<Account<'info, MasterEdition>>,
    #[account(mut)]
    pub payer: Signer<'info>,
    pub system_program: Program<'info, System>,
    /// CHECK:
    pub token_metadata_program: UncheckedAccount<'info>,
    /// CHECK:
    pub token_program: UncheckedAccount<'info>,
    pub candy_wrapper: Program<'info, Wrapper>,
    pub gummyroll_program: Program<'info, SplCompression>,
}
#[automatically_derived]
impl<'info> anchor_lang::Accounts<'info> for Compress<'info>
where
    'info: 'info,
{
    #[inline(never)]
    fn try_accounts(
        program_id: &anchor_lang::solana_program::pubkey::Pubkey,
        accounts: &mut &[anchor_lang::solana_program::account_info::AccountInfo<'info>],
        ix_data: &[u8],
        __bumps: &mut std::collections::BTreeMap<String, u8>,
        __reallocs: &mut std::collections::BTreeSet<anchor_lang::solana_program::pubkey::Pubkey>,
    ) -> anchor_lang::Result<Self> {
        let authority: UncheckedAccount =
            anchor_lang::Accounts::try_accounts(program_id, accounts, ix_data, __bumps, __reallocs)
                .map_err(|e| e.with_account_name("authority"))?;
        let merkle_slab: UncheckedAccount =
            anchor_lang::Accounts::try_accounts(program_id, accounts, ix_data, __bumps, __reallocs)
                .map_err(|e| e.with_account_name("merkle_slab"))?;
        let owner: Signer =
            anchor_lang::Accounts::try_accounts(program_id, accounts, ix_data, __bumps, __reallocs)
                .map_err(|e| e.with_account_name("owner"))?;
        let delegate: UncheckedAccount =
            anchor_lang::Accounts::try_accounts(program_id, accounts, ix_data, __bumps, __reallocs)
                .map_err(|e| e.with_account_name("delegate"))?;
        let token_account: AccountInfo =
            anchor_lang::Accounts::try_accounts(program_id, accounts, ix_data, __bumps, __reallocs)
                .map_err(|e| e.with_account_name("token_account"))?;
        let mint: AccountInfo =
            anchor_lang::Accounts::try_accounts(program_id, accounts, ix_data, __bumps, __reallocs)
                .map_err(|e| e.with_account_name("mint"))?;
        let metadata: Box<anchor_lang::accounts::account::Account<TokenMetadata>> =
            anchor_lang::Accounts::try_accounts(program_id, accounts, ix_data, __bumps, __reallocs)
                .map_err(|e| e.with_account_name("metadata"))?;
        let master_edition: Box<anchor_lang::accounts::account::Account<MasterEdition>> =
            anchor_lang::Accounts::try_accounts(program_id, accounts, ix_data, __bumps, __reallocs)
                .map_err(|e| e.with_account_name("master_edition"))?;
        let payer: Signer =
            anchor_lang::Accounts::try_accounts(program_id, accounts, ix_data, __bumps, __reallocs)
                .map_err(|e| e.with_account_name("payer"))?;
        let system_program: anchor_lang::accounts::program::Program<System> =
            anchor_lang::Accounts::try_accounts(program_id, accounts, ix_data, __bumps, __reallocs)
                .map_err(|e| e.with_account_name("system_program"))?;
        let token_metadata_program: UncheckedAccount =
            anchor_lang::Accounts::try_accounts(program_id, accounts, ix_data, __bumps, __reallocs)
                .map_err(|e| e.with_account_name("token_metadata_program"))?;
        let token_program: UncheckedAccount =
            anchor_lang::Accounts::try_accounts(program_id, accounts, ix_data, __bumps, __reallocs)
                .map_err(|e| e.with_account_name("token_program"))?;
        let candy_wrapper: anchor_lang::accounts::program::Program<Wrapper> =
            anchor_lang::Accounts::try_accounts(program_id, accounts, ix_data, __bumps, __reallocs)
                .map_err(|e| e.with_account_name("candy_wrapper"))?;
        let gummyroll_program: anchor_lang::accounts::program::Program<SplCompression> =
            anchor_lang::Accounts::try_accounts(program_id, accounts, ix_data, __bumps, __reallocs)
                .map_err(|e| e.with_account_name("gummyroll_program"))?;
        let (__pda_address, __bump) =
            Pubkey::find_program_address(&[merkle_slab.key().as_ref()], &program_id);
        __bumps.insert("authority".to_string(), __bump);
        if authority.key() != __pda_address {
            return Err(anchor_lang::error::Error::from(
                anchor_lang::error::ErrorCode::ConstraintSeeds,
            )
            .with_account_name("authority")
            .with_pubkeys((authority.key(), __pda_address)));
        }
        if !token_account.to_account_info().is_writable {
            return Err(anchor_lang::error::Error::from(
                anchor_lang::error::ErrorCode::ConstraintMut,
            )
            .with_account_name("token_account"));
        }
        if !mint.to_account_info().is_writable {
            return Err(anchor_lang::error::Error::from(
                anchor_lang::error::ErrorCode::ConstraintMut,
            )
            .with_account_name("mint"));
        }
        if !metadata.to_account_info().is_writable {
            return Err(anchor_lang::error::Error::from(
                anchor_lang::error::ErrorCode::ConstraintMut,
            )
            .with_account_name("metadata"));
        }
        if !master_edition.to_account_info().is_writable {
            return Err(anchor_lang::error::Error::from(
                anchor_lang::error::ErrorCode::ConstraintMut,
            )
            .with_account_name("master_edition"));
        }
        if !payer.to_account_info().is_writable {
            return Err(anchor_lang::error::Error::from(
                anchor_lang::error::ErrorCode::ConstraintMut,
            )
            .with_account_name("payer"));
        }
        Ok(Compress {
            authority,
            merkle_slab,
            owner,
            delegate,
            token_account,
            mint,
            metadata,
            master_edition,
            payer,
            system_program,
            token_metadata_program,
            token_program,
            candy_wrapper,
            gummyroll_program,
        })
    }
}
#[automatically_derived]
impl<'info> anchor_lang::ToAccountInfos<'info> for Compress<'info>
where
    'info: 'info,
{
    fn to_account_infos(
        &self,
    ) -> Vec<anchor_lang::solana_program::account_info::AccountInfo<'info>> {
        let mut account_infos = ::alloc::vec::Vec::new();
        account_infos.extend(self.authority.to_account_infos());
        account_infos.extend(self.merkle_slab.to_account_infos());
        account_infos.extend(self.owner.to_account_infos());
        account_infos.extend(self.delegate.to_account_infos());
        account_infos.extend(self.token_account.to_account_infos());
        account_infos.extend(self.mint.to_account_infos());
        account_infos.extend(self.metadata.to_account_infos());
        account_infos.extend(self.master_edition.to_account_infos());
        account_infos.extend(self.payer.to_account_infos());
        account_infos.extend(self.system_program.to_account_infos());
        account_infos.extend(self.token_metadata_program.to_account_infos());
        account_infos.extend(self.token_program.to_account_infos());
        account_infos.extend(self.candy_wrapper.to_account_infos());
        account_infos.extend(self.gummyroll_program.to_account_infos());
        account_infos
    }
}
#[automatically_derived]
impl<'info> anchor_lang::ToAccountMetas for Compress<'info> {
    fn to_account_metas(
        &self,
        is_signer: Option<bool>,
    ) -> Vec<anchor_lang::solana_program::instruction::AccountMeta> {
        let mut account_metas = ::alloc::vec::Vec::new();
        account_metas.extend(self.authority.to_account_metas(None));
        account_metas.extend(self.merkle_slab.to_account_metas(None));
        account_metas.extend(self.owner.to_account_metas(None));
        account_metas.extend(self.delegate.to_account_metas(None));
        account_metas.extend(self.token_account.to_account_metas(None));
        account_metas.extend(self.mint.to_account_metas(None));
        account_metas.extend(self.metadata.to_account_metas(None));
        account_metas.extend(self.master_edition.to_account_metas(None));
        account_metas.extend(self.payer.to_account_metas(None));
        account_metas.extend(self.system_program.to_account_metas(None));
        account_metas.extend(self.token_metadata_program.to_account_metas(None));
        account_metas.extend(self.token_program.to_account_metas(None));
        account_metas.extend(self.candy_wrapper.to_account_metas(None));
        account_metas.extend(self.gummyroll_program.to_account_metas(None));
        account_metas
    }
}
#[automatically_derived]
impl<'info> anchor_lang::AccountsExit<'info> for Compress<'info>
where
    'info: 'info,
{
    fn exit(
        &self,
        program_id: &anchor_lang::solana_program::pubkey::Pubkey,
    ) -> anchor_lang::Result<()> {
        anchor_lang::AccountsExit::exit(&self.token_account, program_id)
            .map_err(|e| e.with_account_name("token_account"))?;
        anchor_lang::AccountsExit::exit(&self.mint, program_id)
            .map_err(|e| e.with_account_name("mint"))?;
        anchor_lang::AccountsExit::exit(&self.metadata, program_id)
            .map_err(|e| e.with_account_name("metadata"))?;
        anchor_lang::AccountsExit::exit(&self.master_edition, program_id)
            .map_err(|e| e.with_account_name("master_edition"))?;
        anchor_lang::AccountsExit::exit(&self.payer, program_id)
            .map_err(|e| e.with_account_name("payer"))?;
        Ok(())
    }
}
/// An internal, Anchor generated module. This is used (as an
/// implementation detail), to generate a struct for a given
/// `#[derive(Accounts)]` implementation, where each field is a Pubkey,
/// instead of an `AccountInfo`. This is useful for clients that want
/// to generate a list of accounts, without explicitly knowing the
/// order all the fields should be in.
///
/// To access the struct in this module, one should use the sibling
/// `accounts` module (also generated), which re-exports this.
pub(crate) mod __client_accounts_compress {
    use super::*;
    use anchor_lang::prelude::borsh;
    /// Generated client accounts for [`Compress`].
    pub struct Compress {
        pub authority: anchor_lang::solana_program::pubkey::Pubkey,
        pub merkle_slab: anchor_lang::solana_program::pubkey::Pubkey,
        pub owner: anchor_lang::solana_program::pubkey::Pubkey,
        pub delegate: anchor_lang::solana_program::pubkey::Pubkey,
        pub token_account: anchor_lang::solana_program::pubkey::Pubkey,
        pub mint: anchor_lang::solana_program::pubkey::Pubkey,
        pub metadata: anchor_lang::solana_program::pubkey::Pubkey,
        pub master_edition: anchor_lang::solana_program::pubkey::Pubkey,
        pub payer: anchor_lang::solana_program::pubkey::Pubkey,
        pub system_program: anchor_lang::solana_program::pubkey::Pubkey,
        pub token_metadata_program: anchor_lang::solana_program::pubkey::Pubkey,
        pub token_program: anchor_lang::solana_program::pubkey::Pubkey,
        pub candy_wrapper: anchor_lang::solana_program::pubkey::Pubkey,
        pub gummyroll_program: anchor_lang::solana_program::pubkey::Pubkey,
    }
    impl borsh::ser::BorshSerialize for Compress
    where
        anchor_lang::solana_program::pubkey::Pubkey: borsh::ser::BorshSerialize,
        anchor_lang::solana_program::pubkey::Pubkey: borsh::ser::BorshSerialize,
        anchor_lang::solana_program::pubkey::Pubkey: borsh::ser::BorshSerialize,
        anchor_lang::solana_program::pubkey::Pubkey: borsh::ser::BorshSerialize,
        anchor_lang::solana_program::pubkey::Pubkey: borsh::ser::BorshSerialize,
        anchor_lang::solana_program::pubkey::Pubkey: borsh::ser::BorshSerialize,
        anchor_lang::solana_program::pubkey::Pubkey: borsh::ser::BorshSerialize,
        anchor_lang::solana_program::pubkey::Pubkey: borsh::ser::BorshSerialize,
        anchor_lang::solana_program::pubkey::Pubkey: borsh::ser::BorshSerialize,
        anchor_lang::solana_program::pubkey::Pubkey: borsh::ser::BorshSerialize,
        anchor_lang::solana_program::pubkey::Pubkey: borsh::ser::BorshSerialize,
        anchor_lang::solana_program::pubkey::Pubkey: borsh::ser::BorshSerialize,
        anchor_lang::solana_program::pubkey::Pubkey: borsh::ser::BorshSerialize,
        anchor_lang::solana_program::pubkey::Pubkey: borsh::ser::BorshSerialize,
    {
        fn serialize<W: borsh::maybestd::io::Write>(
            &self,
            writer: &mut W,
        ) -> ::core::result::Result<(), borsh::maybestd::io::Error> {
            borsh::BorshSerialize::serialize(&self.authority, writer)?;
            borsh::BorshSerialize::serialize(&self.merkle_slab, writer)?;
            borsh::BorshSerialize::serialize(&self.owner, writer)?;
            borsh::BorshSerialize::serialize(&self.delegate, writer)?;
            borsh::BorshSerialize::serialize(&self.token_account, writer)?;
            borsh::BorshSerialize::serialize(&self.mint, writer)?;
            borsh::BorshSerialize::serialize(&self.metadata, writer)?;
            borsh::BorshSerialize::serialize(&self.master_edition, writer)?;
            borsh::BorshSerialize::serialize(&self.payer, writer)?;
            borsh::BorshSerialize::serialize(&self.system_program, writer)?;
            borsh::BorshSerialize::serialize(&self.token_metadata_program, writer)?;
            borsh::BorshSerialize::serialize(&self.token_program, writer)?;
            borsh::BorshSerialize::serialize(&self.candy_wrapper, writer)?;
            borsh::BorshSerialize::serialize(&self.gummyroll_program, writer)?;
            Ok(())
        }
    }
    #[automatically_derived]
    impl anchor_lang::ToAccountMetas for Compress {
        fn to_account_metas(
            &self,
            is_signer: Option<bool>,
        ) -> Vec<anchor_lang::solana_program::instruction::AccountMeta> {
            let mut account_metas = ::alloc::vec::Vec::new();
            account_metas.push(
                anchor_lang::solana_program::instruction::AccountMeta::new_readonly(
                    self.authority,
                    false,
                ),
            );
            account_metas.push(
                anchor_lang::solana_program::instruction::AccountMeta::new_readonly(
                    self.merkle_slab,
                    false,
                ),
            );
            account_metas.push(
                anchor_lang::solana_program::instruction::AccountMeta::new_readonly(
                    self.owner, true,
                ),
            );
            account_metas.push(
                anchor_lang::solana_program::instruction::AccountMeta::new_readonly(
                    self.delegate,
                    false,
                ),
            );
            account_metas.push(anchor_lang::solana_program::instruction::AccountMeta::new(
                self.token_account,
                false,
            ));
            account_metas.push(anchor_lang::solana_program::instruction::AccountMeta::new(
                self.mint, false,
            ));
            account_metas.push(anchor_lang::solana_program::instruction::AccountMeta::new(
                self.metadata,
                false,
            ));
            account_metas.push(anchor_lang::solana_program::instruction::AccountMeta::new(
                self.master_edition,
                false,
            ));
            account_metas.push(anchor_lang::solana_program::instruction::AccountMeta::new(
                self.payer, true,
            ));
            account_metas.push(
                anchor_lang::solana_program::instruction::AccountMeta::new_readonly(
                    self.system_program,
                    false,
                ),
            );
            account_metas.push(
                anchor_lang::solana_program::instruction::AccountMeta::new_readonly(
                    self.token_metadata_program,
                    false,
                ),
            );
            account_metas.push(
                anchor_lang::solana_program::instruction::AccountMeta::new_readonly(
                    self.token_program,
                    false,
                ),
            );
            account_metas.push(
                anchor_lang::solana_program::instruction::AccountMeta::new_readonly(
                    self.candy_wrapper,
                    false,
                ),
            );
            account_metas.push(
                anchor_lang::solana_program::instruction::AccountMeta::new_readonly(
                    self.gummyroll_program,
                    false,
                ),
            );
            account_metas
        }
    }
}
/// An internal, Anchor generated module. This is used (as an
/// implementation detail), to generate a CPI struct for a given
/// `#[derive(Accounts)]` implementation, where each field is an
/// AccountInfo.
///
/// To access the struct in this module, one should use the sibling
/// [`cpi::accounts`] module (also generated), which re-exports this.
pub(crate) mod __cpi_client_accounts_compress {
    use super::*;
    /// Generated CPI struct of the accounts for [`Compress`].
    pub struct Compress<'info> {
        pub authority: anchor_lang::solana_program::account_info::AccountInfo<'info>,
        pub merkle_slab: anchor_lang::solana_program::account_info::AccountInfo<'info>,
        pub owner: anchor_lang::solana_program::account_info::AccountInfo<'info>,
        pub delegate: anchor_lang::solana_program::account_info::AccountInfo<'info>,
        pub token_account: anchor_lang::solana_program::account_info::AccountInfo<'info>,
        pub mint: anchor_lang::solana_program::account_info::AccountInfo<'info>,
        pub metadata: anchor_lang::solana_program::account_info::AccountInfo<'info>,
        pub master_edition: anchor_lang::solana_program::account_info::AccountInfo<'info>,
        pub payer: anchor_lang::solana_program::account_info::AccountInfo<'info>,
        pub system_program: anchor_lang::solana_program::account_info::AccountInfo<'info>,
        pub token_metadata_program: anchor_lang::solana_program::account_info::AccountInfo<'info>,
        pub token_program: anchor_lang::solana_program::account_info::AccountInfo<'info>,
        pub candy_wrapper: anchor_lang::solana_program::account_info::AccountInfo<'info>,
        pub gummyroll_program: anchor_lang::solana_program::account_info::AccountInfo<'info>,
    }
    #[automatically_derived]
    impl<'info> anchor_lang::ToAccountMetas for Compress<'info> {
        fn to_account_metas(
            &self,
            is_signer: Option<bool>,
        ) -> Vec<anchor_lang::solana_program::instruction::AccountMeta> {
            let mut account_metas = ::alloc::vec::Vec::new();
            account_metas.push(
                anchor_lang::solana_program::instruction::AccountMeta::new_readonly(
                    anchor_lang::Key::key(&self.authority),
                    false,
                ),
            );
            account_metas.push(
                anchor_lang::solana_program::instruction::AccountMeta::new_readonly(
                    anchor_lang::Key::key(&self.merkle_slab),
                    false,
                ),
            );
            account_metas.push(
                anchor_lang::solana_program::instruction::AccountMeta::new_readonly(
                    anchor_lang::Key::key(&self.owner),
                    true,
                ),
            );
            account_metas.push(
                anchor_lang::solana_program::instruction::AccountMeta::new_readonly(
                    anchor_lang::Key::key(&self.delegate),
                    false,
                ),
            );
            account_metas.push(anchor_lang::solana_program::instruction::AccountMeta::new(
                anchor_lang::Key::key(&self.token_account),
                false,
            ));
            account_metas.push(anchor_lang::solana_program::instruction::AccountMeta::new(
                anchor_lang::Key::key(&self.mint),
                false,
            ));
            account_metas.push(anchor_lang::solana_program::instruction::AccountMeta::new(
                anchor_lang::Key::key(&self.metadata),
                false,
            ));
            account_metas.push(anchor_lang::solana_program::instruction::AccountMeta::new(
                anchor_lang::Key::key(&self.master_edition),
                false,
            ));
            account_metas.push(anchor_lang::solana_program::instruction::AccountMeta::new(
                anchor_lang::Key::key(&self.payer),
                true,
            ));
            account_metas.push(
                anchor_lang::solana_program::instruction::AccountMeta::new_readonly(
                    anchor_lang::Key::key(&self.system_program),
                    false,
                ),
            );
            account_metas.push(
                anchor_lang::solana_program::instruction::AccountMeta::new_readonly(
                    anchor_lang::Key::key(&self.token_metadata_program),
                    false,
                ),
            );
            account_metas.push(
                anchor_lang::solana_program::instruction::AccountMeta::new_readonly(
                    anchor_lang::Key::key(&self.token_program),
                    false,
                ),
            );
            account_metas.push(
                anchor_lang::solana_program::instruction::AccountMeta::new_readonly(
                    anchor_lang::Key::key(&self.candy_wrapper),
                    false,
                ),
            );
            account_metas.push(
                anchor_lang::solana_program::instruction::AccountMeta::new_readonly(
                    anchor_lang::Key::key(&self.gummyroll_program),
                    false,
                ),
            );
            account_metas
        }
    }
    #[automatically_derived]
    impl<'info> anchor_lang::ToAccountInfos<'info> for Compress<'info> {
        fn to_account_infos(
            &self,
        ) -> Vec<anchor_lang::solana_program::account_info::AccountInfo<'info>> {
            let mut account_infos = ::alloc::vec::Vec::new();
            account_infos.push(anchor_lang::ToAccountInfo::to_account_info(&self.authority));
            account_infos.push(anchor_lang::ToAccountInfo::to_account_info(
                &self.merkle_slab,
            ));
            account_infos.push(anchor_lang::ToAccountInfo::to_account_info(&self.owner));
            account_infos.push(anchor_lang::ToAccountInfo::to_account_info(&self.delegate));
            account_infos.push(anchor_lang::ToAccountInfo::to_account_info(
                &self.token_account,
            ));
            account_infos.push(anchor_lang::ToAccountInfo::to_account_info(&self.mint));
            account_infos.push(anchor_lang::ToAccountInfo::to_account_info(&self.metadata));
            account_infos.push(anchor_lang::ToAccountInfo::to_account_info(
                &self.master_edition,
            ));
            account_infos.push(anchor_lang::ToAccountInfo::to_account_info(&self.payer));
            account_infos.push(anchor_lang::ToAccountInfo::to_account_info(
                &self.system_program,
            ));
            account_infos.push(anchor_lang::ToAccountInfo::to_account_info(
                &self.token_metadata_program,
            ));
            account_infos.push(anchor_lang::ToAccountInfo::to_account_info(
                &self.token_program,
            ));
            account_infos.push(anchor_lang::ToAccountInfo::to_account_info(
                &self.candy_wrapper,
            ));
            account_infos.push(anchor_lang::ToAccountInfo::to_account_info(
                &self.gummyroll_program,
            ));
            account_infos
        }
    }
}
pub struct SetMintRequest<'info> {
    # [account (init_if_needed , space = MINT_REQUEST_SIZE , seeds = [merkle_slab . key () . as_ref () , mint_authority . key () . as_ref ()] , payer = payer , bump)]
    pub mint_authority_request: Account<'info, MintRequest>,
    #[account(mut)]
    pub payer: Signer<'info>,
    pub mint_authority: Signer<'info>,
    # [account (mut , seeds = [merkle_slab . key () . as_ref ()] , bump)]
    pub tree_authority: Account<'info, TreeConfig>,
    pub system_program: Program<'info, System>,
    /// CHECK: this account is neither read from or written to
    pub merkle_slab: UncheckedAccount<'info>,
}
#[automatically_derived]
impl<'info> anchor_lang::Accounts<'info> for SetMintRequest<'info>
where
    'info: 'info,
{
    #[inline(never)]
    fn try_accounts(
        program_id: &anchor_lang::solana_program::pubkey::Pubkey,
        accounts: &mut &[anchor_lang::solana_program::account_info::AccountInfo<'info>],
        ix_data: &[u8],
        __bumps: &mut std::collections::BTreeMap<String, u8>,
        __reallocs: &mut std::collections::BTreeSet<anchor_lang::solana_program::pubkey::Pubkey>,
    ) -> anchor_lang::Result<Self> {
        if accounts.is_empty() {
            return Err(anchor_lang::error::ErrorCode::AccountNotEnoughKeys.into());
        }
        let mint_authority_request = &accounts[0];
        *accounts = &accounts[1..];
        let payer: Signer =
            anchor_lang::Accounts::try_accounts(program_id, accounts, ix_data, __bumps, __reallocs)
                .map_err(|e| e.with_account_name("payer"))?;
        let mint_authority: Signer =
            anchor_lang::Accounts::try_accounts(program_id, accounts, ix_data, __bumps, __reallocs)
                .map_err(|e| e.with_account_name("mint_authority"))?;
        let tree_authority: anchor_lang::accounts::account::Account<TreeConfig> =
            anchor_lang::Accounts::try_accounts(program_id, accounts, ix_data, __bumps, __reallocs)
                .map_err(|e| e.with_account_name("tree_authority"))?;
        let system_program: anchor_lang::accounts::program::Program<System> =
            anchor_lang::Accounts::try_accounts(program_id, accounts, ix_data, __bumps, __reallocs)
                .map_err(|e| e.with_account_name("system_program"))?;
        let merkle_slab: UncheckedAccount =
            anchor_lang::Accounts::try_accounts(program_id, accounts, ix_data, __bumps, __reallocs)
                .map_err(|e| e.with_account_name("merkle_slab"))?;
        let __anchor_rent = Rent::get()?;
        let (__pda_address, __bump) = Pubkey::find_program_address(
            &[merkle_slab.key().as_ref(), mint_authority.key().as_ref()],
            program_id,
        );
        __bumps.insert("mint_authority_request".to_string(), __bump);
        let mint_authority_request = {
            let actual_field = mint_authority_request.to_account_info();
            let actual_owner = actual_field.owner;
            let space = MINT_REQUEST_SIZE;
            let pa: anchor_lang::accounts::account::Account<MintRequest> = if !true
                || actual_owner == &anchor_lang::solana_program::system_program::ID
            {
                let payer = payer.to_account_info();
                let __current_lamports = mint_authority_request.lamports();
                if __current_lamports == 0 {
                    let lamports = __anchor_rent.minimum_balance(space);
                    let cpi_accounts = anchor_lang::system_program::CreateAccount {
                        from: payer.to_account_info(),
                        to: mint_authority_request.to_account_info(),
                    };
                    let cpi_context = anchor_lang::context::CpiContext::new(
                        system_program.to_account_info(),
                        cpi_accounts,
                    );
                    anchor_lang::system_program::create_account(
                        cpi_context.with_signer(&[&[
                            merkle_slab.key().as_ref(),
                            mint_authority.key().as_ref(),
                            &[__bump][..],
                        ][..]]),
                        lamports,
                        space as u64,
                        program_id,
                    )?;
                } else {
                    let required_lamports = __anchor_rent
                        .minimum_balance(space)
                        .max(1)
                        .saturating_sub(__current_lamports);
                    if required_lamports > 0 {
                        let cpi_accounts = anchor_lang::system_program::Transfer {
                            from: payer.to_account_info(),
                            to: mint_authority_request.to_account_info(),
                        };
                        let cpi_context = anchor_lang::context::CpiContext::new(
                            system_program.to_account_info(),
                            cpi_accounts,
                        );
                        anchor_lang::system_program::transfer(cpi_context, required_lamports)?;
                    }
                    let cpi_accounts = anchor_lang::system_program::Allocate {
                        account_to_allocate: mint_authority_request.to_account_info(),
                    };
                    let cpi_context = anchor_lang::context::CpiContext::new(
                        system_program.to_account_info(),
                        cpi_accounts,
                    );
                    anchor_lang::system_program::allocate(
                        cpi_context.with_signer(&[&[
                            merkle_slab.key().as_ref(),
                            mint_authority.key().as_ref(),
                            &[__bump][..],
                        ][..]]),
                        space as u64,
                    )?;
                    let cpi_accounts = anchor_lang::system_program::Assign {
                        account_to_assign: mint_authority_request.to_account_info(),
                    };
                    let cpi_context = anchor_lang::context::CpiContext::new(
                        system_program.to_account_info(),
                        cpi_accounts,
                    );
                    anchor_lang::system_program::assign(
                        cpi_context.with_signer(&[&[
                            merkle_slab.key().as_ref(),
                            mint_authority.key().as_ref(),
                            &[__bump][..],
                        ][..]]),
                        program_id,
                    )?;
                }
                anchor_lang::accounts::account::Account::try_from_unchecked(&mint_authority_request)
                    .map_err(|e| e.with_account_name("mint_authority_request"))?
            } else {
                anchor_lang::accounts::account::Account::try_from(&mint_authority_request)
                    .map_err(|e| e.with_account_name("mint_authority_request"))?
            };
            if true {
                if space != actual_field.data_len() {
                    return Err(anchor_lang::error::Error::from(
                        anchor_lang::error::ErrorCode::ConstraintSpace,
                    )
                    .with_account_name("mint_authority_request")
                    .with_values((space, actual_field.data_len())));
                }
                if actual_owner != program_id {
                    return Err(anchor_lang::error::Error::from(
                        anchor_lang::error::ErrorCode::ConstraintOwner,
                    )
                    .with_account_name("mint_authority_request")
                    .with_pubkeys((*actual_owner, *program_id)));
                }
                {
                    let required_lamports = __anchor_rent.minimum_balance(space);
                    if pa.to_account_info().lamports() < required_lamports {
                        return Err(anchor_lang::error::Error::from(
                            anchor_lang::error::ErrorCode::ConstraintRentExempt,
                        )
                        .with_account_name("mint_authority_request"));
                    }
                }
            }
            pa
        };
        if mint_authority_request.key() != __pda_address {
            return Err(anchor_lang::error::Error::from(
                anchor_lang::error::ErrorCode::ConstraintSeeds,
            )
            .with_account_name("mint_authority_request")
            .with_pubkeys((mint_authority_request.key(), __pda_address)));
        }
        if !mint_authority_request.to_account_info().is_writable {
            return Err(anchor_lang::error::Error::from(
                anchor_lang::error::ErrorCode::ConstraintMut,
            )
            .with_account_name("mint_authority_request"));
        }
        if !__anchor_rent.is_exempt(
            mint_authority_request.to_account_info().lamports(),
            mint_authority_request.to_account_info().try_data_len()?,
        ) {
            return Err(anchor_lang::error::Error::from(
                anchor_lang::error::ErrorCode::ConstraintRentExempt,
            )
            .with_account_name("mint_authority_request"));
        }
        if !payer.to_account_info().is_writable {
            return Err(anchor_lang::error::Error::from(
                anchor_lang::error::ErrorCode::ConstraintMut,
            )
            .with_account_name("payer"));
        }
        let (__pda_address, __bump) =
            Pubkey::find_program_address(&[merkle_slab.key().as_ref()], &program_id);
        __bumps.insert("tree_authority".to_string(), __bump);
        if tree_authority.key() != __pda_address {
            return Err(anchor_lang::error::Error::from(
                anchor_lang::error::ErrorCode::ConstraintSeeds,
            )
            .with_account_name("tree_authority")
            .with_pubkeys((tree_authority.key(), __pda_address)));
        }
        if !tree_authority.to_account_info().is_writable {
            return Err(anchor_lang::error::Error::from(
                anchor_lang::error::ErrorCode::ConstraintMut,
            )
            .with_account_name("tree_authority"));
        }
        Ok(SetMintRequest {
            mint_authority_request,
            payer,
            mint_authority,
            tree_authority,
            system_program,
            merkle_slab,
        })
    }
}
#[automatically_derived]
impl<'info> anchor_lang::ToAccountInfos<'info> for SetMintRequest<'info>
where
    'info: 'info,
{
    fn to_account_infos(
        &self,
    ) -> Vec<anchor_lang::solana_program::account_info::AccountInfo<'info>> {
        let mut account_infos = ::alloc::vec::Vec::new();
        account_infos.extend(self.mint_authority_request.to_account_infos());
        account_infos.extend(self.payer.to_account_infos());
        account_infos.extend(self.mint_authority.to_account_infos());
        account_infos.extend(self.tree_authority.to_account_infos());
        account_infos.extend(self.system_program.to_account_infos());
        account_infos.extend(self.merkle_slab.to_account_infos());
        account_infos
    }
}
#[automatically_derived]
impl<'info> anchor_lang::ToAccountMetas for SetMintRequest<'info> {
    fn to_account_metas(
        &self,
        is_signer: Option<bool>,
    ) -> Vec<anchor_lang::solana_program::instruction::AccountMeta> {
        let mut account_metas = ::alloc::vec::Vec::new();
        account_metas.extend(self.mint_authority_request.to_account_metas(None));
        account_metas.extend(self.payer.to_account_metas(None));
        account_metas.extend(self.mint_authority.to_account_metas(None));
        account_metas.extend(self.tree_authority.to_account_metas(None));
        account_metas.extend(self.system_program.to_account_metas(None));
        account_metas.extend(self.merkle_slab.to_account_metas(None));
        account_metas
    }
}
#[automatically_derived]
impl<'info> anchor_lang::AccountsExit<'info> for SetMintRequest<'info>
where
    'info: 'info,
{
    fn exit(
        &self,
        program_id: &anchor_lang::solana_program::pubkey::Pubkey,
    ) -> anchor_lang::Result<()> {
        anchor_lang::AccountsExit::exit(&self.mint_authority_request, program_id)
            .map_err(|e| e.with_account_name("mint_authority_request"))?;
        anchor_lang::AccountsExit::exit(&self.payer, program_id)
            .map_err(|e| e.with_account_name("payer"))?;
        anchor_lang::AccountsExit::exit(&self.tree_authority, program_id)
            .map_err(|e| e.with_account_name("tree_authority"))?;
        Ok(())
    }
}
/// An internal, Anchor generated module. This is used (as an
/// implementation detail), to generate a struct for a given
/// `#[derive(Accounts)]` implementation, where each field is a Pubkey,
/// instead of an `AccountInfo`. This is useful for clients that want
/// to generate a list of accounts, without explicitly knowing the
/// order all the fields should be in.
///
/// To access the struct in this module, one should use the sibling
/// `accounts` module (also generated), which re-exports this.
pub(crate) mod __client_accounts_set_mint_request {
    use super::*;
    use anchor_lang::prelude::borsh;
    /// Generated client accounts for [`SetMintRequest`].
    pub struct SetMintRequest {
        pub mint_authority_request: anchor_lang::solana_program::pubkey::Pubkey,
        pub payer: anchor_lang::solana_program::pubkey::Pubkey,
        pub mint_authority: anchor_lang::solana_program::pubkey::Pubkey,
        pub tree_authority: anchor_lang::solana_program::pubkey::Pubkey,
        pub system_program: anchor_lang::solana_program::pubkey::Pubkey,
        pub merkle_slab: anchor_lang::solana_program::pubkey::Pubkey,
    }
    impl borsh::ser::BorshSerialize for SetMintRequest
    where
        anchor_lang::solana_program::pubkey::Pubkey: borsh::ser::BorshSerialize,
        anchor_lang::solana_program::pubkey::Pubkey: borsh::ser::BorshSerialize,
        anchor_lang::solana_program::pubkey::Pubkey: borsh::ser::BorshSerialize,
        anchor_lang::solana_program::pubkey::Pubkey: borsh::ser::BorshSerialize,
        anchor_lang::solana_program::pubkey::Pubkey: borsh::ser::BorshSerialize,
        anchor_lang::solana_program::pubkey::Pubkey: borsh::ser::BorshSerialize,
    {
        fn serialize<W: borsh::maybestd::io::Write>(
            &self,
            writer: &mut W,
        ) -> ::core::result::Result<(), borsh::maybestd::io::Error> {
            borsh::BorshSerialize::serialize(&self.mint_authority_request, writer)?;
            borsh::BorshSerialize::serialize(&self.payer, writer)?;
            borsh::BorshSerialize::serialize(&self.mint_authority, writer)?;
            borsh::BorshSerialize::serialize(&self.tree_authority, writer)?;
            borsh::BorshSerialize::serialize(&self.system_program, writer)?;
            borsh::BorshSerialize::serialize(&self.merkle_slab, writer)?;
            Ok(())
        }
    }
    #[automatically_derived]
    impl anchor_lang::ToAccountMetas for SetMintRequest {
        fn to_account_metas(
            &self,
            is_signer: Option<bool>,
        ) -> Vec<anchor_lang::solana_program::instruction::AccountMeta> {
            let mut account_metas = ::alloc::vec::Vec::new();
            account_metas.push(anchor_lang::solana_program::instruction::AccountMeta::new(
                self.mint_authority_request,
                false,
            ));
            account_metas.push(anchor_lang::solana_program::instruction::AccountMeta::new(
                self.payer, true,
            ));
            account_metas.push(
                anchor_lang::solana_program::instruction::AccountMeta::new_readonly(
                    self.mint_authority,
                    true,
                ),
            );
            account_metas.push(anchor_lang::solana_program::instruction::AccountMeta::new(
                self.tree_authority,
                false,
            ));
            account_metas.push(
                anchor_lang::solana_program::instruction::AccountMeta::new_readonly(
                    self.system_program,
                    false,
                ),
            );
            account_metas.push(
                anchor_lang::solana_program::instruction::AccountMeta::new_readonly(
                    self.merkle_slab,
                    false,
                ),
            );
            account_metas
        }
    }
}
/// An internal, Anchor generated module. This is used (as an
/// implementation detail), to generate a CPI struct for a given
/// `#[derive(Accounts)]` implementation, where each field is an
/// AccountInfo.
///
/// To access the struct in this module, one should use the sibling
/// [`cpi::accounts`] module (also generated), which re-exports this.
pub(crate) mod __cpi_client_accounts_set_mint_request {
    use super::*;
    /// Generated CPI struct of the accounts for [`SetMintRequest`].
    pub struct SetMintRequest<'info> {
        pub mint_authority_request: anchor_lang::solana_program::account_info::AccountInfo<'info>,
        pub payer: anchor_lang::solana_program::account_info::AccountInfo<'info>,
        pub mint_authority: anchor_lang::solana_program::account_info::AccountInfo<'info>,
        pub tree_authority: anchor_lang::solana_program::account_info::AccountInfo<'info>,
        pub system_program: anchor_lang::solana_program::account_info::AccountInfo<'info>,
        pub merkle_slab: anchor_lang::solana_program::account_info::AccountInfo<'info>,
    }
    #[automatically_derived]
    impl<'info> anchor_lang::ToAccountMetas for SetMintRequest<'info> {
        fn to_account_metas(
            &self,
            is_signer: Option<bool>,
        ) -> Vec<anchor_lang::solana_program::instruction::AccountMeta> {
            let mut account_metas = ::alloc::vec::Vec::new();
            account_metas.push(anchor_lang::solana_program::instruction::AccountMeta::new(
                anchor_lang::Key::key(&self.mint_authority_request),
                false,
            ));
            account_metas.push(anchor_lang::solana_program::instruction::AccountMeta::new(
                anchor_lang::Key::key(&self.payer),
                true,
            ));
            account_metas.push(
                anchor_lang::solana_program::instruction::AccountMeta::new_readonly(
                    anchor_lang::Key::key(&self.mint_authority),
                    true,
                ),
            );
            account_metas.push(anchor_lang::solana_program::instruction::AccountMeta::new(
                anchor_lang::Key::key(&self.tree_authority),
                false,
            ));
            account_metas.push(
                anchor_lang::solana_program::instruction::AccountMeta::new_readonly(
                    anchor_lang::Key::key(&self.system_program),
                    false,
                ),
            );
            account_metas.push(
                anchor_lang::solana_program::instruction::AccountMeta::new_readonly(
                    anchor_lang::Key::key(&self.merkle_slab),
                    false,
                ),
            );
            account_metas
        }
    }
    #[automatically_derived]
    impl<'info> anchor_lang::ToAccountInfos<'info> for SetMintRequest<'info> {
        fn to_account_infos(
            &self,
        ) -> Vec<anchor_lang::solana_program::account_info::AccountInfo<'info>> {
            let mut account_infos = ::alloc::vec::Vec::new();
            account_infos.push(anchor_lang::ToAccountInfo::to_account_info(
                &self.mint_authority_request,
            ));
            account_infos.push(anchor_lang::ToAccountInfo::to_account_info(&self.payer));
            account_infos.push(anchor_lang::ToAccountInfo::to_account_info(
                &self.mint_authority,
            ));
            account_infos.push(anchor_lang::ToAccountInfo::to_account_info(
                &self.tree_authority,
            ));
            account_infos.push(anchor_lang::ToAccountInfo::to_account_info(
                &self.system_program,
            ));
            account_infos.push(anchor_lang::ToAccountInfo::to_account_info(
                &self.merkle_slab,
            ));
            account_infos
        }
    }
}
pub struct SetDefaultMintRequest<'info> {
    # [account (init_if_needed , space = MINT_REQUEST_SIZE , seeds = [merkle_slab . key () . as_ref () , tree_authority . key () . as_ref ()] , payer = payer , bump)]
    pub mint_authority_request: Account<'info, MintRequest>,
    #[account(mut)]
    pub payer: Signer<'info>,
    pub creator: Signer<'info>,
    # [account (mut , seeds = [merkle_slab . key () . as_ref ()] , bump , has_one = creator ,)]
    pub tree_authority: Account<'info, TreeConfig>,
    pub system_program: Program<'info, System>,
    /// CHECK: this account is neither read from or written to
    pub merkle_slab: UncheckedAccount<'info>,
}
#[automatically_derived]
impl<'info> anchor_lang::Accounts<'info> for SetDefaultMintRequest<'info>
where
    'info: 'info,
{
    #[inline(never)]
    fn try_accounts(
        program_id: &anchor_lang::solana_program::pubkey::Pubkey,
        accounts: &mut &[anchor_lang::solana_program::account_info::AccountInfo<'info>],
        ix_data: &[u8],
        __bumps: &mut std::collections::BTreeMap<String, u8>,
        __reallocs: &mut std::collections::BTreeSet<anchor_lang::solana_program::pubkey::Pubkey>,
    ) -> anchor_lang::Result<Self> {
        if accounts.is_empty() {
            return Err(anchor_lang::error::ErrorCode::AccountNotEnoughKeys.into());
        }
        let mint_authority_request = &accounts[0];
        *accounts = &accounts[1..];
        let payer: Signer =
            anchor_lang::Accounts::try_accounts(program_id, accounts, ix_data, __bumps, __reallocs)
                .map_err(|e| e.with_account_name("payer"))?;
        let creator: Signer =
            anchor_lang::Accounts::try_accounts(program_id, accounts, ix_data, __bumps, __reallocs)
                .map_err(|e| e.with_account_name("creator"))?;
        let tree_authority: anchor_lang::accounts::account::Account<TreeConfig> =
            anchor_lang::Accounts::try_accounts(program_id, accounts, ix_data, __bumps, __reallocs)
                .map_err(|e| e.with_account_name("tree_authority"))?;
        let system_program: anchor_lang::accounts::program::Program<System> =
            anchor_lang::Accounts::try_accounts(program_id, accounts, ix_data, __bumps, __reallocs)
                .map_err(|e| e.with_account_name("system_program"))?;
        let merkle_slab: UncheckedAccount =
            anchor_lang::Accounts::try_accounts(program_id, accounts, ix_data, __bumps, __reallocs)
                .map_err(|e| e.with_account_name("merkle_slab"))?;
        let __anchor_rent = Rent::get()?;
        let (__pda_address, __bump) = Pubkey::find_program_address(
            &[merkle_slab.key().as_ref(), tree_authority.key().as_ref()],
            program_id,
        );
        __bumps.insert("mint_authority_request".to_string(), __bump);
        let mint_authority_request = {
            let actual_field = mint_authority_request.to_account_info();
            let actual_owner = actual_field.owner;
            let space = MINT_REQUEST_SIZE;
            let pa: anchor_lang::accounts::account::Account<MintRequest> = if !true
                || actual_owner == &anchor_lang::solana_program::system_program::ID
            {
                let payer = payer.to_account_info();
                let __current_lamports = mint_authority_request.lamports();
                if __current_lamports == 0 {
                    let lamports = __anchor_rent.minimum_balance(space);
                    let cpi_accounts = anchor_lang::system_program::CreateAccount {
                        from: payer.to_account_info(),
                        to: mint_authority_request.to_account_info(),
                    };
                    let cpi_context = anchor_lang::context::CpiContext::new(
                        system_program.to_account_info(),
                        cpi_accounts,
                    );
                    anchor_lang::system_program::create_account(
                        cpi_context.with_signer(&[&[
                            merkle_slab.key().as_ref(),
                            tree_authority.key().as_ref(),
                            &[__bump][..],
                        ][..]]),
                        lamports,
                        space as u64,
                        program_id,
                    )?;
                } else {
                    let required_lamports = __anchor_rent
                        .minimum_balance(space)
                        .max(1)
                        .saturating_sub(__current_lamports);
                    if required_lamports > 0 {
                        let cpi_accounts = anchor_lang::system_program::Transfer {
                            from: payer.to_account_info(),
                            to: mint_authority_request.to_account_info(),
                        };
                        let cpi_context = anchor_lang::context::CpiContext::new(
                            system_program.to_account_info(),
                            cpi_accounts,
                        );
                        anchor_lang::system_program::transfer(cpi_context, required_lamports)?;
                    }
                    let cpi_accounts = anchor_lang::system_program::Allocate {
                        account_to_allocate: mint_authority_request.to_account_info(),
                    };
                    let cpi_context = anchor_lang::context::CpiContext::new(
                        system_program.to_account_info(),
                        cpi_accounts,
                    );
                    anchor_lang::system_program::allocate(
                        cpi_context.with_signer(&[&[
                            merkle_slab.key().as_ref(),
                            tree_authority.key().as_ref(),
                            &[__bump][..],
                        ][..]]),
                        space as u64,
                    )?;
                    let cpi_accounts = anchor_lang::system_program::Assign {
                        account_to_assign: mint_authority_request.to_account_info(),
                    };
                    let cpi_context = anchor_lang::context::CpiContext::new(
                        system_program.to_account_info(),
                        cpi_accounts,
                    );
                    anchor_lang::system_program::assign(
                        cpi_context.with_signer(&[&[
                            merkle_slab.key().as_ref(),
                            tree_authority.key().as_ref(),
                            &[__bump][..],
                        ][..]]),
                        program_id,
                    )?;
                }
                anchor_lang::accounts::account::Account::try_from_unchecked(&mint_authority_request)
                    .map_err(|e| e.with_account_name("mint_authority_request"))?
            } else {
                anchor_lang::accounts::account::Account::try_from(&mint_authority_request)
                    .map_err(|e| e.with_account_name("mint_authority_request"))?
            };
            if true {
                if space != actual_field.data_len() {
                    return Err(anchor_lang::error::Error::from(
                        anchor_lang::error::ErrorCode::ConstraintSpace,
                    )
                    .with_account_name("mint_authority_request")
                    .with_values((space, actual_field.data_len())));
                }
                if actual_owner != program_id {
                    return Err(anchor_lang::error::Error::from(
                        anchor_lang::error::ErrorCode::ConstraintOwner,
                    )
                    .with_account_name("mint_authority_request")
                    .with_pubkeys((*actual_owner, *program_id)));
                }
                {
                    let required_lamports = __anchor_rent.minimum_balance(space);
                    if pa.to_account_info().lamports() < required_lamports {
                        return Err(anchor_lang::error::Error::from(
                            anchor_lang::error::ErrorCode::ConstraintRentExempt,
                        )
                        .with_account_name("mint_authority_request"));
                    }
                }
            }
            pa
        };
        if mint_authority_request.key() != __pda_address {
            return Err(anchor_lang::error::Error::from(
                anchor_lang::error::ErrorCode::ConstraintSeeds,
            )
            .with_account_name("mint_authority_request")
            .with_pubkeys((mint_authority_request.key(), __pda_address)));
        }
        if !mint_authority_request.to_account_info().is_writable {
            return Err(anchor_lang::error::Error::from(
                anchor_lang::error::ErrorCode::ConstraintMut,
            )
            .with_account_name("mint_authority_request"));
        }
        if !__anchor_rent.is_exempt(
            mint_authority_request.to_account_info().lamports(),
            mint_authority_request.to_account_info().try_data_len()?,
        ) {
            return Err(anchor_lang::error::Error::from(
                anchor_lang::error::ErrorCode::ConstraintRentExempt,
            )
            .with_account_name("mint_authority_request"));
        }
        if !payer.to_account_info().is_writable {
            return Err(anchor_lang::error::Error::from(
                anchor_lang::error::ErrorCode::ConstraintMut,
            )
            .with_account_name("payer"));
        }
        let (__pda_address, __bump) =
            Pubkey::find_program_address(&[merkle_slab.key().as_ref()], &program_id);
        __bumps.insert("tree_authority".to_string(), __bump);
        if tree_authority.key() != __pda_address {
            return Err(anchor_lang::error::Error::from(
                anchor_lang::error::ErrorCode::ConstraintSeeds,
            )
            .with_account_name("tree_authority")
            .with_pubkeys((tree_authority.key(), __pda_address)));
        }
        if !tree_authority.to_account_info().is_writable {
            return Err(anchor_lang::error::Error::from(
                anchor_lang::error::ErrorCode::ConstraintMut,
            )
            .with_account_name("tree_authority"));
        }
        {
            let my_key = tree_authority.creator;
            let target_key = creator.key();
            if my_key != target_key {
                return Err(anchor_lang::error::Error::from(
                    anchor_lang::error::ErrorCode::ConstraintHasOne,
                )
                .with_account_name("tree_authority")
                .with_pubkeys((my_key, target_key)));
            }
        }
        Ok(SetDefaultMintRequest {
            mint_authority_request,
            payer,
            creator,
            tree_authority,
            system_program,
            merkle_slab,
        })
    }
}
#[automatically_derived]
impl<'info> anchor_lang::ToAccountInfos<'info> for SetDefaultMintRequest<'info>
where
    'info: 'info,
{
    fn to_account_infos(
        &self,
    ) -> Vec<anchor_lang::solana_program::account_info::AccountInfo<'info>> {
        let mut account_infos = ::alloc::vec::Vec::new();
        account_infos.extend(self.mint_authority_request.to_account_infos());
        account_infos.extend(self.payer.to_account_infos());
        account_infos.extend(self.creator.to_account_infos());
        account_infos.extend(self.tree_authority.to_account_infos());
        account_infos.extend(self.system_program.to_account_infos());
        account_infos.extend(self.merkle_slab.to_account_infos());
        account_infos
    }
}
#[automatically_derived]
impl<'info> anchor_lang::ToAccountMetas for SetDefaultMintRequest<'info> {
    fn to_account_metas(
        &self,
        is_signer: Option<bool>,
    ) -> Vec<anchor_lang::solana_program::instruction::AccountMeta> {
        let mut account_metas = ::alloc::vec::Vec::new();
        account_metas.extend(self.mint_authority_request.to_account_metas(None));
        account_metas.extend(self.payer.to_account_metas(None));
        account_metas.extend(self.creator.to_account_metas(None));
        account_metas.extend(self.tree_authority.to_account_metas(None));
        account_metas.extend(self.system_program.to_account_metas(None));
        account_metas.extend(self.merkle_slab.to_account_metas(None));
        account_metas
    }
}
#[automatically_derived]
impl<'info> anchor_lang::AccountsExit<'info> for SetDefaultMintRequest<'info>
where
    'info: 'info,
{
    fn exit(
        &self,
        program_id: &anchor_lang::solana_program::pubkey::Pubkey,
    ) -> anchor_lang::Result<()> {
        anchor_lang::AccountsExit::exit(&self.mint_authority_request, program_id)
            .map_err(|e| e.with_account_name("mint_authority_request"))?;
        anchor_lang::AccountsExit::exit(&self.payer, program_id)
            .map_err(|e| e.with_account_name("payer"))?;
        anchor_lang::AccountsExit::exit(&self.tree_authority, program_id)
            .map_err(|e| e.with_account_name("tree_authority"))?;
        Ok(())
    }
}
/// An internal, Anchor generated module. This is used (as an
/// implementation detail), to generate a struct for a given
/// `#[derive(Accounts)]` implementation, where each field is a Pubkey,
/// instead of an `AccountInfo`. This is useful for clients that want
/// to generate a list of accounts, without explicitly knowing the
/// order all the fields should be in.
///
/// To access the struct in this module, one should use the sibling
/// `accounts` module (also generated), which re-exports this.
pub(crate) mod __client_accounts_set_default_mint_request {
    use super::*;
    use anchor_lang::prelude::borsh;
    /// Generated client accounts for [`SetDefaultMintRequest`].
    pub struct SetDefaultMintRequest {
        pub mint_authority_request: anchor_lang::solana_program::pubkey::Pubkey,
        pub payer: anchor_lang::solana_program::pubkey::Pubkey,
        pub creator: anchor_lang::solana_program::pubkey::Pubkey,
        pub tree_authority: anchor_lang::solana_program::pubkey::Pubkey,
        pub system_program: anchor_lang::solana_program::pubkey::Pubkey,
        pub merkle_slab: anchor_lang::solana_program::pubkey::Pubkey,
    }
    impl borsh::ser::BorshSerialize for SetDefaultMintRequest
    where
        anchor_lang::solana_program::pubkey::Pubkey: borsh::ser::BorshSerialize,
        anchor_lang::solana_program::pubkey::Pubkey: borsh::ser::BorshSerialize,
        anchor_lang::solana_program::pubkey::Pubkey: borsh::ser::BorshSerialize,
        anchor_lang::solana_program::pubkey::Pubkey: borsh::ser::BorshSerialize,
        anchor_lang::solana_program::pubkey::Pubkey: borsh::ser::BorshSerialize,
        anchor_lang::solana_program::pubkey::Pubkey: borsh::ser::BorshSerialize,
    {
        fn serialize<W: borsh::maybestd::io::Write>(
            &self,
            writer: &mut W,
        ) -> ::core::result::Result<(), borsh::maybestd::io::Error> {
            borsh::BorshSerialize::serialize(&self.mint_authority_request, writer)?;
            borsh::BorshSerialize::serialize(&self.payer, writer)?;
            borsh::BorshSerialize::serialize(&self.creator, writer)?;
            borsh::BorshSerialize::serialize(&self.tree_authority, writer)?;
            borsh::BorshSerialize::serialize(&self.system_program, writer)?;
            borsh::BorshSerialize::serialize(&self.merkle_slab, writer)?;
            Ok(())
        }
    }
    #[automatically_derived]
    impl anchor_lang::ToAccountMetas for SetDefaultMintRequest {
        fn to_account_metas(
            &self,
            is_signer: Option<bool>,
        ) -> Vec<anchor_lang::solana_program::instruction::AccountMeta> {
            let mut account_metas = ::alloc::vec::Vec::new();
            account_metas.push(anchor_lang::solana_program::instruction::AccountMeta::new(
                self.mint_authority_request,
                false,
            ));
            account_metas.push(anchor_lang::solana_program::instruction::AccountMeta::new(
                self.payer, true,
            ));
            account_metas.push(
                anchor_lang::solana_program::instruction::AccountMeta::new_readonly(
                    self.creator,
                    true,
                ),
            );
            account_metas.push(anchor_lang::solana_program::instruction::AccountMeta::new(
                self.tree_authority,
                false,
            ));
            account_metas.push(
                anchor_lang::solana_program::instruction::AccountMeta::new_readonly(
                    self.system_program,
                    false,
                ),
            );
            account_metas.push(
                anchor_lang::solana_program::instruction::AccountMeta::new_readonly(
                    self.merkle_slab,
                    false,
                ),
            );
            account_metas
        }
    }
}
/// An internal, Anchor generated module. This is used (as an
/// implementation detail), to generate a CPI struct for a given
/// `#[derive(Accounts)]` implementation, where each field is an
/// AccountInfo.
///
/// To access the struct in this module, one should use the sibling
/// [`cpi::accounts`] module (also generated), which re-exports this.
pub(crate) mod __cpi_client_accounts_set_default_mint_request {
    use super::*;
    /// Generated CPI struct of the accounts for [`SetDefaultMintRequest`].
    pub struct SetDefaultMintRequest<'info> {
        pub mint_authority_request: anchor_lang::solana_program::account_info::AccountInfo<'info>,
        pub payer: anchor_lang::solana_program::account_info::AccountInfo<'info>,
        pub creator: anchor_lang::solana_program::account_info::AccountInfo<'info>,
        pub tree_authority: anchor_lang::solana_program::account_info::AccountInfo<'info>,
        pub system_program: anchor_lang::solana_program::account_info::AccountInfo<'info>,
        pub merkle_slab: anchor_lang::solana_program::account_info::AccountInfo<'info>,
    }
    #[automatically_derived]
    impl<'info> anchor_lang::ToAccountMetas for SetDefaultMintRequest<'info> {
        fn to_account_metas(
            &self,
            is_signer: Option<bool>,
        ) -> Vec<anchor_lang::solana_program::instruction::AccountMeta> {
            let mut account_metas = ::alloc::vec::Vec::new();
            account_metas.push(anchor_lang::solana_program::instruction::AccountMeta::new(
                anchor_lang::Key::key(&self.mint_authority_request),
                false,
            ));
            account_metas.push(anchor_lang::solana_program::instruction::AccountMeta::new(
                anchor_lang::Key::key(&self.payer),
                true,
            ));
            account_metas.push(
                anchor_lang::solana_program::instruction::AccountMeta::new_readonly(
                    anchor_lang::Key::key(&self.creator),
                    true,
                ),
            );
            account_metas.push(anchor_lang::solana_program::instruction::AccountMeta::new(
                anchor_lang::Key::key(&self.tree_authority),
                false,
            ));
            account_metas.push(
                anchor_lang::solana_program::instruction::AccountMeta::new_readonly(
                    anchor_lang::Key::key(&self.system_program),
                    false,
                ),
            );
            account_metas.push(
                anchor_lang::solana_program::instruction::AccountMeta::new_readonly(
                    anchor_lang::Key::key(&self.merkle_slab),
                    false,
                ),
            );
            account_metas
        }
    }
    #[automatically_derived]
    impl<'info> anchor_lang::ToAccountInfos<'info> for SetDefaultMintRequest<'info> {
        fn to_account_infos(
            &self,
        ) -> Vec<anchor_lang::solana_program::account_info::AccountInfo<'info>> {
            let mut account_infos = ::alloc::vec::Vec::new();
            account_infos.push(anchor_lang::ToAccountInfo::to_account_info(
                &self.mint_authority_request,
            ));
            account_infos.push(anchor_lang::ToAccountInfo::to_account_info(&self.payer));
            account_infos.push(anchor_lang::ToAccountInfo::to_account_info(&self.creator));
            account_infos.push(anchor_lang::ToAccountInfo::to_account_info(
                &self.tree_authority,
            ));
            account_infos.push(anchor_lang::ToAccountInfo::to_account_info(
                &self.system_program,
            ));
            account_infos.push(anchor_lang::ToAccountInfo::to_account_info(
                &self.merkle_slab,
            ));
            account_infos
        }
    }
}
pub struct ApproveMintRequest<'info> {
    # [account (mut , seeds = [merkle_slab . key () . as_ref () , mint_authority_request . mint_authority . as_ref ()] , bump)]
    pub mint_authority_request: Account<'info, MintRequest>,
    # [account (constraint = * tree_delegate . key == tree_authority . creator || * tree_delegate . key == tree_authority . delegate)]
    pub tree_delegate: Signer<'info>,
    # [account (mut , seeds = [merkle_slab . key () . as_ref ()] , bump)]
    pub tree_authority: Account<'info, TreeConfig>,
    /// CHECK: this account is neither read from or written to
    pub merkle_slab: UncheckedAccount<'info>,
}
#[automatically_derived]
impl<'info> anchor_lang::Accounts<'info> for ApproveMintRequest<'info>
where
    'info: 'info,
{
    #[inline(never)]
    fn try_accounts(
        program_id: &anchor_lang::solana_program::pubkey::Pubkey,
        accounts: &mut &[anchor_lang::solana_program::account_info::AccountInfo<'info>],
        ix_data: &[u8],
        __bumps: &mut std::collections::BTreeMap<String, u8>,
        __reallocs: &mut std::collections::BTreeSet<anchor_lang::solana_program::pubkey::Pubkey>,
    ) -> anchor_lang::Result<Self> {
        let mint_authority_request: anchor_lang::accounts::account::Account<MintRequest> =
            anchor_lang::Accounts::try_accounts(program_id, accounts, ix_data, __bumps, __reallocs)
                .map_err(|e| e.with_account_name("mint_authority_request"))?;
        let tree_delegate: Signer =
            anchor_lang::Accounts::try_accounts(program_id, accounts, ix_data, __bumps, __reallocs)
                .map_err(|e| e.with_account_name("tree_delegate"))?;
        let tree_authority: anchor_lang::accounts::account::Account<TreeConfig> =
            anchor_lang::Accounts::try_accounts(program_id, accounts, ix_data, __bumps, __reallocs)
                .map_err(|e| e.with_account_name("tree_authority"))?;
        let merkle_slab: UncheckedAccount =
            anchor_lang::Accounts::try_accounts(program_id, accounts, ix_data, __bumps, __reallocs)
                .map_err(|e| e.with_account_name("merkle_slab"))?;
        let (__pda_address, __bump) = Pubkey::find_program_address(
            &[
                merkle_slab.key().as_ref(),
                mint_authority_request.mint_authority.as_ref(),
            ],
            &program_id,
        );
        __bumps.insert("mint_authority_request".to_string(), __bump);
        if mint_authority_request.key() != __pda_address {
            return Err(anchor_lang::error::Error::from(
                anchor_lang::error::ErrorCode::ConstraintSeeds,
            )
            .with_account_name("mint_authority_request")
            .with_pubkeys((mint_authority_request.key(), __pda_address)));
        }
        if !mint_authority_request.to_account_info().is_writable {
            return Err(anchor_lang::error::Error::from(
                anchor_lang::error::ErrorCode::ConstraintMut,
            )
            .with_account_name("mint_authority_request"));
        }
        if !(*tree_delegate.key == tree_authority.creator
            || *tree_delegate.key == tree_authority.delegate)
        {
            return Err(anchor_lang::error::Error::from(
                anchor_lang::error::ErrorCode::ConstraintRaw,
            )
            .with_account_name("tree_delegate"));
        }
        let (__pda_address, __bump) =
            Pubkey::find_program_address(&[merkle_slab.key().as_ref()], &program_id);
        __bumps.insert("tree_authority".to_string(), __bump);
        if tree_authority.key() != __pda_address {
            return Err(anchor_lang::error::Error::from(
                anchor_lang::error::ErrorCode::ConstraintSeeds,
            )
            .with_account_name("tree_authority")
            .with_pubkeys((tree_authority.key(), __pda_address)));
        }
        if !tree_authority.to_account_info().is_writable {
            return Err(anchor_lang::error::Error::from(
                anchor_lang::error::ErrorCode::ConstraintMut,
            )
            .with_account_name("tree_authority"));
        }
        Ok(ApproveMintRequest {
            mint_authority_request,
            tree_delegate,
            tree_authority,
            merkle_slab,
        })
    }
}
#[automatically_derived]
impl<'info> anchor_lang::ToAccountInfos<'info> for ApproveMintRequest<'info>
where
    'info: 'info,
{
    fn to_account_infos(
        &self,
    ) -> Vec<anchor_lang::solana_program::account_info::AccountInfo<'info>> {
        let mut account_infos = ::alloc::vec::Vec::new();
        account_infos.extend(self.mint_authority_request.to_account_infos());
        account_infos.extend(self.tree_delegate.to_account_infos());
        account_infos.extend(self.tree_authority.to_account_infos());
        account_infos.extend(self.merkle_slab.to_account_infos());
        account_infos
    }
}
#[automatically_derived]
impl<'info> anchor_lang::ToAccountMetas for ApproveMintRequest<'info> {
    fn to_account_metas(
        &self,
        is_signer: Option<bool>,
    ) -> Vec<anchor_lang::solana_program::instruction::AccountMeta> {
        let mut account_metas = ::alloc::vec::Vec::new();
        account_metas.extend(self.mint_authority_request.to_account_metas(None));
        account_metas.extend(self.tree_delegate.to_account_metas(None));
        account_metas.extend(self.tree_authority.to_account_metas(None));
        account_metas.extend(self.merkle_slab.to_account_metas(None));
        account_metas
    }
}
#[automatically_derived]
impl<'info> anchor_lang::AccountsExit<'info> for ApproveMintRequest<'info>
where
    'info: 'info,
{
    fn exit(
        &self,
        program_id: &anchor_lang::solana_program::pubkey::Pubkey,
    ) -> anchor_lang::Result<()> {
        anchor_lang::AccountsExit::exit(&self.mint_authority_request, program_id)
            .map_err(|e| e.with_account_name("mint_authority_request"))?;
        anchor_lang::AccountsExit::exit(&self.tree_authority, program_id)
            .map_err(|e| e.with_account_name("tree_authority"))?;
        Ok(())
    }
}
/// An internal, Anchor generated module. This is used (as an
/// implementation detail), to generate a struct for a given
/// `#[derive(Accounts)]` implementation, where each field is a Pubkey,
/// instead of an `AccountInfo`. This is useful for clients that want
/// to generate a list of accounts, without explicitly knowing the
/// order all the fields should be in.
///
/// To access the struct in this module, one should use the sibling
/// `accounts` module (also generated), which re-exports this.
pub(crate) mod __client_accounts_approve_mint_request {
    use super::*;
    use anchor_lang::prelude::borsh;
    /// Generated client accounts for [`ApproveMintRequest`].
    pub struct ApproveMintRequest {
        pub mint_authority_request: anchor_lang::solana_program::pubkey::Pubkey,
        pub tree_delegate: anchor_lang::solana_program::pubkey::Pubkey,
        pub tree_authority: anchor_lang::solana_program::pubkey::Pubkey,
        pub merkle_slab: anchor_lang::solana_program::pubkey::Pubkey,
    }
    impl borsh::ser::BorshSerialize for ApproveMintRequest
    where
        anchor_lang::solana_program::pubkey::Pubkey: borsh::ser::BorshSerialize,
        anchor_lang::solana_program::pubkey::Pubkey: borsh::ser::BorshSerialize,
        anchor_lang::solana_program::pubkey::Pubkey: borsh::ser::BorshSerialize,
        anchor_lang::solana_program::pubkey::Pubkey: borsh::ser::BorshSerialize,
    {
        fn serialize<W: borsh::maybestd::io::Write>(
            &self,
            writer: &mut W,
        ) -> ::core::result::Result<(), borsh::maybestd::io::Error> {
            borsh::BorshSerialize::serialize(&self.mint_authority_request, writer)?;
            borsh::BorshSerialize::serialize(&self.tree_delegate, writer)?;
            borsh::BorshSerialize::serialize(&self.tree_authority, writer)?;
            borsh::BorshSerialize::serialize(&self.merkle_slab, writer)?;
            Ok(())
        }
    }
    #[automatically_derived]
    impl anchor_lang::ToAccountMetas for ApproveMintRequest {
        fn to_account_metas(
            &self,
            is_signer: Option<bool>,
        ) -> Vec<anchor_lang::solana_program::instruction::AccountMeta> {
            let mut account_metas = ::alloc::vec::Vec::new();
            account_metas.push(anchor_lang::solana_program::instruction::AccountMeta::new(
                self.mint_authority_request,
                false,
            ));
            account_metas.push(
                anchor_lang::solana_program::instruction::AccountMeta::new_readonly(
                    self.tree_delegate,
                    true,
                ),
            );
            account_metas.push(anchor_lang::solana_program::instruction::AccountMeta::new(
                self.tree_authority,
                false,
            ));
            account_metas.push(
                anchor_lang::solana_program::instruction::AccountMeta::new_readonly(
                    self.merkle_slab,
                    false,
                ),
            );
            account_metas
        }
    }
}
/// An internal, Anchor generated module. This is used (as an
/// implementation detail), to generate a CPI struct for a given
/// `#[derive(Accounts)]` implementation, where each field is an
/// AccountInfo.
///
/// To access the struct in this module, one should use the sibling
/// [`cpi::accounts`] module (also generated), which re-exports this.
pub(crate) mod __cpi_client_accounts_approve_mint_request {
    use super::*;
    /// Generated CPI struct of the accounts for [`ApproveMintRequest`].
    pub struct ApproveMintRequest<'info> {
        pub mint_authority_request: anchor_lang::solana_program::account_info::AccountInfo<'info>,
        pub tree_delegate: anchor_lang::solana_program::account_info::AccountInfo<'info>,
        pub tree_authority: anchor_lang::solana_program::account_info::AccountInfo<'info>,
        pub merkle_slab: anchor_lang::solana_program::account_info::AccountInfo<'info>,
    }
    #[automatically_derived]
    impl<'info> anchor_lang::ToAccountMetas for ApproveMintRequest<'info> {
        fn to_account_metas(
            &self,
            is_signer: Option<bool>,
        ) -> Vec<anchor_lang::solana_program::instruction::AccountMeta> {
            let mut account_metas = ::alloc::vec::Vec::new();
            account_metas.push(anchor_lang::solana_program::instruction::AccountMeta::new(
                anchor_lang::Key::key(&self.mint_authority_request),
                false,
            ));
            account_metas.push(
                anchor_lang::solana_program::instruction::AccountMeta::new_readonly(
                    anchor_lang::Key::key(&self.tree_delegate),
                    true,
                ),
            );
            account_metas.push(anchor_lang::solana_program::instruction::AccountMeta::new(
                anchor_lang::Key::key(&self.tree_authority),
                false,
            ));
            account_metas.push(
                anchor_lang::solana_program::instruction::AccountMeta::new_readonly(
                    anchor_lang::Key::key(&self.merkle_slab),
                    false,
                ),
            );
            account_metas
        }
    }
    #[automatically_derived]
    impl<'info> anchor_lang::ToAccountInfos<'info> for ApproveMintRequest<'info> {
        fn to_account_infos(
            &self,
        ) -> Vec<anchor_lang::solana_program::account_info::AccountInfo<'info>> {
            let mut account_infos = ::alloc::vec::Vec::new();
            account_infos.push(anchor_lang::ToAccountInfo::to_account_info(
                &self.mint_authority_request,
            ));
            account_infos.push(anchor_lang::ToAccountInfo::to_account_info(
                &self.tree_delegate,
            ));
            account_infos.push(anchor_lang::ToAccountInfo::to_account_info(
                &self.tree_authority,
            ));
            account_infos.push(anchor_lang::ToAccountInfo::to_account_info(
                &self.merkle_slab,
            ));
            account_infos
        }
    }
}
pub struct CloseMintRequest<'info> {
    # [account (mut , close = mint_authority , seeds = [merkle_slab . key () . as_ref () , mint_authority . key () . as_ref ()] , bump)]
    pub mint_authority_request: Account<'info, MintRequest>,
    #[account(mut)]
    pub mint_authority: Signer<'info>,
    # [account (mut , seeds = [merkle_slab . key () . as_ref ()] , bump)]
    pub tree_authority: Account<'info, TreeConfig>,
    /// CHECK: this account is neither read from or written to
    pub merkle_slab: UncheckedAccount<'info>,
}
#[automatically_derived]
impl<'info> anchor_lang::Accounts<'info> for CloseMintRequest<'info>
where
    'info: 'info,
{
    #[inline(never)]
    fn try_accounts(
        program_id: &anchor_lang::solana_program::pubkey::Pubkey,
        accounts: &mut &[anchor_lang::solana_program::account_info::AccountInfo<'info>],
        ix_data: &[u8],
        __bumps: &mut std::collections::BTreeMap<String, u8>,
        __reallocs: &mut std::collections::BTreeSet<anchor_lang::solana_program::pubkey::Pubkey>,
    ) -> anchor_lang::Result<Self> {
        let mint_authority_request: anchor_lang::accounts::account::Account<MintRequest> =
            anchor_lang::Accounts::try_accounts(program_id, accounts, ix_data, __bumps, __reallocs)
                .map_err(|e| e.with_account_name("mint_authority_request"))?;
        let mint_authority: Signer =
            anchor_lang::Accounts::try_accounts(program_id, accounts, ix_data, __bumps, __reallocs)
                .map_err(|e| e.with_account_name("mint_authority"))?;
        let tree_authority: anchor_lang::accounts::account::Account<TreeConfig> =
            anchor_lang::Accounts::try_accounts(program_id, accounts, ix_data, __bumps, __reallocs)
                .map_err(|e| e.with_account_name("tree_authority"))?;
        let merkle_slab: UncheckedAccount =
            anchor_lang::Accounts::try_accounts(program_id, accounts, ix_data, __bumps, __reallocs)
                .map_err(|e| e.with_account_name("merkle_slab"))?;
        let (__pda_address, __bump) = Pubkey::find_program_address(
            &[merkle_slab.key().as_ref(), mint_authority.key().as_ref()],
            &program_id,
        );
        __bumps.insert("mint_authority_request".to_string(), __bump);
        if mint_authority_request.key() != __pda_address {
            return Err(anchor_lang::error::Error::from(
                anchor_lang::error::ErrorCode::ConstraintSeeds,
            )
            .with_account_name("mint_authority_request")
            .with_pubkeys((mint_authority_request.key(), __pda_address)));
        }
        if !mint_authority_request.to_account_info().is_writable {
            return Err(anchor_lang::error::Error::from(
                anchor_lang::error::ErrorCode::ConstraintMut,
            )
            .with_account_name("mint_authority_request"));
        }
        if mint_authority_request.key() == mint_authority.key() {
            return Err(anchor_lang::error::Error::from(
                anchor_lang::error::ErrorCode::ConstraintClose,
            )
            .with_account_name("mint_authority_request"));
        }
        if !mint_authority.to_account_info().is_writable {
            return Err(anchor_lang::error::Error::from(
                anchor_lang::error::ErrorCode::ConstraintMut,
            )
            .with_account_name("mint_authority"));
        }
        let (__pda_address, __bump) =
            Pubkey::find_program_address(&[merkle_slab.key().as_ref()], &program_id);
        __bumps.insert("tree_authority".to_string(), __bump);
        if tree_authority.key() != __pda_address {
            return Err(anchor_lang::error::Error::from(
                anchor_lang::error::ErrorCode::ConstraintSeeds,
            )
            .with_account_name("tree_authority")
            .with_pubkeys((tree_authority.key(), __pda_address)));
        }
        if !tree_authority.to_account_info().is_writable {
            return Err(anchor_lang::error::Error::from(
                anchor_lang::error::ErrorCode::ConstraintMut,
            )
            .with_account_name("tree_authority"));
        }
        Ok(CloseMintRequest {
            mint_authority_request,
            mint_authority,
            tree_authority,
            merkle_slab,
        })
    }
}
#[automatically_derived]
impl<'info> anchor_lang::ToAccountInfos<'info> for CloseMintRequest<'info>
where
    'info: 'info,
{
    fn to_account_infos(
        &self,
    ) -> Vec<anchor_lang::solana_program::account_info::AccountInfo<'info>> {
        let mut account_infos = ::alloc::vec::Vec::new();
        account_infos.extend(self.mint_authority_request.to_account_infos());
        account_infos.extend(self.mint_authority.to_account_infos());
        account_infos.extend(self.tree_authority.to_account_infos());
        account_infos.extend(self.merkle_slab.to_account_infos());
        account_infos
    }
}
#[automatically_derived]
impl<'info> anchor_lang::ToAccountMetas for CloseMintRequest<'info> {
    fn to_account_metas(
        &self,
        is_signer: Option<bool>,
    ) -> Vec<anchor_lang::solana_program::instruction::AccountMeta> {
        let mut account_metas = ::alloc::vec::Vec::new();
        account_metas.extend(self.mint_authority_request.to_account_metas(None));
        account_metas.extend(self.mint_authority.to_account_metas(None));
        account_metas.extend(self.tree_authority.to_account_metas(None));
        account_metas.extend(self.merkle_slab.to_account_metas(None));
        account_metas
    }
}
#[automatically_derived]
impl<'info> anchor_lang::AccountsExit<'info> for CloseMintRequest<'info>
where
    'info: 'info,
{
    fn exit(
        &self,
        program_id: &anchor_lang::solana_program::pubkey::Pubkey,
    ) -> anchor_lang::Result<()> {
        anchor_lang::AccountsClose::close(
            &self.mint_authority_request,
            self.mint_authority.to_account_info(),
        )
        .map_err(|e| e.with_account_name("mint_authority_request"))?;
        anchor_lang::AccountsExit::exit(&self.mint_authority, program_id)
            .map_err(|e| e.with_account_name("mint_authority"))?;
        anchor_lang::AccountsExit::exit(&self.tree_authority, program_id)
            .map_err(|e| e.with_account_name("tree_authority"))?;
        Ok(())
    }
}
/// An internal, Anchor generated module. This is used (as an
/// implementation detail), to generate a struct for a given
/// `#[derive(Accounts)]` implementation, where each field is a Pubkey,
/// instead of an `AccountInfo`. This is useful for clients that want
/// to generate a list of accounts, without explicitly knowing the
/// order all the fields should be in.
///
/// To access the struct in this module, one should use the sibling
/// `accounts` module (also generated), which re-exports this.
pub(crate) mod __client_accounts_close_mint_request {
    use super::*;
    use anchor_lang::prelude::borsh;
    /// Generated client accounts for [`CloseMintRequest`].
    pub struct CloseMintRequest {
        pub mint_authority_request: anchor_lang::solana_program::pubkey::Pubkey,
        pub mint_authority: anchor_lang::solana_program::pubkey::Pubkey,
        pub tree_authority: anchor_lang::solana_program::pubkey::Pubkey,
        pub merkle_slab: anchor_lang::solana_program::pubkey::Pubkey,
    }
    impl borsh::ser::BorshSerialize for CloseMintRequest
    where
        anchor_lang::solana_program::pubkey::Pubkey: borsh::ser::BorshSerialize,
        anchor_lang::solana_program::pubkey::Pubkey: borsh::ser::BorshSerialize,
        anchor_lang::solana_program::pubkey::Pubkey: borsh::ser::BorshSerialize,
        anchor_lang::solana_program::pubkey::Pubkey: borsh::ser::BorshSerialize,
    {
        fn serialize<W: borsh::maybestd::io::Write>(
            &self,
            writer: &mut W,
        ) -> ::core::result::Result<(), borsh::maybestd::io::Error> {
            borsh::BorshSerialize::serialize(&self.mint_authority_request, writer)?;
            borsh::BorshSerialize::serialize(&self.mint_authority, writer)?;
            borsh::BorshSerialize::serialize(&self.tree_authority, writer)?;
            borsh::BorshSerialize::serialize(&self.merkle_slab, writer)?;
            Ok(())
        }
    }
    #[automatically_derived]
    impl anchor_lang::ToAccountMetas for CloseMintRequest {
        fn to_account_metas(
            &self,
            is_signer: Option<bool>,
        ) -> Vec<anchor_lang::solana_program::instruction::AccountMeta> {
            let mut account_metas = ::alloc::vec::Vec::new();
            account_metas.push(anchor_lang::solana_program::instruction::AccountMeta::new(
                self.mint_authority_request,
                false,
            ));
            account_metas.push(anchor_lang::solana_program::instruction::AccountMeta::new(
                self.mint_authority,
                true,
            ));
            account_metas.push(anchor_lang::solana_program::instruction::AccountMeta::new(
                self.tree_authority,
                false,
            ));
            account_metas.push(
                anchor_lang::solana_program::instruction::AccountMeta::new_readonly(
                    self.merkle_slab,
                    false,
                ),
            );
            account_metas
        }
    }
}
/// An internal, Anchor generated module. This is used (as an
/// implementation detail), to generate a CPI struct for a given
/// `#[derive(Accounts)]` implementation, where each field is an
/// AccountInfo.
///
/// To access the struct in this module, one should use the sibling
/// [`cpi::accounts`] module (also generated), which re-exports this.
pub(crate) mod __cpi_client_accounts_close_mint_request {
    use super::*;
    /// Generated CPI struct of the accounts for [`CloseMintRequest`].
    pub struct CloseMintRequest<'info> {
        pub mint_authority_request: anchor_lang::solana_program::account_info::AccountInfo<'info>,
        pub mint_authority: anchor_lang::solana_program::account_info::AccountInfo<'info>,
        pub tree_authority: anchor_lang::solana_program::account_info::AccountInfo<'info>,
        pub merkle_slab: anchor_lang::solana_program::account_info::AccountInfo<'info>,
    }
    #[automatically_derived]
    impl<'info> anchor_lang::ToAccountMetas for CloseMintRequest<'info> {
        fn to_account_metas(
            &self,
            is_signer: Option<bool>,
        ) -> Vec<anchor_lang::solana_program::instruction::AccountMeta> {
            let mut account_metas = ::alloc::vec::Vec::new();
            account_metas.push(anchor_lang::solana_program::instruction::AccountMeta::new(
                anchor_lang::Key::key(&self.mint_authority_request),
                false,
            ));
            account_metas.push(anchor_lang::solana_program::instruction::AccountMeta::new(
                anchor_lang::Key::key(&self.mint_authority),
                true,
            ));
            account_metas.push(anchor_lang::solana_program::instruction::AccountMeta::new(
                anchor_lang::Key::key(&self.tree_authority),
                false,
            ));
            account_metas.push(
                anchor_lang::solana_program::instruction::AccountMeta::new_readonly(
                    anchor_lang::Key::key(&self.merkle_slab),
                    false,
                ),
            );
            account_metas
        }
    }
    #[automatically_derived]
    impl<'info> anchor_lang::ToAccountInfos<'info> for CloseMintRequest<'info> {
        fn to_account_infos(
            &self,
        ) -> Vec<anchor_lang::solana_program::account_info::AccountInfo<'info>> {
            let mut account_infos = ::alloc::vec::Vec::new();
            account_infos.push(anchor_lang::ToAccountInfo::to_account_info(
                &self.mint_authority_request,
            ));
            account_infos.push(anchor_lang::ToAccountInfo::to_account_info(
                &self.mint_authority,
            ));
            account_infos.push(anchor_lang::ToAccountInfo::to_account_info(
                &self.tree_authority,
            ));
            account_infos.push(anchor_lang::ToAccountInfo::to_account_info(
                &self.merkle_slab,
            ));
            account_infos
        }
    }
}
pub struct SetTreeDelegate<'info> {
    pub creator: Signer<'info>,
    /// CHECK: this account is neither read from or written to
    pub new_delegate: UncheckedAccount<'info>,
    /// CHECK: this account is neither read from or written to
    pub merkle_slab: UncheckedAccount<'info>,
    # [account (mut , seeds = [merkle_slab . key () . as_ref ()] , bump , has_one = creator)]
    pub tree_authority: Account<'info, TreeConfig>,
}
#[automatically_derived]
impl<'info> anchor_lang::Accounts<'info> for SetTreeDelegate<'info>
where
    'info: 'info,
{
    #[inline(never)]
    fn try_accounts(
        program_id: &anchor_lang::solana_program::pubkey::Pubkey,
        accounts: &mut &[anchor_lang::solana_program::account_info::AccountInfo<'info>],
        ix_data: &[u8],
        __bumps: &mut std::collections::BTreeMap<String, u8>,
        __reallocs: &mut std::collections::BTreeSet<anchor_lang::solana_program::pubkey::Pubkey>,
    ) -> anchor_lang::Result<Self> {
        let creator: Signer =
            anchor_lang::Accounts::try_accounts(program_id, accounts, ix_data, __bumps, __reallocs)
                .map_err(|e| e.with_account_name("creator"))?;
        let new_delegate: UncheckedAccount =
            anchor_lang::Accounts::try_accounts(program_id, accounts, ix_data, __bumps, __reallocs)
                .map_err(|e| e.with_account_name("new_delegate"))?;
        let merkle_slab: UncheckedAccount =
            anchor_lang::Accounts::try_accounts(program_id, accounts, ix_data, __bumps, __reallocs)
                .map_err(|e| e.with_account_name("merkle_slab"))?;
        let tree_authority: anchor_lang::accounts::account::Account<TreeConfig> =
            anchor_lang::Accounts::try_accounts(program_id, accounts, ix_data, __bumps, __reallocs)
                .map_err(|e| e.with_account_name("tree_authority"))?;
        let (__pda_address, __bump) =
            Pubkey::find_program_address(&[merkle_slab.key().as_ref()], &program_id);
        __bumps.insert("tree_authority".to_string(), __bump);
        if tree_authority.key() != __pda_address {
            return Err(anchor_lang::error::Error::from(
                anchor_lang::error::ErrorCode::ConstraintSeeds,
            )
            .with_account_name("tree_authority")
            .with_pubkeys((tree_authority.key(), __pda_address)));
        }
        if !tree_authority.to_account_info().is_writable {
            return Err(anchor_lang::error::Error::from(
                anchor_lang::error::ErrorCode::ConstraintMut,
            )
            .with_account_name("tree_authority"));
        }
        {
            let my_key = tree_authority.creator;
            let target_key = creator.key();
            if my_key != target_key {
                return Err(anchor_lang::error::Error::from(
                    anchor_lang::error::ErrorCode::ConstraintHasOne,
                )
                .with_account_name("tree_authority")
                .with_pubkeys((my_key, target_key)));
            }
        }
        Ok(SetTreeDelegate {
            creator,
            new_delegate,
            merkle_slab,
            tree_authority,
        })
    }
}
#[automatically_derived]
impl<'info> anchor_lang::ToAccountInfos<'info> for SetTreeDelegate<'info>
where
    'info: 'info,
{
    fn to_account_infos(
        &self,
    ) -> Vec<anchor_lang::solana_program::account_info::AccountInfo<'info>> {
        let mut account_infos = ::alloc::vec::Vec::new();
        account_infos.extend(self.creator.to_account_infos());
        account_infos.extend(self.new_delegate.to_account_infos());
        account_infos.extend(self.merkle_slab.to_account_infos());
        account_infos.extend(self.tree_authority.to_account_infos());
        account_infos
    }
}
#[automatically_derived]
impl<'info> anchor_lang::ToAccountMetas for SetTreeDelegate<'info> {
    fn to_account_metas(
        &self,
        is_signer: Option<bool>,
    ) -> Vec<anchor_lang::solana_program::instruction::AccountMeta> {
        let mut account_metas = ::alloc::vec::Vec::new();
        account_metas.extend(self.creator.to_account_metas(None));
        account_metas.extend(self.new_delegate.to_account_metas(None));
        account_metas.extend(self.merkle_slab.to_account_metas(None));
        account_metas.extend(self.tree_authority.to_account_metas(None));
        account_metas
    }
}
#[automatically_derived]
impl<'info> anchor_lang::AccountsExit<'info> for SetTreeDelegate<'info>
where
    'info: 'info,
{
    fn exit(
        &self,
        program_id: &anchor_lang::solana_program::pubkey::Pubkey,
    ) -> anchor_lang::Result<()> {
        anchor_lang::AccountsExit::exit(&self.tree_authority, program_id)
            .map_err(|e| e.with_account_name("tree_authority"))?;
        Ok(())
    }
}
/// An internal, Anchor generated module. This is used (as an
/// implementation detail), to generate a struct for a given
/// `#[derive(Accounts)]` implementation, where each field is a Pubkey,
/// instead of an `AccountInfo`. This is useful for clients that want
/// to generate a list of accounts, without explicitly knowing the
/// order all the fields should be in.
///
/// To access the struct in this module, one should use the sibling
/// `accounts` module (also generated), which re-exports this.
pub(crate) mod __client_accounts_set_tree_delegate {
    use super::*;
    use anchor_lang::prelude::borsh;
    /// Generated client accounts for [`SetTreeDelegate`].
    pub struct SetTreeDelegate {
        pub creator: anchor_lang::solana_program::pubkey::Pubkey,
        pub new_delegate: anchor_lang::solana_program::pubkey::Pubkey,
        pub merkle_slab: anchor_lang::solana_program::pubkey::Pubkey,
        pub tree_authority: anchor_lang::solana_program::pubkey::Pubkey,
    }
    impl borsh::ser::BorshSerialize for SetTreeDelegate
    where
        anchor_lang::solana_program::pubkey::Pubkey: borsh::ser::BorshSerialize,
        anchor_lang::solana_program::pubkey::Pubkey: borsh::ser::BorshSerialize,
        anchor_lang::solana_program::pubkey::Pubkey: borsh::ser::BorshSerialize,
        anchor_lang::solana_program::pubkey::Pubkey: borsh::ser::BorshSerialize,
    {
        fn serialize<W: borsh::maybestd::io::Write>(
            &self,
            writer: &mut W,
        ) -> ::core::result::Result<(), borsh::maybestd::io::Error> {
            borsh::BorshSerialize::serialize(&self.creator, writer)?;
            borsh::BorshSerialize::serialize(&self.new_delegate, writer)?;
            borsh::BorshSerialize::serialize(&self.merkle_slab, writer)?;
            borsh::BorshSerialize::serialize(&self.tree_authority, writer)?;
            Ok(())
        }
    }
    #[automatically_derived]
    impl anchor_lang::ToAccountMetas for SetTreeDelegate {
        fn to_account_metas(
            &self,
            is_signer: Option<bool>,
        ) -> Vec<anchor_lang::solana_program::instruction::AccountMeta> {
            let mut account_metas = ::alloc::vec::Vec::new();
            account_metas.push(
                anchor_lang::solana_program::instruction::AccountMeta::new_readonly(
                    self.creator,
                    true,
                ),
            );
            account_metas.push(
                anchor_lang::solana_program::instruction::AccountMeta::new_readonly(
                    self.new_delegate,
                    false,
                ),
            );
            account_metas.push(
                anchor_lang::solana_program::instruction::AccountMeta::new_readonly(
                    self.merkle_slab,
                    false,
                ),
            );
            account_metas.push(anchor_lang::solana_program::instruction::AccountMeta::new(
                self.tree_authority,
                false,
            ));
            account_metas
        }
    }
}
/// An internal, Anchor generated module. This is used (as an
/// implementation detail), to generate a CPI struct for a given
/// `#[derive(Accounts)]` implementation, where each field is an
/// AccountInfo.
///
/// To access the struct in this module, one should use the sibling
/// [`cpi::accounts`] module (also generated), which re-exports this.
pub(crate) mod __cpi_client_accounts_set_tree_delegate {
    use super::*;
    /// Generated CPI struct of the accounts for [`SetTreeDelegate`].
    pub struct SetTreeDelegate<'info> {
        pub creator: anchor_lang::solana_program::account_info::AccountInfo<'info>,
        pub new_delegate: anchor_lang::solana_program::account_info::AccountInfo<'info>,
        pub merkle_slab: anchor_lang::solana_program::account_info::AccountInfo<'info>,
        pub tree_authority: anchor_lang::solana_program::account_info::AccountInfo<'info>,
    }
    #[automatically_derived]
    impl<'info> anchor_lang::ToAccountMetas for SetTreeDelegate<'info> {
        fn to_account_metas(
            &self,
            is_signer: Option<bool>,
        ) -> Vec<anchor_lang::solana_program::instruction::AccountMeta> {
            let mut account_metas = ::alloc::vec::Vec::new();
            account_metas.push(
                anchor_lang::solana_program::instruction::AccountMeta::new_readonly(
                    anchor_lang::Key::key(&self.creator),
                    true,
                ),
            );
            account_metas.push(
                anchor_lang::solana_program::instruction::AccountMeta::new_readonly(
                    anchor_lang::Key::key(&self.new_delegate),
                    false,
                ),
            );
            account_metas.push(
                anchor_lang::solana_program::instruction::AccountMeta::new_readonly(
                    anchor_lang::Key::key(&self.merkle_slab),
                    false,
                ),
            );
            account_metas.push(anchor_lang::solana_program::instruction::AccountMeta::new(
                anchor_lang::Key::key(&self.tree_authority),
                false,
            ));
            account_metas
        }
    }
    #[automatically_derived]
    impl<'info> anchor_lang::ToAccountInfos<'info> for SetTreeDelegate<'info> {
        fn to_account_infos(
            &self,
        ) -> Vec<anchor_lang::solana_program::account_info::AccountInfo<'info>> {
            let mut account_infos = ::alloc::vec::Vec::new();
            account_infos.push(anchor_lang::ToAccountInfo::to_account_info(&self.creator));
            account_infos.push(anchor_lang::ToAccountInfo::to_account_info(
                &self.new_delegate,
            ));
            account_infos.push(anchor_lang::ToAccountInfo::to_account_info(
                &self.merkle_slab,
            ));
            account_infos.push(anchor_lang::ToAccountInfo::to_account_info(
                &self.tree_authority,
            ));
            account_infos
        }
    }
}
pub fn hash_metadata(metadata: &MetadataArgs) -> Result<[u8; 32]> {
    let metadata_args_hash = keccak::hashv(&[metadata.try_to_vec()?.as_slice()]);
    Ok(keccak::hashv(&[
        &metadata_args_hash.to_bytes(),
        &metadata.seller_fee_basis_points.to_le_bytes(),
    ])
    .to_bytes())
}
pub enum InstructionName {
    Unknown,
    MintV1,
    Redeem,
    CancelRedeem,
    Transfer,
    Delegate,
    DecompressV1,
    Compress,
    Burn,
}
pub fn get_instruction_type(full_bytes: &[u8]) -> InstructionName {
    let disc: [u8; 8] = {
        let mut disc = [0; 8];
        disc.copy_from_slice(&full_bytes[..8]);
        disc
    };
    match disc {
        [145, 98, 192, 118, 184, 147, 118, 104] => InstructionName::MintV1,
        [111, 76, 232, 50, 39, 175, 48, 242] => InstructionName::CancelRedeem,
        [184, 12, 86, 149, 70, 196, 97, 225] => InstructionName::Redeem,
        [163, 52, 200, 231, 140, 3, 69, 186] => InstructionName::Transfer,
        [90, 147, 75, 178, 85, 88, 4, 137] => InstructionName::Delegate,
        [54, 85, 76, 70, 228, 250, 164, 81] => InstructionName::DecompressV1,
        [116, 110, 29, 56, 107, 219, 42, 93] => InstructionName::Burn,
        [82, 193, 176, 117, 176, 21, 115, 253] => InstructionName::Compress,
        _ => InstructionName::Unknown,
    }
}
fn assert_enough_mints_to_approve<'info>(
    authority: &Account<'info, TreeConfig>,
    to_approve: u64,
) -> Result<()> {
    if !authority.contains_mint_capacity(to_approve) {
        return Err(BubblegumError::InsufficientMintCapacity.into());
    }
    Ok(())
}
fn process_mint_v1<'info>(
    message: MetadataArgs,
    owner: Pubkey,
    delegate: Pubkey,
    metadata_auth: HashSet<Pubkey>,
    authority_bump: u8,
    authority: &mut Account<'info, TreeConfig>,
    merkle_slab: &AccountInfo<'info>,
    candy_wrapper: &Program<'info, Wrapper>,
    gummyroll_program: &AccountInfo<'info>,
) -> Result<()> {
    assert_metadata_is_mpl_compatible(&message)?;
    let metadata_args_hash = keccak::hashv(&[message.try_to_vec()?.as_slice()]);
    let data_hash = keccak::hashv(&[
        &metadata_args_hash.to_bytes(),
        &message.seller_fee_basis_points.to_le_bytes(),
    ]);
    let creator_data = message
        .creators
        .iter()
        .map(|c| {
            if c.verified && !metadata_auth.contains(&c.address) {
                Err(BubblegumError::CreatorDidNotVerify.into())
            } else {
                Ok([c.address.as_ref(), &[c.verified as u8], &[c.share]].concat())
            }
        })
        .collect::<Result<Vec<_>>>()?;
    let creator_hash = keccak::hashv(
        creator_data
            .iter()
            .map(|c| c.as_slice())
            .collect::<Vec<&[u8]>>()
            .as_ref(),
    );
    let asset_id = get_asset_id(&merkle_slab.key(), authority.num_minted);
    let leaf = LeafSchema::new_v0(
        asset_id,
        owner,
        delegate,
        authority.num_minted,
        data_hash.to_bytes(),
        creator_hash.to_bytes(),
    );
    let new_nft = NewNFTEvent {
        version: Version::V1,
        metadata: message,
        nonce: authority.num_minted,
    };
    {
        anchor_lang::solana_program::log::sol_log_data(&[&anchor_lang::Event::data(&new_nft)]);
    };
    wrap_event(new_nft.try_to_vec()?, &candy_wrapper)?;
    {
        anchor_lang::solana_program::log::sol_log_data(&[&anchor_lang::Event::data(
            &leaf.to_event(),
        )]);
    };
    authority.num_minted = authority.num_minted.saturating_add(1);
    append_leaf(
        &merkle_slab.key(),
        authority_bump,
        &gummyroll_program.to_account_info(),
        &authority.to_account_info(),
        &merkle_slab.to_account_info(),
        &candy_wrapper.to_account_info(),
        leaf.to_node(),
    )
}
fn process_creator_verification<'info>(
    ctx: Context<'_, '_, '_, 'info, CreatorVerification<'info>>,
    root: [u8; 32],
    data_hash: [u8; 32],
    creator_hash: [u8; 32],
    nonce: u64,
    index: u32,
    mut message: MetadataArgs,
    verify: bool,
) -> Result<()> {
    let owner = ctx.accounts.owner.to_account_info();
    let delegate = ctx.accounts.delegate.to_account_info();
    let merkle_slab = ctx.accounts.merkle_slab.to_account_info();
    let creator = ctx.accounts.creator.key();
    if message.creators.is_empty() {
        return Err(BubblegumError::NoCreatorsPresent.into());
    }
    if !message.creators.iter().any(|c| c.address == creator) {
        return Err(BubblegumError::CreatorNotFound.into());
    }
    let provided_creator_data = message
        .creators
        .iter()
        .map(|c| [c.address.as_ref(), &[c.verified as u8], &[c.share]].concat())
        .collect::<Vec<_>>();
    let calculated_creator_hash = keccak::hashv(
        provided_creator_data
            .iter()
            .map(|c| c.as_slice())
            .collect::<Vec<&[u8]>>()
            .as_ref(),
    );
    match (&creator_hash, &calculated_creator_hash.to_bytes()) {
        (left_val, right_val) => {
            if !(*left_val == *right_val) {
                let kind = ::core::panicking::AssertKind::Eq;
                ::core::panicking::assert_failed(
                    kind,
                    &*left_val,
                    &*right_val,
                    ::core::option::Option::None,
                );
            }
        }
    };
    let updated_creator_vec = message
        .creators
        .iter()
        .map(|c| {
            let verified = if c.address == creator.key() {
                verify
            } else {
                c.verified
            };
            Creator {
                address: c.address,
                verified,
                share: c.share,
            }
        })
        .collect::<Vec<Creator>>();
    message.creators = updated_creator_vec;
    let updated_creator_data = message
        .creators
        .iter()
        .map(|c| [c.address.as_ref(), &[c.verified as u8], &[c.share]].concat())
        .collect::<Vec<_>>();
    let updated_creator_hash = keccak::hashv(
        updated_creator_data
            .iter()
            .map(|c| c.as_slice())
            .collect::<Vec<&[u8]>>()
            .as_ref(),
    );
    let metadata_args_hash = keccak::hashv(&[message.try_to_vec()?.as_slice()]);
    let updated_data_hash = keccak::hashv(&[
        &metadata_args_hash.to_bytes(),
        &message.seller_fee_basis_points.to_le_bytes(),
    ]);
    let asset_id = get_asset_id(&merkle_slab.key(), nonce);
    let previous_leaf = LeafSchema::new_v0(
        asset_id,
        owner.key(),
        delegate.key(),
        nonce,
        data_hash,
        creator_hash,
    );
    let new_leaf = LeafSchema::new_v0(
        asset_id,
        owner.key(),
        delegate.key(),
        nonce,
        updated_data_hash.to_bytes(),
        updated_creator_hash.to_bytes(),
    );
    {
        anchor_lang::solana_program::log::sol_log_data(&[&anchor_lang::Event::data(
            &new_leaf.to_event(),
        )]);
    };
    replace_leaf(
        &merkle_slab.key(),
        *ctx.bumps.get("authority").unwrap(),
        &ctx.accounts.gummyroll_program.to_account_info(),
        &ctx.accounts.authority.to_account_info(),
        &ctx.accounts.merkle_slab.to_account_info(),
        &ctx.accounts.candy_wrapper.to_account_info(),
        ctx.remaining_accounts,
        root,
        previous_leaf.to_node(),
        new_leaf.to_node(),
        index,
    )
}
use self::bubblegum::*;
/// # Safety
#[no_mangle]
pub unsafe extern "C" fn entrypoint(input: *mut u8) -> u64 {
    let (program_id, accounts, instruction_data) =
        unsafe { ::solana_program::entrypoint::deserialize(input) };
    match entry(&program_id, &accounts, &instruction_data) {
        Ok(()) => ::solana_program::entrypoint::SUCCESS,
        Err(error) => error.into(),
    }
}
/// The Anchor codegen exposes a programming model where a user defines
/// a set of methods inside of a `#[program]` module in a way similar
/// to writing RPC request handlers. The macro then generates a bunch of
/// code wrapping these user defined methods into something that can be
/// executed on Solana.
///
/// These methods fall into one of three categories, each of which
/// can be considered a different "namespace" of the program.
///
/// 1) Global methods - regular methods inside of the `#[program]`.
/// 2) State methods - associated methods inside a `#[state]` struct.
/// 3) Interface methods - methods inside a strait struct's
///    implementation of an `#[interface]` trait.
///
/// Care must be taken by the codegen to prevent collisions between
/// methods in these different namespaces. For this reason, Anchor uses
/// a variant of sighash to perform method dispatch, rather than
/// something like a simple enum variant discriminator.
///
/// The execution flow of the generated code can be roughly outlined:
///
/// * Start program via the entrypoint.
/// * Strip method identifier off the first 8 bytes of the instruction
///   data and invoke the identified method. The method identifier
///   is a variant of sighash. See docs.rs for `anchor_lang` for details.
/// * If the method identifier is an IDL identifier, execute the IDL
///   instructions, which are a special set of hardcoded instructions
///   baked into every Anchor program. Then exit.
/// * Otherwise, the method identifier is for a user defined
///   instruction, i.e., one of the methods in the user defined
///   `#[program]` module. Perform method dispatch, i.e., execute the
///   big match statement mapping method identifier to method handler
///   wrapper.
/// * Run the method handler wrapper. This wraps the code the user
///   actually wrote, deserializing the accounts, constructing the
///   context, invoking the user's code, and finally running the exit
///   routine, which typically persists account changes.
///
/// The `entry` function here, defines the standard entry to a Solana
/// program, where execution begins.
pub fn entry(
    program_id: &Pubkey,
    accounts: &[AccountInfo],
    data: &[u8],
) -> anchor_lang::solana_program::entrypoint::ProgramResult {
    try_entry(program_id, accounts, data).map_err(|e| {
        e.log();
        e.into()
    })
}
fn try_entry(
    program_id: &Pubkey,
    accounts: &[AccountInfo],
    data: &[u8],
) -> anchor_lang::Result<()> {
    if *program_id != ID {
        return Err(anchor_lang::error::ErrorCode::DeclaredProgramIdMismatch.into());
    }
    if data.len() < 8 {
        return Err(anchor_lang::error::ErrorCode::InstructionMissing.into());
    }
    dispatch(program_id, accounts, data)
}
/// Module representing the program.
pub mod program {
    use super::*;
    /// Type representing the program.
    pub struct Bubblegum;
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::clone::Clone for Bubblegum {
        #[inline]
        fn clone(&self) -> Bubblegum {
            match *self {
                Bubblegum => Bubblegum,
            }
        }
    }
    impl anchor_lang::Id for Bubblegum {
        fn id() -> Pubkey {
            ID
        }
    }
}
/// Performs method dispatch.
///
/// Each method in an anchor program is uniquely defined by a namespace
/// and a rust identifier (i.e., the name given to the method). These
/// two pieces can be combined to creater a method identifier,
/// specifically, Anchor uses
///
/// Sha256("<namespace>:<rust-identifier>")[..8],
///
/// where the namespace can be one of three types. 1) "global" for a
/// regular instruction, 2) "state" for a state struct instruction
/// handler and 3) a trait namespace (used in combination with the
/// `#[interface]` attribute), which is defined by the trait name, e..
/// `MyTrait`.
///
/// With this 8 byte identifier, Anchor performs method dispatch,
/// matching the given 8 byte identifier to the associated method
/// handler, which leads to user defined code being eventually invoked.
fn dispatch(program_id: &Pubkey, accounts: &[AccountInfo], data: &[u8]) -> anchor_lang::Result<()> {
    let mut ix_data: &[u8] = data;
    let sighash: [u8; 8] = {
        let mut sighash: [u8; 8] = [0; 8];
        sighash.copy_from_slice(&ix_data[..8]);
        ix_data = &ix_data[8..];
        sighash
    };
    if true {
        if sighash == anchor_lang::idl::IDL_IX_TAG.to_le_bytes() {
            return __private::__idl::__idl_dispatch(program_id, accounts, &ix_data);
        }
    }
    match sighash {
        [165, 83, 136, 142, 89, 202, 47, 220] => {
            __private::__global::create_tree(program_id, accounts, ix_data)
        }
        [120, 51, 89, 77, 2, 133, 224, 130] => {
            __private::__global::create_default_mint_request(program_id, accounts, ix_data)
        }
        [68, 130, 170, 21, 167, 61, 63, 76] => {
            __private::__global::request_mint_authority(program_id, accounts, ix_data)
        }
        [59, 153, 108, 196, 228, 165, 169, 242] => {
            __private::__global::approve_mint_authority_request(program_id, accounts, ix_data)
        }
        [110, 107, 165, 251, 73, 53, 214, 194] => {
            __private::__global::close_mint_request(program_id, accounts, ix_data)
        }
        [253, 118, 66, 37, 190, 49, 154, 102] => {
            __private::__global::set_tree_delegate(program_id, accounts, ix_data)
        }
        [145, 98, 192, 118, 184, 147, 118, 104] => {
            __private::__global::mint_v1(program_id, accounts, ix_data)
        }
        [52, 17, 96, 132, 71, 4, 85, 194] => {
            __private::__global::verify_creator(program_id, accounts, ix_data)
        }
        [107, 178, 57, 39, 105, 115, 112, 152] => {
            __private::__global::unverify_creator(program_id, accounts, ix_data)
        }
        [163, 52, 200, 231, 140, 3, 69, 186] => {
            __private::__global::transfer(program_id, accounts, ix_data)
        }
        [90, 147, 75, 178, 85, 88, 4, 137] => {
            __private::__global::delegate(program_id, accounts, ix_data)
        }
        [116, 110, 29, 56, 107, 219, 42, 93] => {
            __private::__global::burn(program_id, accounts, ix_data)
        }
        [184, 12, 86, 149, 70, 196, 97, 225] => {
            __private::__global::redeem(program_id, accounts, ix_data)
        }
        [111, 76, 232, 50, 39, 175, 48, 242] => {
            __private::__global::cancel_redeem(program_id, accounts, ix_data)
        }
        [54, 85, 76, 70, 228, 250, 164, 81] => {
            __private::__global::decompress_v1(program_id, accounts, ix_data)
        }
        [82, 193, 176, 117, 176, 21, 115, 253] => {
            __private::__global::compress(program_id, accounts, ix_data)
        }
        _ => Err(anchor_lang::error::ErrorCode::InstructionFallbackNotFound.into()),
    }
}
/// Create a private module to not clutter the program's namespace.
/// Defines an entrypoint for each individual instruction handler
/// wrapper.
mod __private {
    use super::*;
    /// __idl mod defines handlers for injected Anchor IDL instructions.
    pub mod __idl {
        use super::*;
        #[inline(never)]
        #[cfg(not(feature = "no-idl"))]
        pub fn __idl_dispatch(
            program_id: &Pubkey,
            accounts: &[AccountInfo],
            idl_ix_data: &[u8],
        ) -> anchor_lang::Result<()> {
            let mut accounts = accounts;
            let mut data: &[u8] = idl_ix_data;
            let ix = anchor_lang::idl::IdlInstruction::deserialize(&mut data)
                .map_err(|_| anchor_lang::error::ErrorCode::InstructionDidNotDeserialize)?;
            match ix {
                anchor_lang::idl::IdlInstruction::Create { data_len } => {
                    let mut bumps = std::collections::BTreeMap::new();
                    let mut reallocs = std::collections::BTreeSet::new();
                    let mut accounts = anchor_lang::idl::IdlCreateAccounts::try_accounts(
                        program_id,
                        &mut accounts,
                        &[],
                        &mut bumps,
                        &mut reallocs,
                    )?;
                    __idl_create_account(program_id, &mut accounts, data_len)?;
                    accounts.exit(program_id)?;
                }
                anchor_lang::idl::IdlInstruction::CreateBuffer => {
                    let mut bumps = std::collections::BTreeMap::new();
                    let mut reallocs = std::collections::BTreeSet::new();
                    let mut accounts = anchor_lang::idl::IdlCreateBuffer::try_accounts(
                        program_id,
                        &mut accounts,
                        &[],
                        &mut bumps,
                        &mut reallocs,
                    )?;
                    __idl_create_buffer(program_id, &mut accounts)?;
                    accounts.exit(program_id)?;
                }
                anchor_lang::idl::IdlInstruction::Write { data } => {
                    let mut bumps = std::collections::BTreeMap::new();
                    let mut reallocs = std::collections::BTreeSet::new();
                    let mut accounts = anchor_lang::idl::IdlAccounts::try_accounts(
                        program_id,
                        &mut accounts,
                        &[],
                        &mut bumps,
                        &mut reallocs,
                    )?;
                    __idl_write(program_id, &mut accounts, data)?;
                    accounts.exit(program_id)?;
                }
                anchor_lang::idl::IdlInstruction::SetAuthority { new_authority } => {
                    let mut bumps = std::collections::BTreeMap::new();
                    let mut reallocs = std::collections::BTreeSet::new();
                    let mut accounts = anchor_lang::idl::IdlAccounts::try_accounts(
                        program_id,
                        &mut accounts,
                        &[],
                        &mut bumps,
                        &mut reallocs,
                    )?;
                    __idl_set_authority(program_id, &mut accounts, new_authority)?;
                    accounts.exit(program_id)?;
                }
                anchor_lang::idl::IdlInstruction::SetBuffer => {
                    let mut bumps = std::collections::BTreeMap::new();
                    let mut reallocs = std::collections::BTreeSet::new();
                    let mut accounts = anchor_lang::idl::IdlSetBuffer::try_accounts(
                        program_id,
                        &mut accounts,
                        &[],
                        &mut bumps,
                        &mut reallocs,
                    )?;
                    __idl_set_buffer(program_id, &mut accounts)?;
                    accounts.exit(program_id)?;
                }
            }
            Ok(())
        }
        #[inline(never)]
        pub fn __idl_create_account(
            program_id: &Pubkey,
            accounts: &mut anchor_lang::idl::IdlCreateAccounts,
            data_len: u64,
        ) -> anchor_lang::Result<()> {
            ::solana_program::log::sol_log("Instruction: IdlCreateAccount");
            if program_id != accounts.program.key {
                return Err(anchor_lang::error::ErrorCode::IdlInstructionInvalidProgram.into());
            }
            let from = accounts.from.key;
            let (base, nonce) = Pubkey::find_program_address(&[], program_id);
            let seed = anchor_lang::idl::IdlAccount::seed();
            let owner = accounts.program.key;
            let to = Pubkey::create_with_seed(&base, seed, owner).unwrap();
            let space = 8 + 32 + 4 + data_len as usize;
            let rent = Rent::get()?;
            let lamports = rent.minimum_balance(space);
            let seeds = &[&[nonce][..]];
            let ix = anchor_lang::solana_program::system_instruction::create_account_with_seed(
                from,
                &to,
                &base,
                seed,
                lamports,
                space as u64,
                owner,
            );
            anchor_lang::solana_program::program::invoke_signed(
                &ix,
                &[
                    accounts.from.clone(),
                    accounts.to.clone(),
                    accounts.base.clone(),
                    accounts.system_program.clone(),
                ],
                &[seeds],
            )?;
            let mut idl_account = {
                let mut account_data = accounts.to.try_borrow_data()?;
                let mut account_data_slice: &[u8] = &account_data;
                anchor_lang::idl::IdlAccount::try_deserialize_unchecked(&mut account_data_slice)?
            };
            idl_account.authority = *accounts.from.key;
            let mut data = accounts.to.try_borrow_mut_data()?;
            let dst: &mut [u8] = &mut data;
            let mut cursor = std::io::Cursor::new(dst);
            idl_account.try_serialize(&mut cursor)?;
            Ok(())
        }
        #[inline(never)]
        pub fn __idl_create_buffer(
            program_id: &Pubkey,
            accounts: &mut anchor_lang::idl::IdlCreateBuffer,
        ) -> anchor_lang::Result<()> {
            ::solana_program::log::sol_log("Instruction: IdlCreateBuffer");
            let mut buffer = &mut accounts.buffer;
            buffer.authority = *accounts.authority.key;
            Ok(())
        }
        #[inline(never)]
        pub fn __idl_write(
            program_id: &Pubkey,
            accounts: &mut anchor_lang::idl::IdlAccounts,
            idl_data: Vec<u8>,
        ) -> anchor_lang::Result<()> {
            ::solana_program::log::sol_log("Instruction: IdlWrite");
            let mut idl = &mut accounts.idl;
            idl.data.extend(idl_data);
            Ok(())
        }
        #[inline(never)]
        pub fn __idl_set_authority(
            program_id: &Pubkey,
            accounts: &mut anchor_lang::idl::IdlAccounts,
            new_authority: Pubkey,
        ) -> anchor_lang::Result<()> {
            ::solana_program::log::sol_log("Instruction: IdlSetAuthority");
            accounts.idl.authority = new_authority;
            Ok(())
        }
        #[inline(never)]
        pub fn __idl_set_buffer(
            program_id: &Pubkey,
            accounts: &mut anchor_lang::idl::IdlSetBuffer,
        ) -> anchor_lang::Result<()> {
            ::solana_program::log::sol_log("Instruction: IdlSetBuffer");
            accounts.idl.data = accounts.buffer.data.clone();
            Ok(())
        }
    }
    /// __state mod defines wrapped handlers for state instructions.
    pub mod __state {
        use super::*;
    }
    /// __interface mod defines wrapped handlers for `#[interface]` trait
    /// implementations.
    pub mod __interface {
        use super::*;
    }
    /// __global mod defines wrapped handlers for global instructions.
    pub mod __global {
        use super::*;
        #[inline(never)]
        pub fn create_tree(
            program_id: &Pubkey,
            accounts: &[AccountInfo],
            ix_data: &[u8],
        ) -> anchor_lang::Result<()> {
            ::solana_program::log::sol_log("Instruction: CreateTree");
            let ix = instruction::CreateTree::deserialize(&mut &ix_data[..])
                .map_err(|_| anchor_lang::error::ErrorCode::InstructionDidNotDeserialize)?;
            let instruction::CreateTree {
                max_depth,
                max_buffer_size,
            } = ix;
            let mut __bumps = std::collections::BTreeMap::new();
            let mut __reallocs = std::collections::BTreeSet::new();
            let mut remaining_accounts: &[AccountInfo] = accounts;
            let mut accounts = CreateTree::try_accounts(
                program_id,
                &mut remaining_accounts,
                ix_data,
                &mut __bumps,
                &mut __reallocs,
            )?;
            let result = bubblegum::create_tree(
                anchor_lang::context::Context::new(
                    program_id,
                    &mut accounts,
                    remaining_accounts,
                    __bumps,
                ),
                max_depth,
                max_buffer_size,
            )?;
            accounts.exit(program_id)
        }
        #[inline(never)]
        pub fn create_default_mint_request(
            program_id: &Pubkey,
            accounts: &[AccountInfo],
            ix_data: &[u8],
        ) -> anchor_lang::Result<()> {
            ::solana_program::log::sol_log("Instruction: CreateDefaultMintRequest");
            let ix = instruction::CreateDefaultMintRequest::deserialize(&mut &ix_data[..])
                .map_err(|_| anchor_lang::error::ErrorCode::InstructionDidNotDeserialize)?;
            let instruction::CreateDefaultMintRequest { mint_capacity } = ix;
            let mut __bumps = std::collections::BTreeMap::new();
            let mut __reallocs = std::collections::BTreeSet::new();
            let mut remaining_accounts: &[AccountInfo] = accounts;
            let mut accounts = SetDefaultMintRequest::try_accounts(
                program_id,
                &mut remaining_accounts,
                ix_data,
                &mut __bumps,
                &mut __reallocs,
            )?;
            let result = bubblegum::create_default_mint_request(
                anchor_lang::context::Context::new(
                    program_id,
                    &mut accounts,
                    remaining_accounts,
                    __bumps,
                ),
                mint_capacity,
            )?;
            accounts.exit(program_id)
        }
        #[inline(never)]
        pub fn request_mint_authority(
            program_id: &Pubkey,
            accounts: &[AccountInfo],
            ix_data: &[u8],
        ) -> anchor_lang::Result<()> {
            ::solana_program::log::sol_log("Instruction: RequestMintAuthority");
            let ix = instruction::RequestMintAuthority::deserialize(&mut &ix_data[..])
                .map_err(|_| anchor_lang::error::ErrorCode::InstructionDidNotDeserialize)?;
            let instruction::RequestMintAuthority { mint_capacity } = ix;
            let mut __bumps = std::collections::BTreeMap::new();
            let mut __reallocs = std::collections::BTreeSet::new();
            let mut remaining_accounts: &[AccountInfo] = accounts;
            let mut accounts = SetMintRequest::try_accounts(
                program_id,
                &mut remaining_accounts,
                ix_data,
                &mut __bumps,
                &mut __reallocs,
            )?;
            let result = bubblegum::request_mint_authority(
                anchor_lang::context::Context::new(
                    program_id,
                    &mut accounts,
                    remaining_accounts,
                    __bumps,
                ),
                mint_capacity,
            )?;
            accounts.exit(program_id)
        }
        #[inline(never)]
        pub fn approve_mint_authority_request(
            program_id: &Pubkey,
            accounts: &[AccountInfo],
            ix_data: &[u8],
        ) -> anchor_lang::Result<()> {
            ::solana_program::log::sol_log("Instruction: ApproveMintAuthorityRequest");
            let ix = instruction::ApproveMintAuthorityRequest::deserialize(&mut &ix_data[..])
                .map_err(|_| anchor_lang::error::ErrorCode::InstructionDidNotDeserialize)?;
            let instruction::ApproveMintAuthorityRequest {
                num_mints_to_approve,
            } = ix;
            let mut __bumps = std::collections::BTreeMap::new();
            let mut __reallocs = std::collections::BTreeSet::new();
            let mut remaining_accounts: &[AccountInfo] = accounts;
            let mut accounts = ApproveMintRequest::try_accounts(
                program_id,
                &mut remaining_accounts,
                ix_data,
                &mut __bumps,
                &mut __reallocs,
            )?;
            let result = bubblegum::approve_mint_authority_request(
                anchor_lang::context::Context::new(
                    program_id,
                    &mut accounts,
                    remaining_accounts,
                    __bumps,
                ),
                num_mints_to_approve,
            )?;
            accounts.exit(program_id)
        }
        #[inline(never)]
        pub fn close_mint_request(
            program_id: &Pubkey,
            accounts: &[AccountInfo],
            ix_data: &[u8],
        ) -> anchor_lang::Result<()> {
            ::solana_program::log::sol_log("Instruction: CloseMintRequest");
            let ix = instruction::CloseMintRequest::deserialize(&mut &ix_data[..])
                .map_err(|_| anchor_lang::error::ErrorCode::InstructionDidNotDeserialize)?;
            let instruction::CloseMintRequest = ix;
            let mut __bumps = std::collections::BTreeMap::new();
            let mut __reallocs = std::collections::BTreeSet::new();
            let mut remaining_accounts: &[AccountInfo] = accounts;
            let mut accounts = CloseMintRequest::try_accounts(
                program_id,
                &mut remaining_accounts,
                ix_data,
                &mut __bumps,
                &mut __reallocs,
            )?;
            let result = bubblegum::close_mint_request(anchor_lang::context::Context::new(
                program_id,
                &mut accounts,
                remaining_accounts,
                __bumps,
            ))?;
            accounts.exit(program_id)
        }
        #[inline(never)]
        pub fn set_tree_delegate(
            program_id: &Pubkey,
            accounts: &[AccountInfo],
            ix_data: &[u8],
        ) -> anchor_lang::Result<()> {
            ::solana_program::log::sol_log("Instruction: SetTreeDelegate");
            let ix = instruction::SetTreeDelegate::deserialize(&mut &ix_data[..])
                .map_err(|_| anchor_lang::error::ErrorCode::InstructionDidNotDeserialize)?;
            let instruction::SetTreeDelegate = ix;
            let mut __bumps = std::collections::BTreeMap::new();
            let mut __reallocs = std::collections::BTreeSet::new();
            let mut remaining_accounts: &[AccountInfo] = accounts;
            let mut accounts = SetTreeDelegate::try_accounts(
                program_id,
                &mut remaining_accounts,
                ix_data,
                &mut __bumps,
                &mut __reallocs,
            )?;
            let result = bubblegum::set_tree_delegate(anchor_lang::context::Context::new(
                program_id,
                &mut accounts,
                remaining_accounts,
                __bumps,
            ))?;
            accounts.exit(program_id)
        }
        #[inline(never)]
        pub fn mint_v1(
            program_id: &Pubkey,
            accounts: &[AccountInfo],
            ix_data: &[u8],
        ) -> anchor_lang::Result<()> {
            ::solana_program::log::sol_log("Instruction: MintV1");
            let ix = instruction::MintV1::deserialize(&mut &ix_data[..])
                .map_err(|_| anchor_lang::error::ErrorCode::InstructionDidNotDeserialize)?;
            let instruction::MintV1 { message } = ix;
            let mut __bumps = std::collections::BTreeMap::new();
            let mut __reallocs = std::collections::BTreeSet::new();
            let mut remaining_accounts: &[AccountInfo] = accounts;
            let mut accounts = MintV1::try_accounts(
                program_id,
                &mut remaining_accounts,
                ix_data,
                &mut __bumps,
                &mut __reallocs,
            )?;
            let result = bubblegum::mint_v1(
                anchor_lang::context::Context::new(
                    program_id,
                    &mut accounts,
                    remaining_accounts,
                    __bumps,
                ),
                message,
            )?;
            accounts.exit(program_id)
        }
        #[inline(never)]
        pub fn verify_creator(
            program_id: &Pubkey,
            accounts: &[AccountInfo],
            ix_data: &[u8],
        ) -> anchor_lang::Result<()> {
            ::solana_program::log::sol_log("Instruction: VerifyCreator");
            let ix = instruction::VerifyCreator::deserialize(&mut &ix_data[..])
                .map_err(|_| anchor_lang::error::ErrorCode::InstructionDidNotDeserialize)?;
            let instruction::VerifyCreator {
                root,
                data_hash,
                creator_hash,
                nonce,
                index,
                message,
            } = ix;
            let mut __bumps = std::collections::BTreeMap::new();
            let mut __reallocs = std::collections::BTreeSet::new();
            let mut remaining_accounts: &[AccountInfo] = accounts;
            let mut accounts = CreatorVerification::try_accounts(
                program_id,
                &mut remaining_accounts,
                ix_data,
                &mut __bumps,
                &mut __reallocs,
            )?;
            let result = bubblegum::verify_creator(
                anchor_lang::context::Context::new(
                    program_id,
                    &mut accounts,
                    remaining_accounts,
                    __bumps,
                ),
                root,
                data_hash,
                creator_hash,
                nonce,
                index,
                message,
            )?;
            accounts.exit(program_id)
        }
        #[inline(never)]
        pub fn unverify_creator(
            program_id: &Pubkey,
            accounts: &[AccountInfo],
            ix_data: &[u8],
        ) -> anchor_lang::Result<()> {
            ::solana_program::log::sol_log("Instruction: UnverifyCreator");
            let ix = instruction::UnverifyCreator::deserialize(&mut &ix_data[..])
                .map_err(|_| anchor_lang::error::ErrorCode::InstructionDidNotDeserialize)?;
            let instruction::UnverifyCreator {
                root,
                data_hash,
                creator_hash,
                nonce,
                index,
                message,
            } = ix;
            let mut __bumps = std::collections::BTreeMap::new();
            let mut __reallocs = std::collections::BTreeSet::new();
            let mut remaining_accounts: &[AccountInfo] = accounts;
            let mut accounts = CreatorVerification::try_accounts(
                program_id,
                &mut remaining_accounts,
                ix_data,
                &mut __bumps,
                &mut __reallocs,
            )?;
            let result = bubblegum::unverify_creator(
                anchor_lang::context::Context::new(
                    program_id,
                    &mut accounts,
                    remaining_accounts,
                    __bumps,
                ),
                root,
                data_hash,
                creator_hash,
                nonce,
                index,
                message,
            )?;
            accounts.exit(program_id)
        }
        #[inline(never)]
        pub fn transfer(
            program_id: &Pubkey,
            accounts: &[AccountInfo],
            ix_data: &[u8],
        ) -> anchor_lang::Result<()> {
            ::solana_program::log::sol_log("Instruction: Transfer");
            let ix = instruction::Transfer::deserialize(&mut &ix_data[..])
                .map_err(|_| anchor_lang::error::ErrorCode::InstructionDidNotDeserialize)?;
            let instruction::Transfer {
                root,
                data_hash,
                creator_hash,
                nonce,
                index,
            } = ix;
            let mut __bumps = std::collections::BTreeMap::new();
            let mut __reallocs = std::collections::BTreeSet::new();
            let mut remaining_accounts: &[AccountInfo] = accounts;
            let mut accounts = Transfer::try_accounts(
                program_id,
                &mut remaining_accounts,
                ix_data,
                &mut __bumps,
                &mut __reallocs,
            )?;
            let result = bubblegum::transfer(
                anchor_lang::context::Context::new(
                    program_id,
                    &mut accounts,
                    remaining_accounts,
                    __bumps,
                ),
                root,
                data_hash,
                creator_hash,
                nonce,
                index,
            )?;
            accounts.exit(program_id)
        }
        #[inline(never)]
        pub fn delegate(
            program_id: &Pubkey,
            accounts: &[AccountInfo],
            ix_data: &[u8],
        ) -> anchor_lang::Result<()> {
            ::solana_program::log::sol_log("Instruction: Delegate");
            let ix = instruction::Delegate::deserialize(&mut &ix_data[..])
                .map_err(|_| anchor_lang::error::ErrorCode::InstructionDidNotDeserialize)?;
            let instruction::Delegate {
                root,
                data_hash,
                creator_hash,
                nonce,
                index,
            } = ix;
            let mut __bumps = std::collections::BTreeMap::new();
            let mut __reallocs = std::collections::BTreeSet::new();
            let mut remaining_accounts: &[AccountInfo] = accounts;
            let mut accounts = Delegate::try_accounts(
                program_id,
                &mut remaining_accounts,
                ix_data,
                &mut __bumps,
                &mut __reallocs,
            )?;
            let result = bubblegum::delegate(
                anchor_lang::context::Context::new(
                    program_id,
                    &mut accounts,
                    remaining_accounts,
                    __bumps,
                ),
                root,
                data_hash,
                creator_hash,
                nonce,
                index,
            )?;
            accounts.exit(program_id)
        }
        #[inline(never)]
        pub fn burn(
            program_id: &Pubkey,
            accounts: &[AccountInfo],
            ix_data: &[u8],
        ) -> anchor_lang::Result<()> {
            ::solana_program::log::sol_log("Instruction: Burn");
            let ix = instruction::Burn::deserialize(&mut &ix_data[..])
                .map_err(|_| anchor_lang::error::ErrorCode::InstructionDidNotDeserialize)?;
            let instruction::Burn {
                root,
                data_hash,
                creator_hash,
                nonce,
                index,
            } = ix;
            let mut __bumps = std::collections::BTreeMap::new();
            let mut __reallocs = std::collections::BTreeSet::new();
            let mut remaining_accounts: &[AccountInfo] = accounts;
            let mut accounts = Burn::try_accounts(
                program_id,
                &mut remaining_accounts,
                ix_data,
                &mut __bumps,
                &mut __reallocs,
            )?;
            let result = bubblegum::burn(
                anchor_lang::context::Context::new(
                    program_id,
                    &mut accounts,
                    remaining_accounts,
                    __bumps,
                ),
                root,
                data_hash,
                creator_hash,
                nonce,
                index,
            )?;
            accounts.exit(program_id)
        }
        #[inline(never)]
        pub fn redeem(
            program_id: &Pubkey,
            accounts: &[AccountInfo],
            ix_data: &[u8],
        ) -> anchor_lang::Result<()> {
            ::solana_program::log::sol_log("Instruction: Redeem");
            let ix = instruction::Redeem::deserialize(&mut &ix_data[..])
                .map_err(|_| anchor_lang::error::ErrorCode::InstructionDidNotDeserialize)?;
            let instruction::Redeem {
                root,
                data_hash,
                creator_hash,
                nonce,
                index,
            } = ix;
            let mut __bumps = std::collections::BTreeMap::new();
            let mut __reallocs = std::collections::BTreeSet::new();
            let mut remaining_accounts: &[AccountInfo] = accounts;
            let mut accounts = Redeem::try_accounts(
                program_id,
                &mut remaining_accounts,
                ix_data,
                &mut __bumps,
                &mut __reallocs,
            )?;
            let result = bubblegum::redeem(
                anchor_lang::context::Context::new(
                    program_id,
                    &mut accounts,
                    remaining_accounts,
                    __bumps,
                ),
                root,
                data_hash,
                creator_hash,
                nonce,
                index,
            )?;
            accounts.exit(program_id)
        }
        #[inline(never)]
        pub fn cancel_redeem(
            program_id: &Pubkey,
            accounts: &[AccountInfo],
            ix_data: &[u8],
        ) -> anchor_lang::Result<()> {
            ::solana_program::log::sol_log("Instruction: CancelRedeem");
            let ix = instruction::CancelRedeem::deserialize(&mut &ix_data[..])
                .map_err(|_| anchor_lang::error::ErrorCode::InstructionDidNotDeserialize)?;
            let instruction::CancelRedeem { root } = ix;
            let mut __bumps = std::collections::BTreeMap::new();
            let mut __reallocs = std::collections::BTreeSet::new();
            let mut remaining_accounts: &[AccountInfo] = accounts;
            let mut accounts = CancelRedeem::try_accounts(
                program_id,
                &mut remaining_accounts,
                ix_data,
                &mut __bumps,
                &mut __reallocs,
            )?;
            let result = bubblegum::cancel_redeem(
                anchor_lang::context::Context::new(
                    program_id,
                    &mut accounts,
                    remaining_accounts,
                    __bumps,
                ),
                root,
            )?;
            accounts.exit(program_id)
        }
        #[inline(never)]
        pub fn decompress_v1(
            program_id: &Pubkey,
            accounts: &[AccountInfo],
            ix_data: &[u8],
        ) -> anchor_lang::Result<()> {
            ::solana_program::log::sol_log("Instruction: DecompressV1");
            let ix = instruction::DecompressV1::deserialize(&mut &ix_data[..])
                .map_err(|_| anchor_lang::error::ErrorCode::InstructionDidNotDeserialize)?;
            let instruction::DecompressV1 { metadata } = ix;
            let mut __bumps = std::collections::BTreeMap::new();
            let mut __reallocs = std::collections::BTreeSet::new();
            let mut remaining_accounts: &[AccountInfo] = accounts;
            let mut accounts = DecompressV1::try_accounts(
                program_id,
                &mut remaining_accounts,
                ix_data,
                &mut __bumps,
                &mut __reallocs,
            )?;
            let result = bubblegum::decompress_v1(
                anchor_lang::context::Context::new(
                    program_id,
                    &mut accounts,
                    remaining_accounts,
                    __bumps,
                ),
                metadata,
            )?;
            accounts.exit(program_id)
        }
        #[inline(never)]
        pub fn compress(
            program_id: &Pubkey,
            accounts: &[AccountInfo],
            ix_data: &[u8],
        ) -> anchor_lang::Result<()> {
            ::solana_program::log::sol_log("Instruction: Compress");
            let ix = instruction::Compress::deserialize(&mut &ix_data[..])
                .map_err(|_| anchor_lang::error::ErrorCode::InstructionDidNotDeserialize)?;
            let instruction::Compress = ix;
            let mut __bumps = std::collections::BTreeMap::new();
            let mut __reallocs = std::collections::BTreeSet::new();
            let mut remaining_accounts: &[AccountInfo] = accounts;
            let mut accounts = Compress::try_accounts(
                program_id,
                &mut remaining_accounts,
                ix_data,
                &mut __bumps,
                &mut __reallocs,
            )?;
            let result = bubblegum::compress(anchor_lang::context::Context::new(
                program_id,
                &mut accounts,
                remaining_accounts,
                __bumps,
            ))?;
            accounts.exit(program_id)
        }
    }
}
pub mod bubblegum {
    use super::*;
    pub fn create_tree(
        ctx: Context<CreateTree>,
        max_depth: u32,
        max_buffer_size: u32,
    ) -> Result<()> {
        let merkle_slab = ctx.accounts.merkle_slab.to_account_info();
        let seed = merkle_slab.key();
        let seeds = &[seed.as_ref(), &[*ctx.bumps.get("authority").unwrap()]];
        let authority = &mut ctx.accounts.authority;
        authority.set_inner(TreeConfig {
            creator: ctx.accounts.tree_creator.key(),
            delegate: ctx.accounts.tree_creator.key(),
            total_mint_capacity: 1 << max_depth,
            num_mints_approved: 0,
            num_minted: 0,
        });
        let authority_pda_signer = &[&seeds[..]];
        let cpi_ctx = CpiContext::new_with_signer(
            ctx.accounts.gummyroll_program.to_account_info(),
            spl_compression::cpi::accounts::Initialize {
                authority: ctx.accounts.authority.to_account_info(),
                merkle_tree: merkle_slab,
                log_wrapper: ctx.accounts.candy_wrapper.to_account_info(),
            },
            authority_pda_signer,
        );
        spl_compression::cpi::init_empty_merkle_tree(cpi_ctx, max_depth, max_buffer_size)
    }
    /// Creates a special mint request the tree_authority PDA. This allows permissionless minting without
    /// requiring a higher level CPI
    pub fn create_default_mint_request(
        ctx: Context<SetDefaultMintRequest>,
        mint_capacity: u64,
    ) -> Result<()> {
        let request = &mut ctx.accounts.mint_authority_request;
        assert_enough_mints_to_approve(&ctx.accounts.tree_authority, mint_capacity)?;
        request.init_or_set(ctx.accounts.tree_authority.key(), mint_capacity);
        Ok(())
    }
    pub fn request_mint_authority(ctx: Context<SetMintRequest>, mint_capacity: u64) -> Result<()> {
        let request = &mut ctx.accounts.mint_authority_request;
        assert_enough_mints_to_approve(&ctx.accounts.tree_authority, mint_capacity)?;
        request.init_or_set(ctx.accounts.mint_authority.key(), mint_capacity);
        Ok(())
    }
    pub fn approve_mint_authority_request(
        ctx: Context<ApproveMintRequest>,
        num_mints_to_approve: u64,
    ) -> Result<()> {
        let authority = &mut ctx.accounts.tree_authority;
        let request = &mut ctx.accounts.mint_authority_request;
        assert_enough_mints_to_approve(&authority, num_mints_to_approve)?;
        authority.approve_mint_capacity(num_mints_to_approve);
        request.approve(num_mints_to_approve)?;
        Ok(())
    }
    pub fn close_mint_request(ctx: Context<CloseMintRequest>) -> Result<()> {
        let authority = &mut ctx.accounts.tree_authority;
        let request = &ctx.accounts.mint_authority_request;
        authority.restore_mint_capacity(request.num_mints_approved);
        Ok(())
    }
    pub fn set_tree_delegate(ctx: Context<SetTreeDelegate>) -> Result<()> {
        ctx.accounts.tree_authority.delegate = ctx.accounts.new_delegate.key();
        Ok(())
    }
    pub fn mint_v1(ctx: Context<MintV1>, message: MetadataArgs) -> Result<()> {
        let owner = ctx.accounts.owner.key();
        let delegate = ctx.accounts.delegate.key();
        let mint_authority = &mut ctx.accounts.mint_authority;
        let merkle_slab = &ctx.accounts.merkle_slab;
        let mut metadata_auth = HashSet::<Pubkey>::new();
        if mint_authority.key() != ctx.accounts.authority.key() {
            if !mint_authority.is_signer {
                ::core::panicking::panic("assertion failed: mint_authority.is_signer")
            };
            metadata_auth.insert(mint_authority.key());
        }
        metadata_auth.extend(
            ctx.remaining_accounts
                .iter()
                .filter(|a| a.is_signer)
                .map(|a| a.key()),
        );
        let authority = &mut ctx.accounts.authority;
        let request = &mut ctx.accounts.mint_authority_request;
        request.decrement_approvals()?;
        process_mint_v1(
            message,
            owner,
            delegate,
            metadata_auth,
            *ctx.bumps.get("authority").unwrap(),
            authority,
            merkle_slab,
            &ctx.accounts.candy_wrapper,
            &ctx.accounts.gummyroll_program,
        )?;
        if request.num_mints_approved == 0 && request.num_mints_requested == 0 {
            let request_info = request.to_account_info();
            **mint_authority.lamports.borrow_mut() = mint_authority
                .lamports()
                .checked_add(request_info.lamports())
                .ok_or(BubblegumError::CloseMintRequestError)?;
            **request_info.lamports.borrow_mut() = 0;
        }
        Ok(())
    }
    pub fn verify_creator<'info>(
        ctx: Context<'_, '_, '_, 'info, CreatorVerification<'info>>,
        root: [u8; 32],
        data_hash: [u8; 32],
        creator_hash: [u8; 32],
        nonce: u64,
        index: u32,
        message: MetadataArgs,
    ) -> Result<()> {
        process_creator_verification(
            ctx,
            root,
            data_hash,
            creator_hash,
            nonce,
            index,
            message,
            true,
        )
    }
    pub fn unverify_creator<'info>(
        ctx: Context<'_, '_, '_, 'info, CreatorVerification<'info>>,
        root: [u8; 32],
        data_hash: [u8; 32],
        creator_hash: [u8; 32],
        nonce: u64,
        index: u32,
        message: MetadataArgs,
    ) -> Result<()> {
        process_creator_verification(
            ctx,
            root,
            data_hash,
            creator_hash,
            nonce,
            index,
            message,
            false,
        )
    }
    pub fn transfer<'info>(
        ctx: Context<'_, '_, '_, 'info, Transfer<'info>>,
        root: [u8; 32],
        data_hash: [u8; 32],
        creator_hash: [u8; 32],
        nonce: u64,
        index: u32,
    ) -> Result<()> {
        let merkle_slab = ctx.accounts.merkle_slab.to_account_info();
        let owner = ctx.accounts.owner.to_account_info();
        let delegate = ctx.accounts.delegate.to_account_info();
        if !(owner.is_signer || delegate.is_signer) {
            ::core::panicking::panic("assertion failed: owner.is_signer || delegate.is_signer")
        };
        let new_owner = ctx.accounts.new_owner.key();
        let asset_id = get_asset_id(&merkle_slab.key(), nonce);
        let previous_leaf = LeafSchema::new_v0(
            asset_id,
            owner.key(),
            delegate.key(),
            nonce,
            data_hash,
            creator_hash,
        );
        let new_leaf = LeafSchema::new_v0(
            asset_id,
            new_owner,
            new_owner,
            nonce,
            data_hash,
            creator_hash,
        );
        {
            anchor_lang::solana_program::log::sol_log_data(&[&anchor_lang::Event::data(
                &new_leaf.to_event(),
            )]);
        };
        replace_leaf(
            &merkle_slab.key(),
            *ctx.bumps.get("authority").unwrap(),
            &ctx.accounts.gummyroll_program.to_account_info(),
            &ctx.accounts.authority.to_account_info(),
            &ctx.accounts.merkle_slab.to_account_info(),
            &ctx.accounts.candy_wrapper.to_account_info(),
            ctx.remaining_accounts,
            root,
            previous_leaf.to_node(),
            new_leaf.to_node(),
            index,
        )
    }
    pub fn delegate<'info>(
        ctx: Context<'_, '_, '_, 'info, Delegate<'info>>,
        root: [u8; 32],
        data_hash: [u8; 32],
        creator_hash: [u8; 32],
        nonce: u64,
        index: u32,
    ) -> Result<()> {
        let merkle_slab = ctx.accounts.merkle_slab.to_account_info();
        let owner = ctx.accounts.owner.key();
        let previous_delegate = ctx.accounts.previous_delegate.key();
        let new_delegate = ctx.accounts.new_delegate.key();
        let asset_id = get_asset_id(&merkle_slab.key(), nonce);
        let previous_leaf = LeafSchema::new_v0(
            asset_id,
            owner,
            previous_delegate,
            nonce,
            data_hash,
            creator_hash,
        );
        let new_leaf = LeafSchema::new_v0(
            asset_id,
            owner,
            new_delegate,
            nonce,
            data_hash,
            creator_hash,
        );
        wrap_event(new_leaf.try_to_vec()?, &ctx.accounts.candy_wrapper)?;
        {
            anchor_lang::solana_program::log::sol_log_data(&[&anchor_lang::Event::data(
                &new_leaf.to_event(),
            )]);
        };
        replace_leaf(
            &merkle_slab.key(),
            *ctx.bumps.get("authority").unwrap(),
            &ctx.accounts.gummyroll_program.to_account_info(),
            &ctx.accounts.authority.to_account_info(),
            &ctx.accounts.merkle_slab.to_account_info(),
            &ctx.accounts.candy_wrapper.to_account_info(),
            ctx.remaining_accounts,
            root,
            previous_leaf.to_node(),
            new_leaf.to_node(),
            index,
        )
    }
    pub fn burn<'info>(
        ctx: Context<'_, '_, '_, 'info, Burn<'info>>,
        root: [u8; 32],
        data_hash: [u8; 32],
        creator_hash: [u8; 32],
        nonce: u64,
        index: u32,
    ) -> Result<()> {
        let owner = ctx.accounts.owner.to_account_info();
        let delegate = ctx.accounts.delegate.to_account_info();
        if !(owner.is_signer || delegate.is_signer) {
            ::core::panicking::panic("assertion failed: owner.is_signer || delegate.is_signer")
        };
        let merkle_slab = ctx.accounts.merkle_slab.to_account_info();
        let asset_id = get_asset_id(&merkle_slab.key(), nonce);
        let previous_leaf = LeafSchema::new_v0(
            asset_id,
            owner.key(),
            delegate.key(),
            nonce,
            data_hash,
            creator_hash,
        );
        {
            anchor_lang::solana_program::log::sol_log_data(&[&anchor_lang::Event::data(
                &previous_leaf.to_event(),
            )]);
        };
        let new_leaf = Node::default();
        wrap_event(new_leaf.try_to_vec()?, &ctx.accounts.candy_wrapper)?;
        replace_leaf(
            &merkle_slab.key(),
            *ctx.bumps.get("authority").unwrap(),
            &ctx.accounts.gummyroll_program.to_account_info(),
            &ctx.accounts.authority.to_account_info(),
            &ctx.accounts.merkle_slab.to_account_info(),
            &ctx.accounts.candy_wrapper.to_account_info(),
            ctx.remaining_accounts,
            root,
            previous_leaf.to_node(),
            new_leaf,
            index,
        )
    }
    pub fn redeem<'info>(
        ctx: Context<'_, '_, '_, 'info, Redeem<'info>>,
        root: [u8; 32],
        data_hash: [u8; 32],
        creator_hash: [u8; 32],
        nonce: u64,
        index: u32,
    ) -> Result<()> {
        let owner = ctx.accounts.owner.key();
        let delegate = ctx.accounts.delegate.key();
        let merkle_slab = ctx.accounts.merkle_slab.to_account_info();
        let asset_id = get_asset_id(&merkle_slab.key(), nonce);
        let previous_leaf =
            LeafSchema::new_v0(asset_id, owner, delegate, nonce, data_hash, creator_hash);
        {
            anchor_lang::solana_program::log::sol_log_data(&[&anchor_lang::Event::data(
                &previous_leaf.to_event(),
            )]);
        };
        let new_leaf = Node::default();
        wrap_event(new_leaf.try_to_vec()?, &ctx.accounts.candy_wrapper)?;
        replace_leaf(
            &merkle_slab.key(),
            *ctx.bumps.get("authority").unwrap(),
            &ctx.accounts.gummyroll_program.to_account_info(),
            &ctx.accounts.authority.to_account_info(),
            &ctx.accounts.merkle_slab.to_account_info(),
            &ctx.accounts.candy_wrapper.to_account_info(),
            ctx.remaining_accounts,
            root,
            previous_leaf.to_node(),
            new_leaf,
            index,
        )?;
        ctx.accounts
            .voucher
            .set_inner(Voucher::new(previous_leaf, index, merkle_slab.key()));
        Ok(())
    }
    pub fn cancel_redeem<'info>(
        ctx: Context<'_, '_, '_, 'info, CancelRedeem<'info>>,
        root: [u8; 32],
    ) -> Result<()> {
        let voucher = &ctx.accounts.voucher;
        match ctx.accounts.voucher.leaf_schema {
            LeafSchema::V1 { owner, .. } => assert_pubkey_equal(
                &ctx.accounts.owner.key(),
                &owner,
                Some(BubblegumError::AssetOwnerMismatch.into()),
            ),
        }?;
        let merkle_slab = ctx.accounts.merkle_slab.to_account_info();
        {
            anchor_lang::solana_program::log::sol_log_data(&[&anchor_lang::Event::data(
                &voucher.leaf_schema.to_event(),
            )]);
        };
        wrap_event(
            voucher.leaf_schema.try_to_vec()?,
            &ctx.accounts.candy_wrapper,
        )?;
        replace_leaf(
            &merkle_slab.key(),
            *ctx.bumps.get("authority").unwrap(),
            &ctx.accounts.gummyroll_program.to_account_info(),
            &ctx.accounts.authority.to_account_info(),
            &ctx.accounts.merkle_slab.to_account_info(),
            &ctx.accounts.candy_wrapper.to_account_info(),
            ctx.remaining_accounts,
            root,
            [0; 32],
            voucher.leaf_schema.to_node(),
            voucher.index,
        )
    }
    pub fn decompress_v1(ctx: Context<DecompressV1>, metadata: MetadataArgs) -> Result<()> {
        let incoming_data_hash = hash_metadata(&metadata)?;
        let event = match ctx.accounts.voucher.leaf_schema {
            LeafSchema::V1 {
                owner,
                data_hash,
                nonce,
                ..
            } => {
                if !cmp_bytes(&data_hash, &incoming_data_hash, 32) {
                    return Err(BubblegumError::HashingMismatch.into());
                }
                if !cmp_pubkeys(&owner, ctx.accounts.owner.key) {
                    return Err(BubblegumError::AssetOwnerMismatch.into());
                }
                Ok(NFTDecompressionEvent {
                    version: Version::V1,
                    tree_id: ctx.accounts.voucher.merkle_slab.key(),
                    id: get_asset_id(&ctx.accounts.voucher.merkle_slab.key(), nonce),
                    nonce: nonce,
                })
            }
            _ => Err(BubblegumError::UnsupportedSchemaVersion),
        }?;
        let voucher = &ctx.accounts.voucher;
        match metadata.token_program_version {
            TokenProgramVersion::Original => {
                if ctx.accounts.mint.data_is_empty() {
                    invoke_signed(
                        &system_instruction::create_account(
                            &ctx.accounts.owner.key(),
                            &ctx.accounts.mint.key(),
                            Rent::get()?.minimum_balance(SplMint::LEN),
                            SplMint::LEN as u64,
                            &spl_token::id(),
                        ),
                        &[
                            ctx.accounts.owner.to_account_info(),
                            ctx.accounts.mint.to_account_info(),
                            ctx.accounts.system_program.to_account_info(),
                        ],
                        &[&[
                            ASSET_PREFIX.as_bytes(),
                            voucher.merkle_slab.key().as_ref(),
                            voucher.leaf_schema.nonce().to_le_bytes().as_ref(),
                            &[*ctx.bumps.get("mint").unwrap()],
                        ]],
                    )?;
                    invoke(
                        &spl_token::instruction::initialize_mint2(
                            &spl_token::id(),
                            &ctx.accounts.mint.key(),
                            &ctx.accounts.mint_authority.key(),
                            None,
                            0,
                        )?,
                        &[
                            ctx.accounts.token_program.to_account_info(),
                            ctx.accounts.mint.to_account_info(),
                        ],
                    )?;
                }
                if ctx.accounts.token_account.data_is_empty() {
                    invoke(
                        &spl_associated_token_account::instruction::create_associated_token_account(
                            &ctx.accounts.owner.key(),
                            &ctx.accounts.owner.key(),
                            &ctx.accounts.mint.key(),
                        ),
                        &[
                            ctx.accounts.owner.to_account_info(),
                            ctx.accounts.mint.to_account_info(),
                            ctx.accounts.token_account.to_account_info(),
                            ctx.accounts.token_program.to_account_info(),
                            ctx.accounts.associated_token_program.to_account_info(),
                            ctx.accounts.system_program.to_account_info(),
                            ctx.accounts.sysvar_rent.to_account_info(),
                        ],
                    )?;
                }
                invoke_signed(
                    &spl_token::instruction::mint_to(
                        &spl_token::id(),
                        &ctx.accounts.mint.key(),
                        &ctx.accounts.token_account.key(),
                        &ctx.accounts.mint_authority.key(),
                        &[],
                        1,
                    )?,
                    &[
                        ctx.accounts.mint.to_account_info(),
                        ctx.accounts.token_account.to_account_info(),
                        ctx.accounts.mint_authority.to_account_info(),
                        ctx.accounts.token_program.to_account_info(),
                    ],
                    &[&[
                        ctx.accounts.mint.key().as_ref(),
                        &[ctx.bumps["mint_authority"]],
                    ]],
                )?;
            }
            TokenProgramVersion::Token2022 => return Err(ProgramError::InvalidArgument.into()),
        }
        let metadata_infos = <[_]>::into_vec(box [
            ctx.accounts.metadata.to_account_info(),
            ctx.accounts.mint.to_account_info(),
            ctx.accounts.mint_authority.to_account_info(),
            ctx.accounts.owner.to_account_info(),
            ctx.accounts.token_metadata_program.to_account_info(),
            ctx.accounts.token_program.to_account_info(),
            ctx.accounts.system_program.to_account_info(),
            ctx.accounts.sysvar_rent.to_account_info(),
        ]);
        let master_edition_infos = <[_]>::into_vec(box [
            ctx.accounts.master_edition.to_account_info(),
            ctx.accounts.mint.to_account_info(),
            ctx.accounts.mint_authority.to_account_info(),
            ctx.accounts.owner.to_account_info(),
            ctx.accounts.metadata.to_account_info(),
            ctx.accounts.token_metadata_program.to_account_info(),
            ctx.accounts.token_program.to_account_info(),
            ctx.accounts.system_program.to_account_info(),
            ctx.accounts.sysvar_rent.to_account_info(),
        ]);
        ::solana_program::log::sol_log("Creating metadata!");
        invoke_signed(
            &mpl_token_metadata::instruction::create_metadata_accounts_v2(
                ctx.accounts.token_metadata_program.key(),
                ctx.accounts.metadata.key(),
                ctx.accounts.mint.key(),
                ctx.accounts.mint_authority.key(),
                ctx.accounts.owner.key(),
                ctx.accounts.mint_authority.key(),
                metadata.name.clone(),
                metadata.symbol.clone(),
                metadata.uri.clone(),
                if metadata.creators.len() > 0 {
                    let mut amended_metadata_creators = metadata.creators;
                    amended_metadata_creators.push(Creator {
                        address: ctx.accounts.mint_authority.key(),
                        verified: true,
                        share: 0,
                    });
                    Some(
                        amended_metadata_creators
                            .iter()
                            .map(|c| c.adapt())
                            .collect(),
                    )
                } else {
                    None
                },
                metadata.seller_fee_basis_points,
                true,
                metadata.is_mutable,
                match metadata.collection {
                    Some(c) => Some(c.adapt()),
                    None => None,
                },
                match metadata.uses {
                    Some(u) => Some(u.adapt()),
                    None => None,
                },
            ),
            metadata_infos.as_slice(),
            &[&[
                ctx.accounts.mint.key().as_ref(),
                &[ctx.bumps["mint_authority"]],
            ]],
        )?;
        ::solana_program::log::sol_log("Creating master edition!");
        invoke_signed(
            &mpl_token_metadata::instruction::create_master_edition_v3(
                ctx.accounts.token_metadata_program.key(),
                ctx.accounts.master_edition.key(),
                ctx.accounts.mint.key(),
                ctx.accounts.mint_authority.key(),
                ctx.accounts.mint_authority.key(),
                ctx.accounts.metadata.key(),
                ctx.accounts.owner.key(),
                Some(0),
            ),
            master_edition_infos.as_slice(),
            &[&[
                ctx.accounts.mint.key().as_ref(),
                &[ctx.bumps["mint_authority"]],
            ]],
        )?;
        {
            anchor_lang::solana_program::log::sol_log_data(&[&anchor_lang::Event::data(&event)]);
        };
        Ok(())
    }
    pub fn compress(_ctx: Context<Compress>) -> Result<()> {
        Ok(())
    }
}
/// An Anchor generated module containing the program's set of
/// instructions, where each method handler in the `#[program]` mod is
/// associated with a struct defining the input arguments to the
/// method. These should be used directly, when one wants to serialize
/// Anchor instruction data, for example, when speciying
/// instructions on a client.
pub mod instruction {
    use super::*;
    /// Instruction struct definitions for `#[state]` methods.
    pub mod state {
        use super::*;
    }
    /// Instruction.
    pub struct CreateTree {
        pub max_depth: u32,
        pub max_buffer_size: u32,
    }
    impl borsh::ser::BorshSerialize for CreateTree
    where
        u32: borsh::ser::BorshSerialize,
        u32: borsh::ser::BorshSerialize,
    {
        fn serialize<W: borsh::maybestd::io::Write>(
            &self,
            writer: &mut W,
        ) -> ::core::result::Result<(), borsh::maybestd::io::Error> {
            borsh::BorshSerialize::serialize(&self.max_depth, writer)?;
            borsh::BorshSerialize::serialize(&self.max_buffer_size, writer)?;
            Ok(())
        }
    }
    impl borsh::de::BorshDeserialize for CreateTree
    where
        u32: borsh::BorshDeserialize,
        u32: borsh::BorshDeserialize,
    {
        fn deserialize(
            buf: &mut &[u8],
        ) -> ::core::result::Result<Self, borsh::maybestd::io::Error> {
            Ok(Self {
                max_depth: borsh::BorshDeserialize::deserialize(buf)?,
                max_buffer_size: borsh::BorshDeserialize::deserialize(buf)?,
            })
        }
    }
    impl anchor_lang::InstructionData for CreateTree {
        fn data(&self) -> Vec<u8> {
            let mut d = [165, 83, 136, 142, 89, 202, 47, 220].to_vec();
            d.append(&mut self.try_to_vec().expect("Should always serialize"));
            d
        }
    }
    /// Instruction.
    pub struct CreateDefaultMintRequest {
        pub mint_capacity: u64,
    }
    impl borsh::ser::BorshSerialize for CreateDefaultMintRequest
    where
        u64: borsh::ser::BorshSerialize,
    {
        fn serialize<W: borsh::maybestd::io::Write>(
            &self,
            writer: &mut W,
        ) -> ::core::result::Result<(), borsh::maybestd::io::Error> {
            borsh::BorshSerialize::serialize(&self.mint_capacity, writer)?;
            Ok(())
        }
    }
    impl borsh::de::BorshDeserialize for CreateDefaultMintRequest
    where
        u64: borsh::BorshDeserialize,
    {
        fn deserialize(
            buf: &mut &[u8],
        ) -> ::core::result::Result<Self, borsh::maybestd::io::Error> {
            Ok(Self {
                mint_capacity: borsh::BorshDeserialize::deserialize(buf)?,
            })
        }
    }
    impl anchor_lang::InstructionData for CreateDefaultMintRequest {
        fn data(&self) -> Vec<u8> {
            let mut d = [120, 51, 89, 77, 2, 133, 224, 130].to_vec();
            d.append(&mut self.try_to_vec().expect("Should always serialize"));
            d
        }
    }
    /// Instruction.
    pub struct RequestMintAuthority {
        pub mint_capacity: u64,
    }
    impl borsh::ser::BorshSerialize for RequestMintAuthority
    where
        u64: borsh::ser::BorshSerialize,
    {
        fn serialize<W: borsh::maybestd::io::Write>(
            &self,
            writer: &mut W,
        ) -> ::core::result::Result<(), borsh::maybestd::io::Error> {
            borsh::BorshSerialize::serialize(&self.mint_capacity, writer)?;
            Ok(())
        }
    }
    impl borsh::de::BorshDeserialize for RequestMintAuthority
    where
        u64: borsh::BorshDeserialize,
    {
        fn deserialize(
            buf: &mut &[u8],
        ) -> ::core::result::Result<Self, borsh::maybestd::io::Error> {
            Ok(Self {
                mint_capacity: borsh::BorshDeserialize::deserialize(buf)?,
            })
        }
    }
    impl anchor_lang::InstructionData for RequestMintAuthority {
        fn data(&self) -> Vec<u8> {
            let mut d = [68, 130, 170, 21, 167, 61, 63, 76].to_vec();
            d.append(&mut self.try_to_vec().expect("Should always serialize"));
            d
        }
    }
    /// Instruction.
    pub struct ApproveMintAuthorityRequest {
        pub num_mints_to_approve: u64,
    }
    impl borsh::ser::BorshSerialize for ApproveMintAuthorityRequest
    where
        u64: borsh::ser::BorshSerialize,
    {
        fn serialize<W: borsh::maybestd::io::Write>(
            &self,
            writer: &mut W,
        ) -> ::core::result::Result<(), borsh::maybestd::io::Error> {
            borsh::BorshSerialize::serialize(&self.num_mints_to_approve, writer)?;
            Ok(())
        }
    }
    impl borsh::de::BorshDeserialize for ApproveMintAuthorityRequest
    where
        u64: borsh::BorshDeserialize,
    {
        fn deserialize(
            buf: &mut &[u8],
        ) -> ::core::result::Result<Self, borsh::maybestd::io::Error> {
            Ok(Self {
                num_mints_to_approve: borsh::BorshDeserialize::deserialize(buf)?,
            })
        }
    }
    impl anchor_lang::InstructionData for ApproveMintAuthorityRequest {
        fn data(&self) -> Vec<u8> {
            let mut d = [59, 153, 108, 196, 228, 165, 169, 242].to_vec();
            d.append(&mut self.try_to_vec().expect("Should always serialize"));
            d
        }
    }
    /// Instruction.
    pub struct CloseMintRequest;
    impl borsh::ser::BorshSerialize for CloseMintRequest {
        fn serialize<W: borsh::maybestd::io::Write>(
            &self,
            writer: &mut W,
        ) -> ::core::result::Result<(), borsh::maybestd::io::Error> {
            Ok(())
        }
    }
    impl borsh::de::BorshDeserialize for CloseMintRequest {
        fn deserialize(
            buf: &mut &[u8],
        ) -> ::core::result::Result<Self, borsh::maybestd::io::Error> {
            Ok(Self {})
        }
    }
    impl anchor_lang::InstructionData for CloseMintRequest {
        fn data(&self) -> Vec<u8> {
            let mut d = [110, 107, 165, 251, 73, 53, 214, 194].to_vec();
            d.append(&mut self.try_to_vec().expect("Should always serialize"));
            d
        }
    }
    /// Instruction.
    pub struct SetTreeDelegate;
    impl borsh::ser::BorshSerialize for SetTreeDelegate {
        fn serialize<W: borsh::maybestd::io::Write>(
            &self,
            writer: &mut W,
        ) -> ::core::result::Result<(), borsh::maybestd::io::Error> {
            Ok(())
        }
    }
    impl borsh::de::BorshDeserialize for SetTreeDelegate {
        fn deserialize(
            buf: &mut &[u8],
        ) -> ::core::result::Result<Self, borsh::maybestd::io::Error> {
            Ok(Self {})
        }
    }
    impl anchor_lang::InstructionData for SetTreeDelegate {
        fn data(&self) -> Vec<u8> {
            let mut d = [253, 118, 66, 37, 190, 49, 154, 102].to_vec();
            d.append(&mut self.try_to_vec().expect("Should always serialize"));
            d
        }
    }
    /// Instruction.
    pub struct MintV1 {
        pub message: MetadataArgs,
    }
    impl borsh::ser::BorshSerialize for MintV1
    where
        MetadataArgs: borsh::ser::BorshSerialize,
    {
        fn serialize<W: borsh::maybestd::io::Write>(
            &self,
            writer: &mut W,
        ) -> ::core::result::Result<(), borsh::maybestd::io::Error> {
            borsh::BorshSerialize::serialize(&self.message, writer)?;
            Ok(())
        }
    }
    impl borsh::de::BorshDeserialize for MintV1
    where
        MetadataArgs: borsh::BorshDeserialize,
    {
        fn deserialize(
            buf: &mut &[u8],
        ) -> ::core::result::Result<Self, borsh::maybestd::io::Error> {
            Ok(Self {
                message: borsh::BorshDeserialize::deserialize(buf)?,
            })
        }
    }
    impl anchor_lang::InstructionData for MintV1 {
        fn data(&self) -> Vec<u8> {
            let mut d = [145, 98, 192, 118, 184, 147, 118, 104].to_vec();
            d.append(&mut self.try_to_vec().expect("Should always serialize"));
            d
        }
    }
    /// Instruction.
    pub struct VerifyCreator {
        pub root: [u8; 32],
        pub data_hash: [u8; 32],
        pub creator_hash: [u8; 32],
        pub nonce: u64,
        pub index: u32,
        pub message: MetadataArgs,
    }
    impl borsh::ser::BorshSerialize for VerifyCreator
    where
        [u8; 32]: borsh::ser::BorshSerialize,
        [u8; 32]: borsh::ser::BorshSerialize,
        [u8; 32]: borsh::ser::BorshSerialize,
        u64: borsh::ser::BorshSerialize,
        u32: borsh::ser::BorshSerialize,
        MetadataArgs: borsh::ser::BorshSerialize,
    {
        fn serialize<W: borsh::maybestd::io::Write>(
            &self,
            writer: &mut W,
        ) -> ::core::result::Result<(), borsh::maybestd::io::Error> {
            borsh::BorshSerialize::serialize(&self.root, writer)?;
            borsh::BorshSerialize::serialize(&self.data_hash, writer)?;
            borsh::BorshSerialize::serialize(&self.creator_hash, writer)?;
            borsh::BorshSerialize::serialize(&self.nonce, writer)?;
            borsh::BorshSerialize::serialize(&self.index, writer)?;
            borsh::BorshSerialize::serialize(&self.message, writer)?;
            Ok(())
        }
    }
    impl borsh::de::BorshDeserialize for VerifyCreator
    where
        [u8; 32]: borsh::BorshDeserialize,
        [u8; 32]: borsh::BorshDeserialize,
        [u8; 32]: borsh::BorshDeserialize,
        u64: borsh::BorshDeserialize,
        u32: borsh::BorshDeserialize,
        MetadataArgs: borsh::BorshDeserialize,
    {
        fn deserialize(
            buf: &mut &[u8],
        ) -> ::core::result::Result<Self, borsh::maybestd::io::Error> {
            Ok(Self {
                root: borsh::BorshDeserialize::deserialize(buf)?,
                data_hash: borsh::BorshDeserialize::deserialize(buf)?,
                creator_hash: borsh::BorshDeserialize::deserialize(buf)?,
                nonce: borsh::BorshDeserialize::deserialize(buf)?,
                index: borsh::BorshDeserialize::deserialize(buf)?,
                message: borsh::BorshDeserialize::deserialize(buf)?,
            })
        }
    }
    impl anchor_lang::InstructionData for VerifyCreator {
        fn data(&self) -> Vec<u8> {
            let mut d = [52, 17, 96, 132, 71, 4, 85, 194].to_vec();
            d.append(&mut self.try_to_vec().expect("Should always serialize"));
            d
        }
    }
    /// Instruction.
    pub struct UnverifyCreator {
        pub root: [u8; 32],
        pub data_hash: [u8; 32],
        pub creator_hash: [u8; 32],
        pub nonce: u64,
        pub index: u32,
        pub message: MetadataArgs,
    }
    impl borsh::ser::BorshSerialize for UnverifyCreator
    where
        [u8; 32]: borsh::ser::BorshSerialize,
        [u8; 32]: borsh::ser::BorshSerialize,
        [u8; 32]: borsh::ser::BorshSerialize,
        u64: borsh::ser::BorshSerialize,
        u32: borsh::ser::BorshSerialize,
        MetadataArgs: borsh::ser::BorshSerialize,
    {
        fn serialize<W: borsh::maybestd::io::Write>(
            &self,
            writer: &mut W,
        ) -> ::core::result::Result<(), borsh::maybestd::io::Error> {
            borsh::BorshSerialize::serialize(&self.root, writer)?;
            borsh::BorshSerialize::serialize(&self.data_hash, writer)?;
            borsh::BorshSerialize::serialize(&self.creator_hash, writer)?;
            borsh::BorshSerialize::serialize(&self.nonce, writer)?;
            borsh::BorshSerialize::serialize(&self.index, writer)?;
            borsh::BorshSerialize::serialize(&self.message, writer)?;
            Ok(())
        }
    }
    impl borsh::de::BorshDeserialize for UnverifyCreator
    where
        [u8; 32]: borsh::BorshDeserialize,
        [u8; 32]: borsh::BorshDeserialize,
        [u8; 32]: borsh::BorshDeserialize,
        u64: borsh::BorshDeserialize,
        u32: borsh::BorshDeserialize,
        MetadataArgs: borsh::BorshDeserialize,
    {
        fn deserialize(
            buf: &mut &[u8],
        ) -> ::core::result::Result<Self, borsh::maybestd::io::Error> {
            Ok(Self {
                root: borsh::BorshDeserialize::deserialize(buf)?,
                data_hash: borsh::BorshDeserialize::deserialize(buf)?,
                creator_hash: borsh::BorshDeserialize::deserialize(buf)?,
                nonce: borsh::BorshDeserialize::deserialize(buf)?,
                index: borsh::BorshDeserialize::deserialize(buf)?,
                message: borsh::BorshDeserialize::deserialize(buf)?,
            })
        }
    }
    impl anchor_lang::InstructionData for UnverifyCreator {
        fn data(&self) -> Vec<u8> {
            let mut d = [107, 178, 57, 39, 105, 115, 112, 152].to_vec();
            d.append(&mut self.try_to_vec().expect("Should always serialize"));
            d
        }
    }
    /// Instruction.
    pub struct Transfer {
        pub root: [u8; 32],
        pub data_hash: [u8; 32],
        pub creator_hash: [u8; 32],
        pub nonce: u64,
        pub index: u32,
    }
    impl borsh::ser::BorshSerialize for Transfer
    where
        [u8; 32]: borsh::ser::BorshSerialize,
        [u8; 32]: borsh::ser::BorshSerialize,
        [u8; 32]: borsh::ser::BorshSerialize,
        u64: borsh::ser::BorshSerialize,
        u32: borsh::ser::BorshSerialize,
    {
        fn serialize<W: borsh::maybestd::io::Write>(
            &self,
            writer: &mut W,
        ) -> ::core::result::Result<(), borsh::maybestd::io::Error> {
            borsh::BorshSerialize::serialize(&self.root, writer)?;
            borsh::BorshSerialize::serialize(&self.data_hash, writer)?;
            borsh::BorshSerialize::serialize(&self.creator_hash, writer)?;
            borsh::BorshSerialize::serialize(&self.nonce, writer)?;
            borsh::BorshSerialize::serialize(&self.index, writer)?;
            Ok(())
        }
    }
    impl borsh::de::BorshDeserialize for Transfer
    where
        [u8; 32]: borsh::BorshDeserialize,
        [u8; 32]: borsh::BorshDeserialize,
        [u8; 32]: borsh::BorshDeserialize,
        u64: borsh::BorshDeserialize,
        u32: borsh::BorshDeserialize,
    {
        fn deserialize(
            buf: &mut &[u8],
        ) -> ::core::result::Result<Self, borsh::maybestd::io::Error> {
            Ok(Self {
                root: borsh::BorshDeserialize::deserialize(buf)?,
                data_hash: borsh::BorshDeserialize::deserialize(buf)?,
                creator_hash: borsh::BorshDeserialize::deserialize(buf)?,
                nonce: borsh::BorshDeserialize::deserialize(buf)?,
                index: borsh::BorshDeserialize::deserialize(buf)?,
            })
        }
    }
    impl anchor_lang::InstructionData for Transfer {
        fn data(&self) -> Vec<u8> {
            let mut d = [163, 52, 200, 231, 140, 3, 69, 186].to_vec();
            d.append(&mut self.try_to_vec().expect("Should always serialize"));
            d
        }
    }
    /// Instruction.
    pub struct Delegate {
        pub root: [u8; 32],
        pub data_hash: [u8; 32],
        pub creator_hash: [u8; 32],
        pub nonce: u64,
        pub index: u32,
    }
    impl borsh::ser::BorshSerialize for Delegate
    where
        [u8; 32]: borsh::ser::BorshSerialize,
        [u8; 32]: borsh::ser::BorshSerialize,
        [u8; 32]: borsh::ser::BorshSerialize,
        u64: borsh::ser::BorshSerialize,
        u32: borsh::ser::BorshSerialize,
    {
        fn serialize<W: borsh::maybestd::io::Write>(
            &self,
            writer: &mut W,
        ) -> ::core::result::Result<(), borsh::maybestd::io::Error> {
            borsh::BorshSerialize::serialize(&self.root, writer)?;
            borsh::BorshSerialize::serialize(&self.data_hash, writer)?;
            borsh::BorshSerialize::serialize(&self.creator_hash, writer)?;
            borsh::BorshSerialize::serialize(&self.nonce, writer)?;
            borsh::BorshSerialize::serialize(&self.index, writer)?;
            Ok(())
        }
    }
    impl borsh::de::BorshDeserialize for Delegate
    where
        [u8; 32]: borsh::BorshDeserialize,
        [u8; 32]: borsh::BorshDeserialize,
        [u8; 32]: borsh::BorshDeserialize,
        u64: borsh::BorshDeserialize,
        u32: borsh::BorshDeserialize,
    {
        fn deserialize(
            buf: &mut &[u8],
        ) -> ::core::result::Result<Self, borsh::maybestd::io::Error> {
            Ok(Self {
                root: borsh::BorshDeserialize::deserialize(buf)?,
                data_hash: borsh::BorshDeserialize::deserialize(buf)?,
                creator_hash: borsh::BorshDeserialize::deserialize(buf)?,
                nonce: borsh::BorshDeserialize::deserialize(buf)?,
                index: borsh::BorshDeserialize::deserialize(buf)?,
            })
        }
    }
    impl anchor_lang::InstructionData for Delegate {
        fn data(&self) -> Vec<u8> {
            let mut d = [90, 147, 75, 178, 85, 88, 4, 137].to_vec();
            d.append(&mut self.try_to_vec().expect("Should always serialize"));
            d
        }
    }
    /// Instruction.
    pub struct Burn {
        pub root: [u8; 32],
        pub data_hash: [u8; 32],
        pub creator_hash: [u8; 32],
        pub nonce: u64,
        pub index: u32,
    }
    impl borsh::ser::BorshSerialize for Burn
    where
        [u8; 32]: borsh::ser::BorshSerialize,
        [u8; 32]: borsh::ser::BorshSerialize,
        [u8; 32]: borsh::ser::BorshSerialize,
        u64: borsh::ser::BorshSerialize,
        u32: borsh::ser::BorshSerialize,
    {
        fn serialize<W: borsh::maybestd::io::Write>(
            &self,
            writer: &mut W,
        ) -> ::core::result::Result<(), borsh::maybestd::io::Error> {
            borsh::BorshSerialize::serialize(&self.root, writer)?;
            borsh::BorshSerialize::serialize(&self.data_hash, writer)?;
            borsh::BorshSerialize::serialize(&self.creator_hash, writer)?;
            borsh::BorshSerialize::serialize(&self.nonce, writer)?;
            borsh::BorshSerialize::serialize(&self.index, writer)?;
            Ok(())
        }
    }
    impl borsh::de::BorshDeserialize for Burn
    where
        [u8; 32]: borsh::BorshDeserialize,
        [u8; 32]: borsh::BorshDeserialize,
        [u8; 32]: borsh::BorshDeserialize,
        u64: borsh::BorshDeserialize,
        u32: borsh::BorshDeserialize,
    {
        fn deserialize(
            buf: &mut &[u8],
        ) -> ::core::result::Result<Self, borsh::maybestd::io::Error> {
            Ok(Self {
                root: borsh::BorshDeserialize::deserialize(buf)?,
                data_hash: borsh::BorshDeserialize::deserialize(buf)?,
                creator_hash: borsh::BorshDeserialize::deserialize(buf)?,
                nonce: borsh::BorshDeserialize::deserialize(buf)?,
                index: borsh::BorshDeserialize::deserialize(buf)?,
            })
        }
    }
    impl anchor_lang::InstructionData for Burn {
        fn data(&self) -> Vec<u8> {
            let mut d = [116, 110, 29, 56, 107, 219, 42, 93].to_vec();
            d.append(&mut self.try_to_vec().expect("Should always serialize"));
            d
        }
    }
    /// Instruction.
    pub struct Redeem {
        pub root: [u8; 32],
        pub data_hash: [u8; 32],
        pub creator_hash: [u8; 32],
        pub nonce: u64,
        pub index: u32,
    }
    impl borsh::ser::BorshSerialize for Redeem
    where
        [u8; 32]: borsh::ser::BorshSerialize,
        [u8; 32]: borsh::ser::BorshSerialize,
        [u8; 32]: borsh::ser::BorshSerialize,
        u64: borsh::ser::BorshSerialize,
        u32: borsh::ser::BorshSerialize,
    {
        fn serialize<W: borsh::maybestd::io::Write>(
            &self,
            writer: &mut W,
        ) -> ::core::result::Result<(), borsh::maybestd::io::Error> {
            borsh::BorshSerialize::serialize(&self.root, writer)?;
            borsh::BorshSerialize::serialize(&self.data_hash, writer)?;
            borsh::BorshSerialize::serialize(&self.creator_hash, writer)?;
            borsh::BorshSerialize::serialize(&self.nonce, writer)?;
            borsh::BorshSerialize::serialize(&self.index, writer)?;
            Ok(())
        }
    }
    impl borsh::de::BorshDeserialize for Redeem
    where
        [u8; 32]: borsh::BorshDeserialize,
        [u8; 32]: borsh::BorshDeserialize,
        [u8; 32]: borsh::BorshDeserialize,
        u64: borsh::BorshDeserialize,
        u32: borsh::BorshDeserialize,
    {
        fn deserialize(
            buf: &mut &[u8],
        ) -> ::core::result::Result<Self, borsh::maybestd::io::Error> {
            Ok(Self {
                root: borsh::BorshDeserialize::deserialize(buf)?,
                data_hash: borsh::BorshDeserialize::deserialize(buf)?,
                creator_hash: borsh::BorshDeserialize::deserialize(buf)?,
                nonce: borsh::BorshDeserialize::deserialize(buf)?,
                index: borsh::BorshDeserialize::deserialize(buf)?,
            })
        }
    }
    impl anchor_lang::InstructionData for Redeem {
        fn data(&self) -> Vec<u8> {
            let mut d = [184, 12, 86, 149, 70, 196, 97, 225].to_vec();
            d.append(&mut self.try_to_vec().expect("Should always serialize"));
            d
        }
    }
    /// Instruction.
    pub struct CancelRedeem {
        pub root: [u8; 32],
    }
    impl borsh::ser::BorshSerialize for CancelRedeem
    where
        [u8; 32]: borsh::ser::BorshSerialize,
    {
        fn serialize<W: borsh::maybestd::io::Write>(
            &self,
            writer: &mut W,
        ) -> ::core::result::Result<(), borsh::maybestd::io::Error> {
            borsh::BorshSerialize::serialize(&self.root, writer)?;
            Ok(())
        }
    }
    impl borsh::de::BorshDeserialize for CancelRedeem
    where
        [u8; 32]: borsh::BorshDeserialize,
    {
        fn deserialize(
            buf: &mut &[u8],
        ) -> ::core::result::Result<Self, borsh::maybestd::io::Error> {
            Ok(Self {
                root: borsh::BorshDeserialize::deserialize(buf)?,
            })
        }
    }
    impl anchor_lang::InstructionData for CancelRedeem {
        fn data(&self) -> Vec<u8> {
            let mut d = [111, 76, 232, 50, 39, 175, 48, 242].to_vec();
            d.append(&mut self.try_to_vec().expect("Should always serialize"));
            d
        }
    }
    /// Instruction.
    pub struct DecompressV1 {
        pub metadata: MetadataArgs,
    }
    impl borsh::ser::BorshSerialize for DecompressV1
    where
        MetadataArgs: borsh::ser::BorshSerialize,
    {
        fn serialize<W: borsh::maybestd::io::Write>(
            &self,
            writer: &mut W,
        ) -> ::core::result::Result<(), borsh::maybestd::io::Error> {
            borsh::BorshSerialize::serialize(&self.metadata, writer)?;
            Ok(())
        }
    }
    impl borsh::de::BorshDeserialize for DecompressV1
    where
        MetadataArgs: borsh::BorshDeserialize,
    {
        fn deserialize(
            buf: &mut &[u8],
        ) -> ::core::result::Result<Self, borsh::maybestd::io::Error> {
            Ok(Self {
                metadata: borsh::BorshDeserialize::deserialize(buf)?,
            })
        }
    }
    impl anchor_lang::InstructionData for DecompressV1 {
        fn data(&self) -> Vec<u8> {
            let mut d = [54, 85, 76, 70, 228, 250, 164, 81].to_vec();
            d.append(&mut self.try_to_vec().expect("Should always serialize"));
            d
        }
    }
    /// Instruction.
    pub struct Compress;
    impl borsh::ser::BorshSerialize for Compress {
        fn serialize<W: borsh::maybestd::io::Write>(
            &self,
            writer: &mut W,
        ) -> ::core::result::Result<(), borsh::maybestd::io::Error> {
            Ok(())
        }
    }
    impl borsh::de::BorshDeserialize for Compress {
        fn deserialize(
            buf: &mut &[u8],
        ) -> ::core::result::Result<Self, borsh::maybestd::io::Error> {
            Ok(Self {})
        }
    }
    impl anchor_lang::InstructionData for Compress {
        fn data(&self) -> Vec<u8> {
            let mut d = [82, 193, 176, 117, 176, 21, 115, 253].to_vec();
            d.append(&mut self.try_to_vec().expect("Should always serialize"));
            d
        }
    }
}
/// An Anchor generated module, providing a set of structs
/// mirroring the structs deriving `Accounts`, where each field is
/// a `Pubkey`. This is useful for specifying accounts for a client.
pub mod accounts {
    pub use crate::__client_accounts_creator_verification::*;
    pub use crate::__client_accounts_cancel_redeem::*;
    pub use crate::__client_accounts_burn::*;
    pub use crate::__client_accounts_set_tree_delegate::*;
    pub use crate::__client_accounts_close_mint_request::*;
    pub use crate::__client_accounts_decompress_v1::*;
    pub use crate::__client_accounts_approve_mint_request::*;
    pub use crate::__client_accounts_delegate::*;
    pub use crate::__client_accounts_redeem::*;
    pub use crate::__client_accounts_create_tree::*;
    pub use crate::__client_accounts_mint_v1::*;
    pub use crate::__client_accounts_set_default_mint_request::*;
    pub use crate::__client_accounts_transfer::*;
    pub use crate::__client_accounts_compress::*;
    pub use crate::__client_accounts_set_mint_request::*;
}
#![feature(prelude_import)]
#[prelude_import]
use std::prelude::rust_2018::*;
#[macro_use]
extern crate std;
use {
    crate::error::BubblegumError,
    crate::state::metaplex_anchor::MplTokenMetadata,
    crate::state::{
        leaf_schema::{LeafSchema, Version},
        metaplex_adapter::{Creator, MetadataArgs, TokenProgramVersion},
        metaplex_anchor::{MasterEdition, TokenMetadata},
        request::{MintRequest, MINT_REQUEST_SIZE},
        NFTDecompressionEvent, NewNFTEvent, TreeConfig, Voucher, ASSET_PREFIX, TREE_AUTHORITY_SIZE,
        VOUCHER_PREFIX, VOUCHER_SIZE,
    },
    crate::utils::{
        append_leaf, assert_metadata_is_mpl_compatible, assert_pubkey_equal, cmp_bytes,
        cmp_pubkeys, get_asset_id, replace_leaf,
    },
    anchor_lang::{
        prelude::*,
        solana_program::{
            keccak,
            program::{invoke, invoke_signed},
            program_error::ProgramError,
            program_pack::Pack,
            system_instruction,
            account_info::AccountInfo,
        },
    },
    spl_compression::{
        Node,
        data_wrapper::{Wrapper, wrap_event},
    },
    spl_token::state::Mint as SplMint,
    std::collections::HashSet,
};
pub mod error {
    use anchor_lang::prelude::*;
    #[repr(u32)]
    pub enum BubblegumError {
        AssetOwnerMismatch,
        PublicKeyMismatch,
        HashingMismatch,
        UnsupportedSchemaVersion,
        CreatorShareTotalMustBe100,
        DuplicateCreatorAddress,
        CreatorDidNotVerify,
        CreatorNotFound,
        NoCreatorsPresent,
        CreatorsTooLong,
        MetadataNameTooLong,
        MetadataSymbolTooLong,
        MetadataUriTooLong,
        MetadataBasisPointsTooHigh,
        InsufficientMintCapacity,
        MintRequestNotApproved,
        MintRequestKeyMismatch,
        MintRequestDiscriminatorMismatch,
        CloseMintRequestError,
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::fmt::Debug for BubblegumError {
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            match (&*self,) {
                (&BubblegumError::AssetOwnerMismatch,) => {
                    ::core::fmt::Formatter::write_str(f, "AssetOwnerMismatch")
                }
                (&BubblegumError::PublicKeyMismatch,) => {
                    ::core::fmt::Formatter::write_str(f, "PublicKeyMismatch")
                }
                (&BubblegumError::HashingMismatch,) => {
                    ::core::fmt::Formatter::write_str(f, "HashingMismatch")
                }
                (&BubblegumError::UnsupportedSchemaVersion,) => {
                    ::core::fmt::Formatter::write_str(f, "UnsupportedSchemaVersion")
                }
                (&BubblegumError::CreatorShareTotalMustBe100,) => {
                    ::core::fmt::Formatter::write_str(f, "CreatorShareTotalMustBe100")
                }
                (&BubblegumError::DuplicateCreatorAddress,) => {
                    ::core::fmt::Formatter::write_str(f, "DuplicateCreatorAddress")
                }
                (&BubblegumError::CreatorDidNotVerify,) => {
                    ::core::fmt::Formatter::write_str(f, "CreatorDidNotVerify")
                }
                (&BubblegumError::CreatorNotFound,) => {
                    ::core::fmt::Formatter::write_str(f, "CreatorNotFound")
                }
                (&BubblegumError::NoCreatorsPresent,) => {
                    ::core::fmt::Formatter::write_str(f, "NoCreatorsPresent")
                }
                (&BubblegumError::CreatorsTooLong,) => {
                    ::core::fmt::Formatter::write_str(f, "CreatorsTooLong")
                }
                (&BubblegumError::MetadataNameTooLong,) => {
                    ::core::fmt::Formatter::write_str(f, "MetadataNameTooLong")
                }
                (&BubblegumError::MetadataSymbolTooLong,) => {
                    ::core::fmt::Formatter::write_str(f, "MetadataSymbolTooLong")
                }
                (&BubblegumError::MetadataUriTooLong,) => {
                    ::core::fmt::Formatter::write_str(f, "MetadataUriTooLong")
                }
                (&BubblegumError::MetadataBasisPointsTooHigh,) => {
                    ::core::fmt::Formatter::write_str(f, "MetadataBasisPointsTooHigh")
                }
                (&BubblegumError::InsufficientMintCapacity,) => {
                    ::core::fmt::Formatter::write_str(f, "InsufficientMintCapacity")
                }
                (&BubblegumError::MintRequestNotApproved,) => {
                    ::core::fmt::Formatter::write_str(f, "MintRequestNotApproved")
                }
                (&BubblegumError::MintRequestKeyMismatch,) => {
                    ::core::fmt::Formatter::write_str(f, "MintRequestKeyMismatch")
                }
                (&BubblegumError::MintRequestDiscriminatorMismatch,) => {
                    ::core::fmt::Formatter::write_str(f, "MintRequestDiscriminatorMismatch")
                }
                (&BubblegumError::CloseMintRequestError,) => {
                    ::core::fmt::Formatter::write_str(f, "CloseMintRequestError")
                }
            }
        }
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::clone::Clone for BubblegumError {
        #[inline]
        fn clone(&self) -> BubblegumError {
            {
                *self
            }
        }
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::marker::Copy for BubblegumError {}
    impl BubblegumError {
        /// Gets the name of this [#enum_name].
        pub fn name(&self) -> String {
            match self {
                BubblegumError::AssetOwnerMismatch => "AssetOwnerMismatch".to_string(),
                BubblegumError::PublicKeyMismatch => "PublicKeyMismatch".to_string(),
                BubblegumError::HashingMismatch => "HashingMismatch".to_string(),
                BubblegumError::UnsupportedSchemaVersion => "UnsupportedSchemaVersion".to_string(),
                BubblegumError::CreatorShareTotalMustBe100 => {
                    "CreatorShareTotalMustBe100".to_string()
                }
                BubblegumError::DuplicateCreatorAddress => "DuplicateCreatorAddress".to_string(),
                BubblegumError::CreatorDidNotVerify => "CreatorDidNotVerify".to_string(),
                BubblegumError::CreatorNotFound => "CreatorNotFound".to_string(),
                BubblegumError::NoCreatorsPresent => "NoCreatorsPresent".to_string(),
                BubblegumError::CreatorsTooLong => "CreatorsTooLong".to_string(),
                BubblegumError::MetadataNameTooLong => "MetadataNameTooLong".to_string(),
                BubblegumError::MetadataSymbolTooLong => "MetadataSymbolTooLong".to_string(),
                BubblegumError::MetadataUriTooLong => "MetadataUriTooLong".to_string(),
                BubblegumError::MetadataBasisPointsTooHigh => {
                    "MetadataBasisPointsTooHigh".to_string()
                }
                BubblegumError::InsufficientMintCapacity => "InsufficientMintCapacity".to_string(),
                BubblegumError::MintRequestNotApproved => "MintRequestNotApproved".to_string(),
                BubblegumError::MintRequestKeyMismatch => "MintRequestKeyMismatch".to_string(),
                BubblegumError::MintRequestDiscriminatorMismatch => {
                    "MintRequestDiscriminatorMismatch".to_string()
                }
                BubblegumError::CloseMintRequestError => "CloseMintRequestError".to_string(),
            }
        }
    }
    impl From<BubblegumError> for u32 {
        fn from(e: BubblegumError) -> u32 {
            e as u32 + anchor_lang::error::ERROR_CODE_OFFSET
        }
    }
    impl From<BubblegumError> for anchor_lang::error::Error {
        fn from(error_code: BubblegumError) -> anchor_lang::error::Error {
            anchor_lang::error::Error::from(anchor_lang::error::AnchorError {
                error_name: error_code.name(),
                error_code_number: error_code.into(),
                error_msg: error_code.to_string(),
                error_origin: None,
                compared_values: None,
            })
        }
    }
    impl std::fmt::Display for BubblegumError {
        fn fmt(
            &self,
            fmt: &mut std::fmt::Formatter<'_>,
        ) -> std::result::Result<(), std::fmt::Error> {
            match self {
                BubblegumError::AssetOwnerMismatch => {
                    let result = fmt.write_fmt(::core::fmt::Arguments::new_v1(
                        &["Asset Owner Does not match"],
                        &[],
                    ));
                    result
                }
                BubblegumError::PublicKeyMismatch => {
                    let result =
                        fmt.write_fmt(::core::fmt::Arguments::new_v1(&["PublicKeyMismatch"], &[]));
                    result
                }
                BubblegumError::HashingMismatch => {
                    let result = fmt.write_fmt(::core::fmt::Arguments::new_v1(
                        &["Hashing Mismatch Within Leaf Schema"],
                        &[],
                    ));
                    result
                }
                BubblegumError::UnsupportedSchemaVersion => {
                    let result = fmt.write_fmt(::core::fmt::Arguments::new_v1(
                        &["Unsupported Schema Version"],
                        &[],
                    ));
                    result
                }
                BubblegumError::CreatorShareTotalMustBe100 => {
                    let result = fmt.write_fmt(::core::fmt::Arguments::new_v1(
                        &["Creator shares must sum to 100"],
                        &[],
                    ));
                    result
                }
                BubblegumError::DuplicateCreatorAddress => {
                    let result = fmt.write_fmt(::core::fmt::Arguments::new_v1(
                        &["No duplicate creator addresses in metadata"],
                        &[],
                    ));
                    result
                }
                BubblegumError::CreatorDidNotVerify => {
                    let result = fmt.write_fmt(::core::fmt::Arguments::new_v1(
                        &["Creator did not verify the metadata"],
                        &[],
                    ));
                    result
                }
                BubblegumError::CreatorNotFound => {
                    let result = fmt.write_fmt(::core::fmt::Arguments::new_v1(
                        &["Creator not found in creator Vec"],
                        &[],
                    ));
                    result
                }
                BubblegumError::NoCreatorsPresent => {
                    let result = fmt.write_fmt(::core::fmt::Arguments::new_v1(
                        &["No creators in creator Vec"],
                        &[],
                    ));
                    result
                }
                BubblegumError::CreatorsTooLong => {
                    let result = fmt.write_fmt(::core::fmt::Arguments::new_v1(
                        &["Creators list too long"],
                        &[],
                    ));
                    result
                }
                BubblegumError::MetadataNameTooLong => {
                    let result = fmt.write_fmt(::core::fmt::Arguments::new_v1(
                        &["Name in metadata is too long"],
                        &[],
                    ));
                    result
                }
                BubblegumError::MetadataSymbolTooLong => {
                    let result = fmt.write_fmt(::core::fmt::Arguments::new_v1(
                        &["Symbol in metadata is too long"],
                        &[],
                    ));
                    result
                }
                BubblegumError::MetadataUriTooLong => {
                    let result = fmt.write_fmt(::core::fmt::Arguments::new_v1(
                        &["Uri in metadata is too long"],
                        &[],
                    ));
                    result
                }
                BubblegumError::MetadataBasisPointsTooHigh => {
                    let result = fmt.write_fmt(::core::fmt::Arguments::new_v1(
                        &["Basis points in metadata cannot exceed 10000"],
                        &[],
                    ));
                    result
                }
                BubblegumError::InsufficientMintCapacity => {
                    let result = fmt.write_fmt(::core::fmt::Arguments::new_v1(
                        &["Not enough unapproved mints left"],
                        &[],
                    ));
                    result
                }
                BubblegumError::MintRequestNotApproved => {
                    let result = fmt.write_fmt(::core::fmt::Arguments::new_v1(
                        &["Mint request not approved"],
                        &[],
                    ));
                    result
                }
                BubblegumError::MintRequestKeyMismatch => {
                    let result = fmt.write_fmt(::core::fmt::Arguments::new_v1(
                        &["Mint authority key does not match request"],
                        &[],
                    ));
                    result
                }
                BubblegumError::MintRequestDiscriminatorMismatch => {
                    let result = fmt.write_fmt(::core::fmt::Arguments::new_v1(
                        &["Mint request data has incorrect disciminator"],
                        &[],
                    ));
                    result
                }
                BubblegumError::CloseMintRequestError => {
                    let result = fmt.write_fmt(::core::fmt::Arguments::new_v1(
                        &["Something went wrong closing mint request"],
                        &[],
                    ));
                    result
                }
            }
        }
    }
}
pub mod state {
    pub mod leaf_schema {
        use anchor_lang::{prelude::*, solana_program::keccak};
        use spl_compression::Node;
        pub struct LeafSchemaEvent {
            pub version: Version,
            pub schema: LeafSchema,
            pub leaf_hash: [u8; 32],
        }
        impl borsh::ser::BorshSerialize for LeafSchemaEvent
        where
            Version: borsh::ser::BorshSerialize,
            LeafSchema: borsh::ser::BorshSerialize,
            [u8; 32]: borsh::ser::BorshSerialize,
        {
            fn serialize<W: borsh::maybestd::io::Write>(
                &self,
                writer: &mut W,
            ) -> ::core::result::Result<(), borsh::maybestd::io::Error> {
                borsh::BorshSerialize::serialize(&self.version, writer)?;
                borsh::BorshSerialize::serialize(&self.schema, writer)?;
                borsh::BorshSerialize::serialize(&self.leaf_hash, writer)?;
                Ok(())
            }
        }
        impl borsh::de::BorshDeserialize for LeafSchemaEvent
        where
            Version: borsh::BorshDeserialize,
            LeafSchema: borsh::BorshDeserialize,
            [u8; 32]: borsh::BorshDeserialize,
        {
            fn deserialize(
                buf: &mut &[u8],
            ) -> ::core::result::Result<Self, borsh::maybestd::io::Error> {
                Ok(Self {
                    version: borsh::BorshDeserialize::deserialize(buf)?,
                    schema: borsh::BorshDeserialize::deserialize(buf)?,
                    leaf_hash: borsh::BorshDeserialize::deserialize(buf)?,
                })
            }
        }
        impl anchor_lang::Event for LeafSchemaEvent {
            fn data(&self) -> Vec<u8> {
                let mut d = [56, 139, 154, 164, 204, 170, 78, 204].to_vec();
                d.append(&mut self.try_to_vec().unwrap());
                d
            }
        }
        impl anchor_lang::Discriminator for LeafSchemaEvent {
            fn discriminator() -> [u8; 8] {
                [56, 139, 154, 164, 204, 170, 78, 204]
            }
        }
        pub enum Version {
            V1,
        }
        impl borsh::de::BorshDeserialize for Version {
            fn deserialize(
                buf: &mut &[u8],
            ) -> core::result::Result<Self, borsh::maybestd::io::Error> {
                let variant_idx: u8 = borsh::BorshDeserialize::deserialize(buf)?;
                let return_value = match variant_idx {
                    0u8 => Version::V1,
                    _ => {
                        let msg = {
                            let res = ::alloc::fmt::format(::core::fmt::Arguments::new_v1(
                                &["Unexpected variant index: "],
                                &[::core::fmt::ArgumentV1::new_debug(&variant_idx)],
                            ));
                            res
                        };
                        return Err(borsh::maybestd::io::Error::new(
                            borsh::maybestd::io::ErrorKind::InvalidInput,
                            msg,
                        ));
                    }
                };
                Ok(return_value)
            }
        }
        impl borsh::ser::BorshSerialize for Version {
            fn serialize<W: borsh::maybestd::io::Write>(
                &self,
                writer: &mut W,
            ) -> core::result::Result<(), borsh::maybestd::io::Error> {
                let variant_idx: u8 = match self {
                    Version::V1 => 0u8,
                };
                writer.write_all(&variant_idx.to_le_bytes())?;
                match self {
                    Version::V1 => {}
                }
                Ok(())
            }
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::core::clone::Clone for Version {
            #[inline]
            fn clone(&self) -> Version {
                {
                    *self
                }
            }
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::core::marker::Copy for Version {}
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::core::fmt::Debug for Version {
            fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                match (&*self,) {
                    (&Version::V1,) => ::core::fmt::Formatter::write_str(f, "V1"),
                }
            }
        }
        impl Default for Version {
            fn default() -> Self {
                Version::V1
            }
        }
        impl Version {
            pub fn to_bytes(&self) -> u8 {
                match self {
                    Version::V1 => 1,
                }
            }
        }
        pub enum LeafSchema {
            V1 {
                id: Pubkey,
                owner: Pubkey,
                delegate: Pubkey,
                nonce: u64,
                data_hash: [u8; 32],
                creator_hash: [u8; 32],
            },
        }
        impl borsh::de::BorshDeserialize for LeafSchema
        where
            Pubkey: borsh::BorshDeserialize,
            Pubkey: borsh::BorshDeserialize,
            Pubkey: borsh::BorshDeserialize,
            u64: borsh::BorshDeserialize,
            [u8; 32]: borsh::BorshDeserialize,
            [u8; 32]: borsh::BorshDeserialize,
        {
            fn deserialize(
                buf: &mut &[u8],
            ) -> core::result::Result<Self, borsh::maybestd::io::Error> {
                let variant_idx: u8 = borsh::BorshDeserialize::deserialize(buf)?;
                let return_value = match variant_idx {
                    0u8 => LeafSchema::V1 {
                        id: borsh::BorshDeserialize::deserialize(buf)?,
                        owner: borsh::BorshDeserialize::deserialize(buf)?,
                        delegate: borsh::BorshDeserialize::deserialize(buf)?,
                        nonce: borsh::BorshDeserialize::deserialize(buf)?,
                        data_hash: borsh::BorshDeserialize::deserialize(buf)?,
                        creator_hash: borsh::BorshDeserialize::deserialize(buf)?,
                    },
                    _ => {
                        let msg = {
                            let res = ::alloc::fmt::format(::core::fmt::Arguments::new_v1(
                                &["Unexpected variant index: "],
                                &[::core::fmt::ArgumentV1::new_debug(&variant_idx)],
                            ));
                            res
                        };
                        return Err(borsh::maybestd::io::Error::new(
                            borsh::maybestd::io::ErrorKind::InvalidInput,
                            msg,
                        ));
                    }
                };
                Ok(return_value)
            }
        }
        impl borsh::ser::BorshSerialize for LeafSchema
        where
            Pubkey: borsh::ser::BorshSerialize,
            Pubkey: borsh::ser::BorshSerialize,
            Pubkey: borsh::ser::BorshSerialize,
            u64: borsh::ser::BorshSerialize,
            [u8; 32]: borsh::ser::BorshSerialize,
            [u8; 32]: borsh::ser::BorshSerialize,
        {
            fn serialize<W: borsh::maybestd::io::Write>(
                &self,
                writer: &mut W,
            ) -> core::result::Result<(), borsh::maybestd::io::Error> {
                let variant_idx: u8 = match self {
                    LeafSchema::V1 { .. } => 0u8,
                };
                writer.write_all(&variant_idx.to_le_bytes())?;
                match self {
                    LeafSchema::V1 {
                        id,
                        owner,
                        delegate,
                        nonce,
                        data_hash,
                        creator_hash,
                    } => {
                        borsh::BorshSerialize::serialize(id, writer)?;
                        borsh::BorshSerialize::serialize(owner, writer)?;
                        borsh::BorshSerialize::serialize(delegate, writer)?;
                        borsh::BorshSerialize::serialize(nonce, writer)?;
                        borsh::BorshSerialize::serialize(data_hash, writer)?;
                        borsh::BorshSerialize::serialize(creator_hash, writer)?;
                    }
                }
                Ok(())
            }
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::core::clone::Clone for LeafSchema {
            #[inline]
            fn clone(&self) -> LeafSchema {
                {
                    let _: ::core::clone::AssertParamIsClone<Pubkey>;
                    let _: ::core::clone::AssertParamIsClone<Pubkey>;
                    let _: ::core::clone::AssertParamIsClone<Pubkey>;
                    let _: ::core::clone::AssertParamIsClone<u64>;
                    let _: ::core::clone::AssertParamIsClone<[u8; 32]>;
                    let _: ::core::clone::AssertParamIsClone<[u8; 32]>;
                    *self
                }
            }
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::core::marker::Copy for LeafSchema {}
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::core::fmt::Debug for LeafSchema {
            fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                match (&*self,) {
                    (&LeafSchema::V1 {
                        id: ref __self_0,
                        owner: ref __self_1,
                        delegate: ref __self_2,
                        nonce: ref __self_3,
                        data_hash: ref __self_4,
                        creator_hash: ref __self_5,
                    },) => {
                        let debug_trait_builder =
                            &mut ::core::fmt::Formatter::debug_struct(f, "V1");
                        let _ = ::core::fmt::DebugStruct::field(
                            debug_trait_builder,
                            "id",
                            &&(*__self_0),
                        );
                        let _ = ::core::fmt::DebugStruct::field(
                            debug_trait_builder,
                            "owner",
                            &&(*__self_1),
                        );
                        let _ = ::core::fmt::DebugStruct::field(
                            debug_trait_builder,
                            "delegate",
                            &&(*__self_2),
                        );
                        let _ = ::core::fmt::DebugStruct::field(
                            debug_trait_builder,
                            "nonce",
                            &&(*__self_3),
                        );
                        let _ = ::core::fmt::DebugStruct::field(
                            debug_trait_builder,
                            "data_hash",
                            &&(*__self_4),
                        );
                        let _ = ::core::fmt::DebugStruct::field(
                            debug_trait_builder,
                            "creator_hash",
                            &&(*__self_5),
                        );
                        ::core::fmt::DebugStruct::finish(debug_trait_builder)
                    }
                }
            }
        }
        impl Default for LeafSchema {
            fn default() -> Self {
                Self::V1 {
                    id: Default::default(),
                    owner: Default::default(),
                    delegate: Default::default(),
                    nonce: 0,
                    data_hash: [0; 32],
                    creator_hash: [0; 32],
                }
            }
        }
        impl LeafSchema {
            pub fn new_v0(
                id: Pubkey,
                owner: Pubkey,
                delegate: Pubkey,
                nonce: u64,
                data_hash: [u8; 32],
                creator_hash: [u8; 32],
            ) -> Self {
                Self::V1 {
                    id,
                    owner,
                    delegate,
                    nonce,
                    data_hash,
                    creator_hash,
                }
            }
            pub fn version(&self) -> Version {
                match self {
                    LeafSchema::V1 { .. } => Version::V1,
                }
            }
            pub fn id(&self) -> Pubkey {
                match self {
                    LeafSchema::V1 { id, .. } => *id,
                }
            }
            pub fn nonce(&self) -> u64 {
                match self {
                    LeafSchema::V1 { nonce, .. } => *nonce,
                }
            }
            pub fn data_hash(&self) -> [u8; 32] {
                match self {
                    LeafSchema::V1 { data_hash, .. } => *data_hash,
                }
            }
            pub fn to_event(&self) -> LeafSchemaEvent {
                LeafSchemaEvent {
                    version: self.version(),
                    schema: *self,
                    leaf_hash: self.to_node(),
                }
            }
            pub fn to_node(&self) -> Node {
                let hashed_leaf = match self {
                    LeafSchema::V1 {
                        id,
                        owner,
                        delegate,
                        nonce,
                        data_hash,
                        creator_hash,
                    } => keccak::hashv(&[
                        &[self.version().to_bytes()],
                        id.as_ref(),
                        owner.as_ref(),
                        delegate.as_ref(),
                        nonce.to_le_bytes().as_ref(),
                        data_hash.as_ref(),
                        creator_hash.as_ref(),
                    ])
                    .to_bytes(),
                };
                hashed_leaf
            }
        }
    }
    pub mod metaplex_adapter {
        use anchor_lang::prelude::*;
        pub enum TokenProgramVersion {
            Original,
            Token2022,
        }
        impl borsh::ser::BorshSerialize for TokenProgramVersion {
            fn serialize<W: borsh::maybestd::io::Write>(
                &self,
                writer: &mut W,
            ) -> core::result::Result<(), borsh::maybestd::io::Error> {
                let variant_idx: u8 = match self {
                    TokenProgramVersion::Original => 0u8,
                    TokenProgramVersion::Token2022 => 1u8,
                };
                writer.write_all(&variant_idx.to_le_bytes())?;
                match self {
                    TokenProgramVersion::Original => {}
                    TokenProgramVersion::Token2022 => {}
                }
                Ok(())
            }
        }
        impl borsh::de::BorshDeserialize for TokenProgramVersion {
            fn deserialize(
                buf: &mut &[u8],
            ) -> core::result::Result<Self, borsh::maybestd::io::Error> {
                let variant_idx: u8 = borsh::BorshDeserialize::deserialize(buf)?;
                let return_value = match variant_idx {
                    0u8 => TokenProgramVersion::Original,
                    1u8 => TokenProgramVersion::Token2022,
                    _ => {
                        let msg = {
                            let res = ::alloc::fmt::format(::core::fmt::Arguments::new_v1(
                                &["Unexpected variant index: "],
                                &[::core::fmt::ArgumentV1::new_debug(&variant_idx)],
                            ));
                            res
                        };
                        return Err(borsh::maybestd::io::Error::new(
                            borsh::maybestd::io::ErrorKind::InvalidInput,
                            msg,
                        ));
                    }
                };
                Ok(return_value)
            }
        }
        impl ::core::marker::StructuralPartialEq for TokenProgramVersion {}
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::core::cmp::PartialEq for TokenProgramVersion {
            #[inline]
            fn eq(&self, other: &TokenProgramVersion) -> bool {
                {
                    let __self_vi = ::core::intrinsics::discriminant_value(&*self);
                    let __arg_1_vi = ::core::intrinsics::discriminant_value(&*other);
                    if true && __self_vi == __arg_1_vi {
                        match (&*self, &*other) {
                            _ => true,
                        }
                    } else {
                        false
                    }
                }
            }
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::core::marker::Copy for TokenProgramVersion {}
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::core::clone::Clone for TokenProgramVersion {
            #[inline]
            fn clone(&self) -> TokenProgramVersion {
                {
                    *self
                }
            }
        }
        pub struct Creator {
            pub address: Pubkey,
            pub verified: bool,
            pub share: u8,
        }
        impl borsh::ser::BorshSerialize for Creator
        where
            Pubkey: borsh::ser::BorshSerialize,
            bool: borsh::ser::BorshSerialize,
            u8: borsh::ser::BorshSerialize,
        {
            fn serialize<W: borsh::maybestd::io::Write>(
                &self,
                writer: &mut W,
            ) -> ::core::result::Result<(), borsh::maybestd::io::Error> {
                borsh::BorshSerialize::serialize(&self.address, writer)?;
                borsh::BorshSerialize::serialize(&self.verified, writer)?;
                borsh::BorshSerialize::serialize(&self.share, writer)?;
                Ok(())
            }
        }
        impl borsh::de::BorshDeserialize for Creator
        where
            Pubkey: borsh::BorshDeserialize,
            bool: borsh::BorshDeserialize,
            u8: borsh::BorshDeserialize,
        {
            fn deserialize(
                buf: &mut &[u8],
            ) -> ::core::result::Result<Self, borsh::maybestd::io::Error> {
                Ok(Self {
                    address: borsh::BorshDeserialize::deserialize(buf)?,
                    verified: borsh::BorshDeserialize::deserialize(buf)?,
                    share: borsh::BorshDeserialize::deserialize(buf)?,
                })
            }
        }
        impl ::core::marker::StructuralPartialEq for Creator {}
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::core::cmp::PartialEq for Creator {
            #[inline]
            fn eq(&self, other: &Creator) -> bool {
                match *other {
                    Creator {
                        address: ref __self_1_0,
                        verified: ref __self_1_1,
                        share: ref __self_1_2,
                    } => match *self {
                        Creator {
                            address: ref __self_0_0,
                            verified: ref __self_0_1,
                            share: ref __self_0_2,
                        } => {
                            (*__self_0_0) == (*__self_1_0)
                                && (*__self_0_1) == (*__self_1_1)
                                && (*__self_0_2) == (*__self_1_2)
                        }
                    },
                }
            }
            #[inline]
            fn ne(&self, other: &Creator) -> bool {
                match *other {
                    Creator {
                        address: ref __self_1_0,
                        verified: ref __self_1_1,
                        share: ref __self_1_2,
                    } => match *self {
                        Creator {
                            address: ref __self_0_0,
                            verified: ref __self_0_1,
                            share: ref __self_0_2,
                        } => {
                            (*__self_0_0) != (*__self_1_0)
                                || (*__self_0_1) != (*__self_1_1)
                                || (*__self_0_2) != (*__self_1_2)
                        }
                    },
                }
            }
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::core::marker::Copy for Creator {}
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::core::clone::Clone for Creator {
            #[inline]
            fn clone(&self) -> Creator {
                {
                    let _: ::core::clone::AssertParamIsClone<Pubkey>;
                    let _: ::core::clone::AssertParamIsClone<bool>;
                    let _: ::core::clone::AssertParamIsClone<u8>;
                    *self
                }
            }
        }
        impl Creator {
            pub fn adapt(&self) -> mpl_token_metadata::state::Creator {
                mpl_token_metadata::state::Creator {
                    address: self.address,
                    verified: self.verified,
                    share: self.share,
                }
            }
        }
        pub enum TokenStandard {
            NonFungible,
            FungibleAsset,
            Fungible,
            NonFungibleEdition,
        }
        impl borsh::ser::BorshSerialize for TokenStandard {
            fn serialize<W: borsh::maybestd::io::Write>(
                &self,
                writer: &mut W,
            ) -> core::result::Result<(), borsh::maybestd::io::Error> {
                let variant_idx: u8 = match self {
                    TokenStandard::NonFungible => 0u8,
                    TokenStandard::FungibleAsset => 1u8,
                    TokenStandard::Fungible => 2u8,
                    TokenStandard::NonFungibleEdition => 3u8,
                };
                writer.write_all(&variant_idx.to_le_bytes())?;
                match self {
                    TokenStandard::NonFungible => {}
                    TokenStandard::FungibleAsset => {}
                    TokenStandard::Fungible => {}
                    TokenStandard::NonFungibleEdition => {}
                }
                Ok(())
            }
        }
        impl borsh::de::BorshDeserialize for TokenStandard {
            fn deserialize(
                buf: &mut &[u8],
            ) -> core::result::Result<Self, borsh::maybestd::io::Error> {
                let variant_idx: u8 = borsh::BorshDeserialize::deserialize(buf)?;
                let return_value = match variant_idx {
                    0u8 => TokenStandard::NonFungible,
                    1u8 => TokenStandard::FungibleAsset,
                    2u8 => TokenStandard::Fungible,
                    3u8 => TokenStandard::NonFungibleEdition,
                    _ => {
                        let msg = {
                            let res = ::alloc::fmt::format(::core::fmt::Arguments::new_v1(
                                &["Unexpected variant index: "],
                                &[::core::fmt::ArgumentV1::new_debug(&variant_idx)],
                            ));
                            res
                        };
                        return Err(borsh::maybestd::io::Error::new(
                            borsh::maybestd::io::ErrorKind::InvalidInput,
                            msg,
                        ));
                    }
                };
                Ok(return_value)
            }
        }
        impl ::core::marker::StructuralPartialEq for TokenStandard {}
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::core::cmp::PartialEq for TokenStandard {
            #[inline]
            fn eq(&self, other: &TokenStandard) -> bool {
                {
                    let __self_vi = ::core::intrinsics::discriminant_value(&*self);
                    let __arg_1_vi = ::core::intrinsics::discriminant_value(&*other);
                    if true && __self_vi == __arg_1_vi {
                        match (&*self, &*other) {
                            _ => true,
                        }
                    } else {
                        false
                    }
                }
            }
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::core::fmt::Debug for TokenStandard {
            fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                match (&*self,) {
                    (&TokenStandard::NonFungible,) => {
                        ::core::fmt::Formatter::write_str(f, "NonFungible")
                    }
                    (&TokenStandard::FungibleAsset,) => {
                        ::core::fmt::Formatter::write_str(f, "FungibleAsset")
                    }
                    (&TokenStandard::Fungible,) => ::core::fmt::Formatter::write_str(f, "Fungible"),
                    (&TokenStandard::NonFungibleEdition,) => {
                        ::core::fmt::Formatter::write_str(f, "NonFungibleEdition")
                    }
                }
            }
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::core::clone::Clone for TokenStandard {
            #[inline]
            fn clone(&self) -> TokenStandard {
                match (&*self,) {
                    (&TokenStandard::NonFungible,) => TokenStandard::NonFungible,
                    (&TokenStandard::FungibleAsset,) => TokenStandard::FungibleAsset,
                    (&TokenStandard::Fungible,) => TokenStandard::Fungible,
                    (&TokenStandard::NonFungibleEdition,) => TokenStandard::NonFungibleEdition,
                }
            }
        }
        pub enum UseMethod {
            Burn,
            Multiple,
            Single,
        }
        impl borsh::ser::BorshSerialize for UseMethod {
            fn serialize<W: borsh::maybestd::io::Write>(
                &self,
                writer: &mut W,
            ) -> core::result::Result<(), borsh::maybestd::io::Error> {
                let variant_idx: u8 = match self {
                    UseMethod::Burn => 0u8,
                    UseMethod::Multiple => 1u8,
                    UseMethod::Single => 2u8,
                };
                writer.write_all(&variant_idx.to_le_bytes())?;
                match self {
                    UseMethod::Burn => {}
                    UseMethod::Multiple => {}
                    UseMethod::Single => {}
                }
                Ok(())
            }
        }
        impl borsh::de::BorshDeserialize for UseMethod {
            fn deserialize(
                buf: &mut &[u8],
            ) -> core::result::Result<Self, borsh::maybestd::io::Error> {
                let variant_idx: u8 = borsh::BorshDeserialize::deserialize(buf)?;
                let return_value = match variant_idx {
                    0u8 => UseMethod::Burn,
                    1u8 => UseMethod::Multiple,
                    2u8 => UseMethod::Single,
                    _ => {
                        let msg = {
                            let res = ::alloc::fmt::format(::core::fmt::Arguments::new_v1(
                                &["Unexpected variant index: "],
                                &[::core::fmt::ArgumentV1::new_debug(&variant_idx)],
                            ));
                            res
                        };
                        return Err(borsh::maybestd::io::Error::new(
                            borsh::maybestd::io::ErrorKind::InvalidInput,
                            msg,
                        ));
                    }
                };
                Ok(return_value)
            }
        }
        impl ::core::marker::StructuralPartialEq for UseMethod {}
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::core::cmp::PartialEq for UseMethod {
            #[inline]
            fn eq(&self, other: &UseMethod) -> bool {
                {
                    let __self_vi = ::core::intrinsics::discriminant_value(&*self);
                    let __arg_1_vi = ::core::intrinsics::discriminant_value(&*other);
                    if true && __self_vi == __arg_1_vi {
                        match (&*self, &*other) {
                            _ => true,
                        }
                    } else {
                        false
                    }
                }
            }
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::core::fmt::Debug for UseMethod {
            fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                match (&*self,) {
                    (&UseMethod::Burn,) => ::core::fmt::Formatter::write_str(f, "Burn"),
                    (&UseMethod::Multiple,) => ::core::fmt::Formatter::write_str(f, "Multiple"),
                    (&UseMethod::Single,) => ::core::fmt::Formatter::write_str(f, "Single"),
                }
            }
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::core::clone::Clone for UseMethod {
            #[inline]
            fn clone(&self) -> UseMethod {
                match (&*self,) {
                    (&UseMethod::Burn,) => UseMethod::Burn,
                    (&UseMethod::Multiple,) => UseMethod::Multiple,
                    (&UseMethod::Single,) => UseMethod::Single,
                }
            }
        }
        pub struct Uses {
            pub use_method: UseMethod,
            pub remaining: u64,
            pub total: u64,
        }
        impl borsh::ser::BorshSerialize for Uses
        where
            UseMethod: borsh::ser::BorshSerialize,
            u64: borsh::ser::BorshSerialize,
            u64: borsh::ser::BorshSerialize,
        {
            fn serialize<W: borsh::maybestd::io::Write>(
                &self,
                writer: &mut W,
            ) -> ::core::result::Result<(), borsh::maybestd::io::Error> {
                borsh::BorshSerialize::serialize(&self.use_method, writer)?;
                borsh::BorshSerialize::serialize(&self.remaining, writer)?;
                borsh::BorshSerialize::serialize(&self.total, writer)?;
                Ok(())
            }
        }
        impl borsh::de::BorshDeserialize for Uses
        where
            UseMethod: borsh::BorshDeserialize,
            u64: borsh::BorshDeserialize,
            u64: borsh::BorshDeserialize,
        {
            fn deserialize(
                buf: &mut &[u8],
            ) -> ::core::result::Result<Self, borsh::maybestd::io::Error> {
                Ok(Self {
                    use_method: borsh::BorshDeserialize::deserialize(buf)?,
                    remaining: borsh::BorshDeserialize::deserialize(buf)?,
                    total: borsh::BorshDeserialize::deserialize(buf)?,
                })
            }
        }
        impl ::core::marker::StructuralPartialEq for Uses {}
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::core::cmp::PartialEq for Uses {
            #[inline]
            fn eq(&self, other: &Uses) -> bool {
                match *other {
                    Uses {
                        use_method: ref __self_1_0,
                        remaining: ref __self_1_1,
                        total: ref __self_1_2,
                    } => match *self {
                        Uses {
                            use_method: ref __self_0_0,
                            remaining: ref __self_0_1,
                            total: ref __self_0_2,
                        } => {
                            (*__self_0_0) == (*__self_1_0)
                                && (*__self_0_1) == (*__self_1_1)
                                && (*__self_0_2) == (*__self_1_2)
                        }
                    },
                }
            }
            #[inline]
            fn ne(&self, other: &Uses) -> bool {
                match *other {
                    Uses {
                        use_method: ref __self_1_0,
                        remaining: ref __self_1_1,
                        total: ref __self_1_2,
                    } => match *self {
                        Uses {
                            use_method: ref __self_0_0,
                            remaining: ref __self_0_1,
                            total: ref __self_0_2,
                        } => {
                            (*__self_0_0) != (*__self_1_0)
                                || (*__self_0_1) != (*__self_1_1)
                                || (*__self_0_2) != (*__self_1_2)
                        }
                    },
                }
            }
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::core::fmt::Debug for Uses {
            fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                match *self {
                    Uses {
                        use_method: ref __self_0_0,
                        remaining: ref __self_0_1,
                        total: ref __self_0_2,
                    } => {
                        let debug_trait_builder =
                            &mut ::core::fmt::Formatter::debug_struct(f, "Uses");
                        let _ = ::core::fmt::DebugStruct::field(
                            debug_trait_builder,
                            "use_method",
                            &&(*__self_0_0),
                        );
                        let _ = ::core::fmt::DebugStruct::field(
                            debug_trait_builder,
                            "remaining",
                            &&(*__self_0_1),
                        );
                        let _ = ::core::fmt::DebugStruct::field(
                            debug_trait_builder,
                            "total",
                            &&(*__self_0_2),
                        );
                        ::core::fmt::DebugStruct::finish(debug_trait_builder)
                    }
                }
            }
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::core::clone::Clone for Uses {
            #[inline]
            fn clone(&self) -> Uses {
                match *self {
                    Uses {
                        use_method: ref __self_0_0,
                        remaining: ref __self_0_1,
                        total: ref __self_0_2,
                    } => Uses {
                        use_method: ::core::clone::Clone::clone(&(*__self_0_0)),
                        remaining: ::core::clone::Clone::clone(&(*__self_0_1)),
                        total: ::core::clone::Clone::clone(&(*__self_0_2)),
                    },
                }
            }
        }
        impl Uses {
            pub fn adapt(&self) -> mpl_token_metadata::state::Uses {
                mpl_token_metadata::state::Uses {
                    use_method: match self.use_method {
                        UseMethod::Burn => mpl_token_metadata::state::UseMethod::Burn,
                        UseMethod::Multiple => mpl_token_metadata::state::UseMethod::Multiple,
                        UseMethod::Single => mpl_token_metadata::state::UseMethod::Single,
                    },
                    remaining: self.remaining,
                    total: self.total,
                }
            }
        }
        #[repr(C)]
        pub struct Collection {
            pub verified: bool,
            pub key: Pubkey,
        }
        impl borsh::ser::BorshSerialize for Collection
        where
            bool: borsh::ser::BorshSerialize,
            Pubkey: borsh::ser::BorshSerialize,
        {
            fn serialize<W: borsh::maybestd::io::Write>(
                &self,
                writer: &mut W,
            ) -> ::core::result::Result<(), borsh::maybestd::io::Error> {
                borsh::BorshSerialize::serialize(&self.verified, writer)?;
                borsh::BorshSerialize::serialize(&self.key, writer)?;
                Ok(())
            }
        }
        impl borsh::de::BorshDeserialize for Collection
        where
            bool: borsh::BorshDeserialize,
            Pubkey: borsh::BorshDeserialize,
        {
            fn deserialize(
                buf: &mut &[u8],
            ) -> ::core::result::Result<Self, borsh::maybestd::io::Error> {
                Ok(Self {
                    verified: borsh::BorshDeserialize::deserialize(buf)?,
                    key: borsh::BorshDeserialize::deserialize(buf)?,
                })
            }
        }
        impl ::core::marker::StructuralPartialEq for Collection {}
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::core::cmp::PartialEq for Collection {
            #[inline]
            fn eq(&self, other: &Collection) -> bool {
                match *other {
                    Collection {
                        verified: ref __self_1_0,
                        key: ref __self_1_1,
                    } => match *self {
                        Collection {
                            verified: ref __self_0_0,
                            key: ref __self_0_1,
                        } => (*__self_0_0) == (*__self_1_0) && (*__self_0_1) == (*__self_1_1),
                    },
                }
            }
            #[inline]
            fn ne(&self, other: &Collection) -> bool {
                match *other {
                    Collection {
                        verified: ref __self_1_0,
                        key: ref __self_1_1,
                    } => match *self {
                        Collection {
                            verified: ref __self_0_0,
                            key: ref __self_0_1,
                        } => (*__self_0_0) != (*__self_1_0) || (*__self_0_1) != (*__self_1_1),
                    },
                }
            }
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::core::fmt::Debug for Collection {
            fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                match *self {
                    Collection {
                        verified: ref __self_0_0,
                        key: ref __self_0_1,
                    } => {
                        let debug_trait_builder =
                            &mut ::core::fmt::Formatter::debug_struct(f, "Collection");
                        let _ = ::core::fmt::DebugStruct::field(
                            debug_trait_builder,
                            "verified",
                            &&(*__self_0_0),
                        );
                        let _ = ::core::fmt::DebugStruct::field(
                            debug_trait_builder,
                            "key",
                            &&(*__self_0_1),
                        );
                        ::core::fmt::DebugStruct::finish(debug_trait_builder)
                    }
                }
            }
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::core::clone::Clone for Collection {
            #[inline]
            fn clone(&self) -> Collection {
                match *self {
                    Collection {
                        verified: ref __self_0_0,
                        key: ref __self_0_1,
                    } => Collection {
                        verified: ::core::clone::Clone::clone(&(*__self_0_0)),
                        key: ::core::clone::Clone::clone(&(*__self_0_1)),
                    },
                }
            }
        }
        impl Collection {
            pub fn adapt(&self) -> mpl_token_metadata::state::Collection {
                mpl_token_metadata::state::Collection {
                    verified: self.verified,
                    key: self.key,
                }
            }
        }
        pub struct MetadataArgs {
            /// The name of the asset
            pub name: String,
            /// The symbol for the asset
            pub symbol: String,
            /// URI pointing to JSON representing the asset
            pub uri: String,
            /// Royalty basis points that goes to creators in secondary sales (0-10000)
            pub seller_fee_basis_points: u16,
            pub primary_sale_happened: bool,
            pub is_mutable: bool,
            /// nonce for easy calculation of editions, if present
            pub edition_nonce: Option<u8>,
            /// Since we cannot easily change Metadata, we add the new DataV2 fields here at the end.
            pub token_standard: Option<TokenStandard>,
            /// Collection
            pub collection: Option<Collection>,
            /// Uses
            pub uses: Option<Uses>,
            pub token_program_version: TokenProgramVersion,
            pub creators: Vec<Creator>,
        }
        impl borsh::ser::BorshSerialize for MetadataArgs
        where
            String: borsh::ser::BorshSerialize,
            String: borsh::ser::BorshSerialize,
            String: borsh::ser::BorshSerialize,
            u16: borsh::ser::BorshSerialize,
            bool: borsh::ser::BorshSerialize,
            bool: borsh::ser::BorshSerialize,
            Option<u8>: borsh::ser::BorshSerialize,
            Option<TokenStandard>: borsh::ser::BorshSerialize,
            Option<Collection>: borsh::ser::BorshSerialize,
            Option<Uses>: borsh::ser::BorshSerialize,
            TokenProgramVersion: borsh::ser::BorshSerialize,
            Vec<Creator>: borsh::ser::BorshSerialize,
        {
            fn serialize<W: borsh::maybestd::io::Write>(
                &self,
                writer: &mut W,
            ) -> ::core::result::Result<(), borsh::maybestd::io::Error> {
                borsh::BorshSerialize::serialize(&self.name, writer)?;
                borsh::BorshSerialize::serialize(&self.symbol, writer)?;
                borsh::BorshSerialize::serialize(&self.uri, writer)?;
                borsh::BorshSerialize::serialize(&self.seller_fee_basis_points, writer)?;
                borsh::BorshSerialize::serialize(&self.primary_sale_happened, writer)?;
                borsh::BorshSerialize::serialize(&self.is_mutable, writer)?;
                borsh::BorshSerialize::serialize(&self.edition_nonce, writer)?;
                borsh::BorshSerialize::serialize(&self.token_standard, writer)?;
                borsh::BorshSerialize::serialize(&self.collection, writer)?;
                borsh::BorshSerialize::serialize(&self.uses, writer)?;
                borsh::BorshSerialize::serialize(&self.token_program_version, writer)?;
                borsh::BorshSerialize::serialize(&self.creators, writer)?;
                Ok(())
            }
        }
        impl borsh::de::BorshDeserialize for MetadataArgs
        where
            String: borsh::BorshDeserialize,
            String: borsh::BorshDeserialize,
            String: borsh::BorshDeserialize,
            u16: borsh::BorshDeserialize,
            bool: borsh::BorshDeserialize,
            bool: borsh::BorshDeserialize,
            Option<u8>: borsh::BorshDeserialize,
            Option<TokenStandard>: borsh::BorshDeserialize,
            Option<Collection>: borsh::BorshDeserialize,
            Option<Uses>: borsh::BorshDeserialize,
            TokenProgramVersion: borsh::BorshDeserialize,
            Vec<Creator>: borsh::BorshDeserialize,
        {
            fn deserialize(
                buf: &mut &[u8],
            ) -> ::core::result::Result<Self, borsh::maybestd::io::Error> {
                Ok(Self {
                    name: borsh::BorshDeserialize::deserialize(buf)?,
                    symbol: borsh::BorshDeserialize::deserialize(buf)?,
                    uri: borsh::BorshDeserialize::deserialize(buf)?,
                    seller_fee_basis_points: borsh::BorshDeserialize::deserialize(buf)?,
                    primary_sale_happened: borsh::BorshDeserialize::deserialize(buf)?,
                    is_mutable: borsh::BorshDeserialize::deserialize(buf)?,
                    edition_nonce: borsh::BorshDeserialize::deserialize(buf)?,
                    token_standard: borsh::BorshDeserialize::deserialize(buf)?,
                    collection: borsh::BorshDeserialize::deserialize(buf)?,
                    uses: borsh::BorshDeserialize::deserialize(buf)?,
                    token_program_version: borsh::BorshDeserialize::deserialize(buf)?,
                    creators: borsh::BorshDeserialize::deserialize(buf)?,
                })
            }
        }
        impl ::core::marker::StructuralPartialEq for MetadataArgs {}
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::core::cmp::PartialEq for MetadataArgs {
            #[inline]
            fn eq(&self, other: &MetadataArgs) -> bool {
                match *other {
                    MetadataArgs {
                        name: ref __self_1_0,
                        symbol: ref __self_1_1,
                        uri: ref __self_1_2,
                        seller_fee_basis_points: ref __self_1_3,
                        primary_sale_happened: ref __self_1_4,
                        is_mutable: ref __self_1_5,
                        edition_nonce: ref __self_1_6,
                        token_standard: ref __self_1_7,
                        collection: ref __self_1_8,
                        uses: ref __self_1_9,
                        token_program_version: ref __self_1_10,
                        creators: ref __self_1_11,
                    } => match *self {
                        MetadataArgs {
                            name: ref __self_0_0,
                            symbol: ref __self_0_1,
                            uri: ref __self_0_2,
                            seller_fee_basis_points: ref __self_0_3,
                            primary_sale_happened: ref __self_0_4,
                            is_mutable: ref __self_0_5,
                            edition_nonce: ref __self_0_6,
                            token_standard: ref __self_0_7,
                            collection: ref __self_0_8,
                            uses: ref __self_0_9,
                            token_program_version: ref __self_0_10,
                            creators: ref __self_0_11,
                        } => {
                            (*__self_0_0) == (*__self_1_0)
                                && (*__self_0_1) == (*__self_1_1)
                                && (*__self_0_2) == (*__self_1_2)
                                && (*__self_0_3) == (*__self_1_3)
                                && (*__self_0_4) == (*__self_1_4)
                                && (*__self_0_5) == (*__self_1_5)
                                && (*__self_0_6) == (*__self_1_6)
                                && (*__self_0_7) == (*__self_1_7)
                                && (*__self_0_8) == (*__self_1_8)
                                && (*__self_0_9) == (*__self_1_9)
                                && (*__self_0_10) == (*__self_1_10)
                                && (*__self_0_11) == (*__self_1_11)
                        }
                    },
                }
            }
            #[inline]
            fn ne(&self, other: &MetadataArgs) -> bool {
                match *other {
                    MetadataArgs {
                        name: ref __self_1_0,
                        symbol: ref __self_1_1,
                        uri: ref __self_1_2,
                        seller_fee_basis_points: ref __self_1_3,
                        primary_sale_happened: ref __self_1_4,
                        is_mutable: ref __self_1_5,
                        edition_nonce: ref __self_1_6,
                        token_standard: ref __self_1_7,
                        collection: ref __self_1_8,
                        uses: ref __self_1_9,
                        token_program_version: ref __self_1_10,
                        creators: ref __self_1_11,
                    } => match *self {
                        MetadataArgs {
                            name: ref __self_0_0,
                            symbol: ref __self_0_1,
                            uri: ref __self_0_2,
                            seller_fee_basis_points: ref __self_0_3,
                            primary_sale_happened: ref __self_0_4,
                            is_mutable: ref __self_0_5,
                            edition_nonce: ref __self_0_6,
                            token_standard: ref __self_0_7,
                            collection: ref __self_0_8,
                            uses: ref __self_0_9,
                            token_program_version: ref __self_0_10,
                            creators: ref __self_0_11,
                        } => {
                            (*__self_0_0) != (*__self_1_0)
                                || (*__self_0_1) != (*__self_1_1)
                                || (*__self_0_2) != (*__self_1_2)
                                || (*__self_0_3) != (*__self_1_3)
                                || (*__self_0_4) != (*__self_1_4)
                                || (*__self_0_5) != (*__self_1_5)
                                || (*__self_0_6) != (*__self_1_6)
                                || (*__self_0_7) != (*__self_1_7)
                                || (*__self_0_8) != (*__self_1_8)
                                || (*__self_0_9) != (*__self_1_9)
                                || (*__self_0_10) != (*__self_1_10)
                                || (*__self_0_11) != (*__self_1_11)
                        }
                    },
                }
            }
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::core::clone::Clone for MetadataArgs {
            #[inline]
            fn clone(&self) -> MetadataArgs {
                match *self {
                    MetadataArgs {
                        name: ref __self_0_0,
                        symbol: ref __self_0_1,
                        uri: ref __self_0_2,
                        seller_fee_basis_points: ref __self_0_3,
                        primary_sale_happened: ref __self_0_4,
                        is_mutable: ref __self_0_5,
                        edition_nonce: ref __self_0_6,
                        token_standard: ref __self_0_7,
                        collection: ref __self_0_8,
                        uses: ref __self_0_9,
                        token_program_version: ref __self_0_10,
                        creators: ref __self_0_11,
                    } => MetadataArgs {
                        name: ::core::clone::Clone::clone(&(*__self_0_0)),
                        symbol: ::core::clone::Clone::clone(&(*__self_0_1)),
                        uri: ::core::clone::Clone::clone(&(*__self_0_2)),
                        seller_fee_basis_points: ::core::clone::Clone::clone(&(*__self_0_3)),
                        primary_sale_happened: ::core::clone::Clone::clone(&(*__self_0_4)),
                        is_mutable: ::core::clone::Clone::clone(&(*__self_0_5)),
                        edition_nonce: ::core::clone::Clone::clone(&(*__self_0_6)),
                        token_standard: ::core::clone::Clone::clone(&(*__self_0_7)),
                        collection: ::core::clone::Clone::clone(&(*__self_0_8)),
                        uses: ::core::clone::Clone::clone(&(*__self_0_9)),
                        token_program_version: ::core::clone::Clone::clone(&(*__self_0_10)),
                        creators: ::core::clone::Clone::clone(&(*__self_0_11)),
                    },
                }
            }
        }
    }
    pub mod metaplex_anchor {
        use anchor_lang::prelude::*;
        use anchor_lang::solana_program::pubkey::Pubkey;
        use mpl_token_metadata::{
            state::{MAX_MASTER_EDITION_LEN, MAX_METADATA_LEN},
            utils::try_from_slice_checked,
        };
        use std::ops::Deref;
        pub struct MasterEdition(mpl_token_metadata::state::MasterEditionV2);
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::core::clone::Clone for MasterEdition {
            #[inline]
            fn clone(&self) -> MasterEdition {
                match *self {
                    MasterEdition(ref __self_0_0) => {
                        MasterEdition(::core::clone::Clone::clone(&(*__self_0_0)))
                    }
                }
            }
        }
        impl borsh::de::BorshDeserialize for MasterEdition {
            fn deserialize(
                buf: &mut &[u8],
            ) -> ::core::result::Result<Self, borsh::maybestd::io::Error> {
                Ok(Self(borsh::BorshDeserialize::deserialize(buf)?))
            }
        }
        impl borsh::ser::BorshSerialize for MasterEdition {
            fn serialize<W: borsh::maybestd::io::Write>(
                &self,
                writer: &mut W,
            ) -> ::core::result::Result<(), borsh::maybestd::io::Error> {
                borsh::BorshSerialize::serialize(&self.0, writer)?;
                Ok(())
            }
        }
        impl anchor_lang::AccountDeserialize for MasterEdition {
            fn try_deserialize_unchecked(buf: &mut &[u8]) -> Result<Self> {
                try_from_slice_checked(
                    buf,
                    mpl_token_metadata::state::Key::MasterEditionV2,
                    MAX_MASTER_EDITION_LEN,
                )
                .map_err(Into::into)
            }
        }
        impl anchor_lang::AccountSerialize for MasterEdition {}
        impl anchor_lang::Owner for MasterEdition {
            fn owner() -> Pubkey {
                mpl_token_metadata::id()
            }
        }
        impl Deref for MasterEdition {
            type Target = mpl_token_metadata::state::MasterEditionV2;
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        pub struct TokenMetadata(mpl_token_metadata::state::Metadata);
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::core::clone::Clone for TokenMetadata {
            #[inline]
            fn clone(&self) -> TokenMetadata {
                match *self {
                    TokenMetadata(ref __self_0_0) => {
                        TokenMetadata(::core::clone::Clone::clone(&(*__self_0_0)))
                    }
                }
            }
        }
        impl borsh::de::BorshDeserialize for TokenMetadata {
            fn deserialize(
                buf: &mut &[u8],
            ) -> ::core::result::Result<Self, borsh::maybestd::io::Error> {
                Ok(Self(borsh::BorshDeserialize::deserialize(buf)?))
            }
        }
        impl borsh::ser::BorshSerialize for TokenMetadata {
            fn serialize<W: borsh::maybestd::io::Write>(
                &self,
                writer: &mut W,
            ) -> ::core::result::Result<(), borsh::maybestd::io::Error> {
                borsh::BorshSerialize::serialize(&self.0, writer)?;
                Ok(())
            }
        }
        impl anchor_lang::AccountDeserialize for TokenMetadata {
            fn try_deserialize_unchecked(buf: &mut &[u8]) -> Result<Self> {
                try_from_slice_checked(
                    buf,
                    mpl_token_metadata::state::Key::MetadataV1,
                    MAX_METADATA_LEN,
                )
                .map_err(Into::into)
            }
        }
        impl anchor_lang::AccountSerialize for TokenMetadata {}
        impl anchor_lang::Owner for TokenMetadata {
            fn owner() -> Pubkey {
                mpl_token_metadata::id()
            }
        }
        impl Deref for TokenMetadata {
            type Target = mpl_token_metadata::state::Metadata;
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        pub struct MplTokenMetadata;
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::core::clone::Clone for MplTokenMetadata {
            #[inline]
            fn clone(&self) -> MplTokenMetadata {
                match *self {
                    MplTokenMetadata => MplTokenMetadata,
                }
            }
        }
        impl anchor_lang::Id for MplTokenMetadata {
            fn id() -> Pubkey {
                mpl_token_metadata::id()
            }
        }
    }
    pub mod request {
        use crate::error::BubblegumError;
        use anchor_lang::prelude::*;
        pub const MINT_REQUEST_SIZE: usize = 48 + 8;
        pub struct MintRequest {
            pub mint_authority: Pubkey,
            pub num_mints_requested: u64,
            pub num_mints_approved: u64,
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::core::marker::Copy for MintRequest {}
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::core::fmt::Debug for MintRequest {
            fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                match *self {
                    MintRequest {
                        mint_authority: ref __self_0_0,
                        num_mints_requested: ref __self_0_1,
                        num_mints_approved: ref __self_0_2,
                    } => {
                        let debug_trait_builder =
                            &mut ::core::fmt::Formatter::debug_struct(f, "MintRequest");
                        let _ = ::core::fmt::DebugStruct::field(
                            debug_trait_builder,
                            "mint_authority",
                            &&(*__self_0_0),
                        );
                        let _ = ::core::fmt::DebugStruct::field(
                            debug_trait_builder,
                            "num_mints_requested",
                            &&(*__self_0_1),
                        );
                        let _ = ::core::fmt::DebugStruct::field(
                            debug_trait_builder,
                            "num_mints_approved",
                            &&(*__self_0_2),
                        );
                        ::core::fmt::DebugStruct::finish(debug_trait_builder)
                    }
                }
            }
        }
        impl borsh::ser::BorshSerialize for MintRequest
        where
            Pubkey: borsh::ser::BorshSerialize,
            u64: borsh::ser::BorshSerialize,
            u64: borsh::ser::BorshSerialize,
        {
            fn serialize<W: borsh::maybestd::io::Write>(
                &self,
                writer: &mut W,
            ) -> ::core::result::Result<(), borsh::maybestd::io::Error> {
                borsh::BorshSerialize::serialize(&self.mint_authority, writer)?;
                borsh::BorshSerialize::serialize(&self.num_mints_requested, writer)?;
                borsh::BorshSerialize::serialize(&self.num_mints_approved, writer)?;
                Ok(())
            }
        }
        impl borsh::de::BorshDeserialize for MintRequest
        where
            Pubkey: borsh::BorshDeserialize,
            u64: borsh::BorshDeserialize,
            u64: borsh::BorshDeserialize,
        {
            fn deserialize(
                buf: &mut &[u8],
            ) -> ::core::result::Result<Self, borsh::maybestd::io::Error> {
                Ok(Self {
                    mint_authority: borsh::BorshDeserialize::deserialize(buf)?,
                    num_mints_requested: borsh::BorshDeserialize::deserialize(buf)?,
                    num_mints_approved: borsh::BorshDeserialize::deserialize(buf)?,
                })
            }
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::core::clone::Clone for MintRequest {
            #[inline]
            fn clone(&self) -> MintRequest {
                match *self {
                    MintRequest {
                        mint_authority: ref __self_0_0,
                        num_mints_requested: ref __self_0_1,
                        num_mints_approved: ref __self_0_2,
                    } => MintRequest {
                        mint_authority: ::core::clone::Clone::clone(&(*__self_0_0)),
                        num_mints_requested: ::core::clone::Clone::clone(&(*__self_0_1)),
                        num_mints_approved: ::core::clone::Clone::clone(&(*__self_0_2)),
                    },
                }
            }
        }
        #[automatically_derived]
        impl anchor_lang::AccountSerialize for MintRequest {
            fn try_serialize<W: std::io::Write>(&self, writer: &mut W) -> anchor_lang::Result<()> {
                if writer
                    .write_all(&[60, 88, 16, 213, 180, 138, 14, 225])
                    .is_err()
                {
                    return Err(anchor_lang::error::ErrorCode::AccountDidNotSerialize.into());
                }
                if AnchorSerialize::serialize(self, writer).is_err() {
                    return Err(anchor_lang::error::ErrorCode::AccountDidNotSerialize.into());
                }
                Ok(())
            }
        }
        #[automatically_derived]
        impl anchor_lang::AccountDeserialize for MintRequest {
            fn try_deserialize(buf: &mut &[u8]) -> anchor_lang::Result<Self> {
                if buf.len() < [60, 88, 16, 213, 180, 138, 14, 225].len() {
                    return Err(anchor_lang::error::ErrorCode::AccountDiscriminatorNotFound.into());
                }
                let given_disc = &buf[..8];
                if &[60, 88, 16, 213, 180, 138, 14, 225] != given_disc {
                    return Err(
                        anchor_lang::error::Error::from(anchor_lang::error::AnchorError {
                            error_name: anchor_lang::error::ErrorCode::AccountDiscriminatorMismatch
                                .name(),
                            error_code_number:
                                anchor_lang::error::ErrorCode::AccountDiscriminatorMismatch.into(),
                            error_msg: anchor_lang::error::ErrorCode::AccountDiscriminatorMismatch
                                .to_string(),
                            error_origin: Some(anchor_lang::error::ErrorOrigin::Source(
                                anchor_lang::error::Source {
                                    filename: "src/state/request.rs",
                                    line: 6u32,
                                },
                            )),
                            compared_values: None,
                        })
                        .with_account_name("MintRequest"),
                    );
                }
                Self::try_deserialize_unchecked(buf)
            }
            fn try_deserialize_unchecked(buf: &mut &[u8]) -> anchor_lang::Result<Self> {
                let mut data: &[u8] = &buf[8..];
                AnchorDeserialize::deserialize(&mut data)
                    .map_err(|_| anchor_lang::error::ErrorCode::AccountDidNotDeserialize.into())
            }
        }
        #[automatically_derived]
        impl anchor_lang::Discriminator for MintRequest {
            fn discriminator() -> [u8; 8] {
                [60, 88, 16, 213, 180, 138, 14, 225]
            }
        }
        #[automatically_derived]
        impl anchor_lang::Owner for MintRequest {
            fn owner() -> Pubkey {
                crate::ID
            }
        }
        impl MintRequest {
            pub fn init(&mut self, mint_authority: &Pubkey, mint_capacity: u64) {
                self.mint_authority = *mint_authority;
                self.num_mints_requested = mint_capacity;
                self.num_mints_approved = 0;
            }
            pub fn decrement_approvals(&mut self) -> Result<()> {
                if self.num_mints_approved == 0 {
                    return Err(BubblegumError::MintRequestNotApproved.into());
                }
                self.num_mints_approved -= 1;
                Ok(())
            }
            pub fn is_initialized(&self) -> bool {
                self.mint_authority != Pubkey::default()
            }
            pub fn init_or_set(&mut self, auth: Pubkey, mint_capacity: u64) {
                if self.is_initialized() {
                    self.num_mints_requested = mint_capacity;
                } else {
                    self.init(&auth, mint_capacity);
                }
            }
            pub fn approve(&mut self, num_to_approve: u64) -> Result<()> {
                if num_to_approve > self.num_mints_requested {
                    ::solana_program::log::sol_log(
                        "Cannot approve more mints than the requested amount",
                    );
                    return Err(BubblegumError::MintRequestNotApproved.into());
                }
                self.num_mints_requested = self.num_mints_requested.saturating_sub(num_to_approve);
                self.num_mints_approved = self.num_mints_approved.saturating_add(num_to_approve);
                Ok(())
            }
            pub fn process_mint(&mut self) -> Result<()> {
                if self.num_mints_approved > 0 {
                    return Err(BubblegumError::MintRequestNotApproved.into());
                }
                self.num_mints_approved = self.num_mints_approved.saturating_sub(1);
                Ok(())
            }
            pub fn has_mint_capacity(&self, capacity: u64) -> bool {
                self.num_mints_approved >= capacity
            }
        }
    }
    use anchor_lang::prelude::*;
    use leaf_schema::LeafSchema;
    use leaf_schema::Version;
    use metaplex_adapter::MetadataArgs;
    pub const TREE_AUTHORITY_SIZE: usize = 88 + 8;
    pub const VOUCHER_SIZE: usize = 8 + 1 + 32 + 32 + 32 + 8 + 32 + 32 + 4 + 32;
    pub const VOUCHER_PREFIX: &str = "voucher";
    pub const ASSET_PREFIX: &str = "asset";
    pub struct TreeConfig {
        pub creator: Pubkey,
        pub delegate: Pubkey,
        pub total_mint_capacity: u64,
        pub num_mints_approved: u64,
        pub num_minted: u64,
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::marker::Copy for TreeConfig {}
    impl borsh::ser::BorshSerialize for TreeConfig
    where
        Pubkey: borsh::ser::BorshSerialize,
        Pubkey: borsh::ser::BorshSerialize,
        u64: borsh::ser::BorshSerialize,
        u64: borsh::ser::BorshSerialize,
        u64: borsh::ser::BorshSerialize,
    {
        fn serialize<W: borsh::maybestd::io::Write>(
            &self,
            writer: &mut W,
        ) -> ::core::result::Result<(), borsh::maybestd::io::Error> {
            borsh::BorshSerialize::serialize(&self.creator, writer)?;
            borsh::BorshSerialize::serialize(&self.delegate, writer)?;
            borsh::BorshSerialize::serialize(&self.total_mint_capacity, writer)?;
            borsh::BorshSerialize::serialize(&self.num_mints_approved, writer)?;
            borsh::BorshSerialize::serialize(&self.num_minted, writer)?;
            Ok(())
        }
    }
    impl borsh::de::BorshDeserialize for TreeConfig
    where
        Pubkey: borsh::BorshDeserialize,
        Pubkey: borsh::BorshDeserialize,
        u64: borsh::BorshDeserialize,
        u64: borsh::BorshDeserialize,
        u64: borsh::BorshDeserialize,
    {
        fn deserialize(
            buf: &mut &[u8],
        ) -> ::core::result::Result<Self, borsh::maybestd::io::Error> {
            Ok(Self {
                creator: borsh::BorshDeserialize::deserialize(buf)?,
                delegate: borsh::BorshDeserialize::deserialize(buf)?,
                total_mint_capacity: borsh::BorshDeserialize::deserialize(buf)?,
                num_mints_approved: borsh::BorshDeserialize::deserialize(buf)?,
                num_minted: borsh::BorshDeserialize::deserialize(buf)?,
            })
        }
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::clone::Clone for TreeConfig {
        #[inline]
        fn clone(&self) -> TreeConfig {
            match *self {
                TreeConfig {
                    creator: ref __self_0_0,
                    delegate: ref __self_0_1,
                    total_mint_capacity: ref __self_0_2,
                    num_mints_approved: ref __self_0_3,
                    num_minted: ref __self_0_4,
                } => TreeConfig {
                    creator: ::core::clone::Clone::clone(&(*__self_0_0)),
                    delegate: ::core::clone::Clone::clone(&(*__self_0_1)),
                    total_mint_capacity: ::core::clone::Clone::clone(&(*__self_0_2)),
                    num_mints_approved: ::core::clone::Clone::clone(&(*__self_0_3)),
                    num_minted: ::core::clone::Clone::clone(&(*__self_0_4)),
                },
            }
        }
    }
    #[automatically_derived]
    impl anchor_lang::AccountSerialize for TreeConfig {
        fn try_serialize<W: std::io::Write>(&self, writer: &mut W) -> anchor_lang::Result<()> {
            if writer
                .write_all(&[122, 245, 175, 248, 171, 34, 0, 207])
                .is_err()
            {
                return Err(anchor_lang::error::ErrorCode::AccountDidNotSerialize.into());
            }
            if AnchorSerialize::serialize(self, writer).is_err() {
                return Err(anchor_lang::error::ErrorCode::AccountDidNotSerialize.into());
            }
            Ok(())
        }
    }
    #[automatically_derived]
    impl anchor_lang::AccountDeserialize for TreeConfig {
        fn try_deserialize(buf: &mut &[u8]) -> anchor_lang::Result<Self> {
            if buf.len() < [122, 245, 175, 248, 171, 34, 0, 207].len() {
                return Err(anchor_lang::error::ErrorCode::AccountDiscriminatorNotFound.into());
            }
            let given_disc = &buf[..8];
            if &[122, 245, 175, 248, 171, 34, 0, 207] != given_disc {
                return Err(
                    anchor_lang::error::Error::from(anchor_lang::error::AnchorError {
                        error_name: anchor_lang::error::ErrorCode::AccountDiscriminatorMismatch
                            .name(),
                        error_code_number:
                            anchor_lang::error::ErrorCode::AccountDiscriminatorMismatch.into(),
                        error_msg: anchor_lang::error::ErrorCode::AccountDiscriminatorMismatch
                            .to_string(),
                        error_origin: Some(anchor_lang::error::ErrorOrigin::Source(
                            anchor_lang::error::Source {
                                filename: "src/state/mod.rs",
                                line: 15u32,
                            },
                        )),
                        compared_values: None,
                    })
                    .with_account_name("TreeConfig"),
                );
            }
            Self::try_deserialize_unchecked(buf)
        }
        fn try_deserialize_unchecked(buf: &mut &[u8]) -> anchor_lang::Result<Self> {
            let mut data: &[u8] = &buf[8..];
            AnchorDeserialize::deserialize(&mut data)
                .map_err(|_| anchor_lang::error::ErrorCode::AccountDidNotDeserialize.into())
        }
    }
    #[automatically_derived]
    impl anchor_lang::Discriminator for TreeConfig {
        fn discriminator() -> [u8; 8] {
            [122, 245, 175, 248, 171, 34, 0, 207]
        }
    }
    #[automatically_derived]
    impl anchor_lang::Owner for TreeConfig {
        fn owner() -> Pubkey {
            crate::ID
        }
    }
    impl TreeConfig {
        pub fn increment_mint_count(&mut self) {
            self.num_minted = self.num_minted.saturating_add(1);
        }
        pub fn approve_mint_capacity(&mut self, capacity: u64) {
            self.num_mints_approved = self.num_mints_approved.saturating_add(capacity);
        }
        pub fn contains_mint_capacity(&self, requested_capacity: u64) -> bool {
            let remaining_mints = self.total_mint_capacity.saturating_sub(self.num_minted);
            let remaining_mints_to_approve =
                remaining_mints.saturating_sub(self.num_mints_approved);
            requested_capacity <= remaining_mints_to_approve
        }
        pub fn restore_mint_capacity(&mut self, capacity: u64) {
            self.num_mints_approved = self.num_mints_approved.saturating_sub(capacity);
        }
    }
    pub struct Voucher {
        pub leaf_schema: LeafSchema,
        pub index: u32,
        pub merkle_slab: Pubkey,
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::marker::Copy for Voucher {}
    impl borsh::ser::BorshSerialize for Voucher
    where
        LeafSchema: borsh::ser::BorshSerialize,
        u32: borsh::ser::BorshSerialize,
        Pubkey: borsh::ser::BorshSerialize,
    {
        fn serialize<W: borsh::maybestd::io::Write>(
            &self,
            writer: &mut W,
        ) -> ::core::result::Result<(), borsh::maybestd::io::Error> {
            borsh::BorshSerialize::serialize(&self.leaf_schema, writer)?;
            borsh::BorshSerialize::serialize(&self.index, writer)?;
            borsh::BorshSerialize::serialize(&self.merkle_slab, writer)?;
            Ok(())
        }
    }
    impl borsh::de::BorshDeserialize for Voucher
    where
        LeafSchema: borsh::BorshDeserialize,
        u32: borsh::BorshDeserialize,
        Pubkey: borsh::BorshDeserialize,
    {
        fn deserialize(
            buf: &mut &[u8],
        ) -> ::core::result::Result<Self, borsh::maybestd::io::Error> {
            Ok(Self {
                leaf_schema: borsh::BorshDeserialize::deserialize(buf)?,
                index: borsh::BorshDeserialize::deserialize(buf)?,
                merkle_slab: borsh::BorshDeserialize::deserialize(buf)?,
            })
        }
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::clone::Clone for Voucher {
        #[inline]
        fn clone(&self) -> Voucher {
            match *self {
                Voucher {
                    leaf_schema: ref __self_0_0,
                    index: ref __self_0_1,
                    merkle_slab: ref __self_0_2,
                } => Voucher {
                    leaf_schema: ::core::clone::Clone::clone(&(*__self_0_0)),
                    index: ::core::clone::Clone::clone(&(*__self_0_1)),
                    merkle_slab: ::core::clone::Clone::clone(&(*__self_0_2)),
                },
            }
        }
    }
    #[automatically_derived]
    impl anchor_lang::AccountSerialize for Voucher {
        fn try_serialize<W: std::io::Write>(&self, writer: &mut W) -> anchor_lang::Result<()> {
            if writer
                .write_all(&[191, 204, 149, 234, 213, 165, 13, 65])
                .is_err()
            {
                return Err(anchor_lang::error::ErrorCode::AccountDidNotSerialize.into());
            }
            if AnchorSerialize::serialize(self, writer).is_err() {
                return Err(anchor_lang::error::ErrorCode::AccountDidNotSerialize.into());
            }
            Ok(())
        }
    }
    #[automatically_derived]
    impl anchor_lang::AccountDeserialize for Voucher {
        fn try_deserialize(buf: &mut &[u8]) -> anchor_lang::Result<Self> {
            if buf.len() < [191, 204, 149, 234, 213, 165, 13, 65].len() {
                return Err(anchor_lang::error::ErrorCode::AccountDiscriminatorNotFound.into());
            }
            let given_disc = &buf[..8];
            if &[191, 204, 149, 234, 213, 165, 13, 65] != given_disc {
                return Err(
                    anchor_lang::error::Error::from(anchor_lang::error::AnchorError {
                        error_name: anchor_lang::error::ErrorCode::AccountDiscriminatorMismatch
                            .name(),
                        error_code_number:
                            anchor_lang::error::ErrorCode::AccountDiscriminatorMismatch.into(),
                        error_msg: anchor_lang::error::ErrorCode::AccountDiscriminatorMismatch
                            .to_string(),
                        error_origin: Some(anchor_lang::error::ErrorOrigin::Source(
                            anchor_lang::error::Source {
                                filename: "src/state/mod.rs",
                                line: 45u32,
                            },
                        )),
                        compared_values: None,
                    })
                    .with_account_name("Voucher"),
                );
            }
            Self::try_deserialize_unchecked(buf)
        }
        fn try_deserialize_unchecked(buf: &mut &[u8]) -> anchor_lang::Result<Self> {
            let mut data: &[u8] = &buf[8..];
            AnchorDeserialize::deserialize(&mut data)
                .map_err(|_| anchor_lang::error::ErrorCode::AccountDidNotDeserialize.into())
        }
    }
    #[automatically_derived]
    impl anchor_lang::Discriminator for Voucher {
        fn discriminator() -> [u8; 8] {
            [191, 204, 149, 234, 213, 165, 13, 65]
        }
    }
    #[automatically_derived]
    impl anchor_lang::Owner for Voucher {
        fn owner() -> Pubkey {
            crate::ID
        }
    }
    impl Voucher {
        pub fn new(leaf_schema: LeafSchema, index: u32, merkle_slab: Pubkey) -> Self {
            Self {
                leaf_schema,
                index,
                merkle_slab,
            }
        }
    }
    pub struct NewNFTEvent {
        pub version: Version,
        pub metadata: MetadataArgs,
        pub nonce: u64,
    }
    impl borsh::ser::BorshSerialize for NewNFTEvent
    where
        Version: borsh::ser::BorshSerialize,
        MetadataArgs: borsh::ser::BorshSerialize,
        u64: borsh::ser::BorshSerialize,
    {
        fn serialize<W: borsh::maybestd::io::Write>(
            &self,
            writer: &mut W,
        ) -> ::core::result::Result<(), borsh::maybestd::io::Error> {
            borsh::BorshSerialize::serialize(&self.version, writer)?;
            borsh::BorshSerialize::serialize(&self.metadata, writer)?;
            borsh::BorshSerialize::serialize(&self.nonce, writer)?;
            Ok(())
        }
    }
    impl borsh::de::BorshDeserialize for NewNFTEvent
    where
        Version: borsh::BorshDeserialize,
        MetadataArgs: borsh::BorshDeserialize,
        u64: borsh::BorshDeserialize,
    {
        fn deserialize(
            buf: &mut &[u8],
        ) -> ::core::result::Result<Self, borsh::maybestd::io::Error> {
            Ok(Self {
                version: borsh::BorshDeserialize::deserialize(buf)?,
                metadata: borsh::BorshDeserialize::deserialize(buf)?,
                nonce: borsh::BorshDeserialize::deserialize(buf)?,
            })
        }
    }
    impl anchor_lang::Event for NewNFTEvent {
        fn data(&self) -> Vec<u8> {
            let mut d = [196, 35, 157, 194, 143, 50, 170, 171].to_vec();
            d.append(&mut self.try_to_vec().unwrap());
            d
        }
    }
    impl anchor_lang::Discriminator for NewNFTEvent {
        fn discriminator() -> [u8; 8] {
            [196, 35, 157, 194, 143, 50, 170, 171]
        }
    }
    pub struct NFTDecompressionEvent {
        pub version: Version,
        pub id: Pubkey,
        pub tree_id: Pubkey,
        pub nonce: u64,
    }
    impl borsh::ser::BorshSerialize for NFTDecompressionEvent
    where
        Version: borsh::ser::BorshSerialize,
        Pubkey: borsh::ser::BorshSerialize,
        Pubkey: borsh::ser::BorshSerialize,
        u64: borsh::ser::BorshSerialize,
    {
        fn serialize<W: borsh::maybestd::io::Write>(
            &self,
            writer: &mut W,
        ) -> ::core::result::Result<(), borsh::maybestd::io::Error> {
            borsh::BorshSerialize::serialize(&self.version, writer)?;
            borsh::BorshSerialize::serialize(&self.id, writer)?;
            borsh::BorshSerialize::serialize(&self.tree_id, writer)?;
            borsh::BorshSerialize::serialize(&self.nonce, writer)?;
            Ok(())
        }
    }
    impl borsh::de::BorshDeserialize for NFTDecompressionEvent
    where
        Version: borsh::BorshDeserialize,
        Pubkey: borsh::BorshDeserialize,
        Pubkey: borsh::BorshDeserialize,
        u64: borsh::BorshDeserialize,
    {
        fn deserialize(
            buf: &mut &[u8],
        ) -> ::core::result::Result<Self, borsh::maybestd::io::Error> {
            Ok(Self {
                version: borsh::BorshDeserialize::deserialize(buf)?,
                id: borsh::BorshDeserialize::deserialize(buf)?,
                tree_id: borsh::BorshDeserialize::deserialize(buf)?,
                nonce: borsh::BorshDeserialize::deserialize(buf)?,
            })
        }
    }
    impl anchor_lang::Event for NFTDecompressionEvent {
        fn data(&self) -> Vec<u8> {
            let mut d = [255, 254, 123, 106, 237, 80, 198, 107].to_vec();
            d.append(&mut self.try_to_vec().unwrap());
            d
        }
    }
    impl anchor_lang::Discriminator for NFTDecompressionEvent {
        fn discriminator() -> [u8; 8] {
            [255, 254, 123, 106, 237, 80, 198, 107]
        }
    }
}
pub mod utils {
    use {
        crate::error::BubblegumError,
        crate::state::metaplex_adapter::MetadataArgs,
        crate::ASSET_PREFIX,
        anchor_lang::{
            prelude::*, solana_program::program_memory::sol_memcmp,
            solana_program::pubkey::PUBKEY_BYTES,
        },
        spl_compression::Node,
    };
    /// Assert that the provided MetadataArgs are compatible with MPL `Data`
    pub fn assert_metadata_is_mpl_compatible(metadata: &MetadataArgs) -> Result<()> {
        if metadata.name.len() > mpl_token_metadata::state::MAX_NAME_LENGTH {
            return Err(BubblegumError::MetadataNameTooLong.into());
        }
        if metadata.symbol.len() > mpl_token_metadata::state::MAX_SYMBOL_LENGTH {
            return Err(BubblegumError::MetadataSymbolTooLong.into());
        }
        if metadata.uri.len() > mpl_token_metadata::state::MAX_URI_LENGTH {
            return Err(BubblegumError::MetadataUriTooLong.into());
        }
        if metadata.seller_fee_basis_points > 10000 {
            return Err(BubblegumError::MetadataBasisPointsTooHigh.into());
        }
        if metadata.creators.len() > 0 {
            if metadata.creators.len() > mpl_token_metadata::state::MAX_CREATOR_LIMIT - 1 {
                return Err(BubblegumError::CreatorsTooLong.into());
            }
            let mut total: u8 = 0;
            for i in 0..metadata.creators.len() {
                let creator = metadata.creators[i];
                for iter in metadata.creators.iter().skip(i + 1) {
                    if iter.address == creator.address {
                        return Err(BubblegumError::DuplicateCreatorAddress.into());
                    }
                }
                total = total
                    .checked_add(creator.share)
                    .ok_or(BubblegumError::CreatorShareTotalMustBe100)?;
            }
            if total != 100 {
                return Err(BubblegumError::CreatorShareTotalMustBe100.into());
            }
        }
        Ok(())
    }
    pub fn replace_leaf<'info>(
        seed: &Pubkey,
        bump: u8,
        gummyroll_program: &AccountInfo<'info>,
        authority: &AccountInfo<'info>,
        merkle_roll: &AccountInfo<'info>,
        candy_wrapper: &AccountInfo<'info>,
        remaining_accounts: &[AccountInfo<'info>],
        root_node: Node,
        previous_leaf: Node,
        new_leaf: Node,
        index: u32,
    ) -> Result<()> {
        let seeds = &[seed.as_ref(), &[bump]];
        let authority_pda_signer = &[&seeds[..]];
        let cpi_ctx = CpiContext::new_with_signer(
            gummyroll_program.clone(),
            spl_compression::cpi::accounts::Modify {
                authority: authority.clone(),
                merkle_tree: merkle_roll.clone(),
                log_wrapper: candy_wrapper.clone(),
            },
            authority_pda_signer,
        )
        .with_remaining_accounts(remaining_accounts.to_vec());
        spl_compression::cpi::replace_leaf(cpi_ctx, root_node, previous_leaf, new_leaf, index)
    }
    pub fn append_leaf<'info>(
        seed: &Pubkey,
        bump: u8,
        gummyroll_program: &AccountInfo<'info>,
        authority: &AccountInfo<'info>,
        merkle_roll: &AccountInfo<'info>,
        candy_wrapper: &AccountInfo<'info>,
        leaf_node: Node,
    ) -> Result<()> {
        let seeds = &[seed.as_ref(), &[bump]];
        let authority_pda_signer = &[&seeds[..]];
        let cpi_ctx = CpiContext::new_with_signer(
            gummyroll_program.clone(),
            spl_compression::cpi::accounts::Modify {
                authority: authority.clone(),
                merkle_tree: merkle_roll.clone(),
                log_wrapper: candy_wrapper.clone(),
            },
            authority_pda_signer,
        );
        spl_compression::cpi::append(cpi_ctx, leaf_node)
    }
    pub fn cmp_pubkeys(a: &Pubkey, b: &Pubkey) -> bool {
        sol_memcmp(a.as_ref(), b.as_ref(), PUBKEY_BYTES) == 0
    }
    pub fn cmp_bytes(a: &[u8], b: &[u8], size: usize) -> bool {
        sol_memcmp(a.as_ref(), b.as_ref(), size) == 0
    }
    pub fn assert_pubkey_equal(
        a: &Pubkey,
        b: &Pubkey,
        error: Option<anchor_lang::error::Error>,
    ) -> Result<()> {
        if !cmp_pubkeys(a, b) {
            if error.is_some() {
                let err = error.unwrap();
                return Err(err);
            }
            return Err(BubblegumError::PublicKeyMismatch.into());
        } else {
            Ok(())
        }
    }
    pub fn assert_derivation(
        program_id: &Pubkey,
        account: &AccountInfo,
        path: &[&[u8]],
        error: Option<error::Error>,
    ) -> Result<u8> {
        let (key, bump) = Pubkey::find_program_address(&path, program_id);
        if !cmp_pubkeys(&key, account.key) {
            if error.is_some() {
                let err = error.unwrap();
                ::solana_program::log::sol_log(&{
                    let res = ::alloc::fmt::format(::core::fmt::Arguments::new_v1(
                        &["Derivation "],
                        &[::core::fmt::ArgumentV1::new_debug(&err)],
                    ));
                    res
                });
                return Err(err.into());
            }
            ::solana_program::log::sol_log("DerivedKeyInvalid");
            return Err(ProgramError::InvalidInstructionData.into());
        }
        Ok(bump)
    }
    pub fn assert_owned_by(account: &AccountInfo, owner: &Pubkey) -> Result<()> {
        if !cmp_pubkeys(account.owner, owner) {
            Err(ProgramError::IllegalOwner.into())
        } else {
            Ok(())
        }
    }
    pub fn get_asset_id(tree_id: &Pubkey, nonce: u64) -> Pubkey {
        Pubkey::find_program_address(
            &[
                ASSET_PREFIX.as_ref(),
                tree_id.as_ref(),
                &nonce.to_le_bytes(),
            ],
            &crate::id(),
        )
        .0
    }
}
/// The static program ID
pub static ID: anchor_lang::solana_program::pubkey::Pubkey =
    anchor_lang::solana_program::pubkey::Pubkey::new_from_array([
        152u8, 139u8, 128u8, 235u8, 121u8, 53u8, 40u8, 105u8, 178u8, 36u8, 116u8, 95u8, 89u8,
        221u8, 191u8, 138u8, 38u8, 88u8, 202u8, 19u8, 220u8, 104u8, 129u8, 33u8, 38u8, 53u8, 28u8,
        174u8, 7u8, 193u8, 165u8, 165u8,
    ]);
/// Confirms that a given pubkey is equivalent to the program ID
pub fn check_id(id: &anchor_lang::solana_program::pubkey::Pubkey) -> bool {
    id == &ID
}
/// Returns the program ID
pub fn id() -> anchor_lang::solana_program::pubkey::Pubkey {
    ID
}
pub struct SplCompression;
#[automatically_derived]
#[allow(unused_qualifications)]
impl ::core::clone::Clone for SplCompression {
    #[inline]
    fn clone(&self) -> SplCompression {
        match *self {
            SplCompression => SplCompression,
        }
    }
}
impl Id for SplCompression {
    fn id() -> Pubkey {
        spl_compression::id()
    }
}
pub struct CreateTree<'info> {
    # [account (init , seeds = [merkle_slab . key () . as_ref ()] , payer = payer , space = TREE_AUTHORITY_SIZE , bump ,)]
    pub authority: Account<'info, TreeConfig>,
    #[account(mut)]
    pub payer: Signer<'info>,
    pub tree_creator: Signer<'info>,
    pub candy_wrapper: Program<'info, Wrapper>,
    pub system_program: Program<'info, System>,
    pub gummyroll_program: Program<'info, SplCompression>,
    #[account(zero)]
    /// CHECK: This account must be all zeros
    pub merkle_slab: UncheckedAccount<'info>,
}
#[automatically_derived]
impl<'info> anchor_lang::Accounts<'info> for CreateTree<'info>
where
    'info: 'info,
{
    #[inline(never)]
    fn try_accounts(
        program_id: &anchor_lang::solana_program::pubkey::Pubkey,
        accounts: &mut &[anchor_lang::solana_program::account_info::AccountInfo<'info>],
        ix_data: &[u8],
        __bumps: &mut std::collections::BTreeMap<String, u8>,
        __reallocs: &mut std::collections::BTreeSet<anchor_lang::solana_program::pubkey::Pubkey>,
    ) -> anchor_lang::Result<Self> {
        if accounts.is_empty() {
            return Err(anchor_lang::error::ErrorCode::AccountNotEnoughKeys.into());
        }
        let authority = &accounts[0];
        *accounts = &accounts[1..];
        let payer: Signer =
            anchor_lang::Accounts::try_accounts(program_id, accounts, ix_data, __bumps, __reallocs)
                .map_err(|e| e.with_account_name("payer"))?;
        let tree_creator: Signer =
            anchor_lang::Accounts::try_accounts(program_id, accounts, ix_data, __bumps, __reallocs)
                .map_err(|e| e.with_account_name("tree_creator"))?;
        let candy_wrapper: anchor_lang::accounts::program::Program<Wrapper> =
            anchor_lang::Accounts::try_accounts(program_id, accounts, ix_data, __bumps, __reallocs)
                .map_err(|e| e.with_account_name("candy_wrapper"))?;
        let system_program: anchor_lang::accounts::program::Program<System> =
            anchor_lang::Accounts::try_accounts(program_id, accounts, ix_data, __bumps, __reallocs)
                .map_err(|e| e.with_account_name("system_program"))?;
        let gummyroll_program: anchor_lang::accounts::program::Program<SplCompression> =
            anchor_lang::Accounts::try_accounts(program_id, accounts, ix_data, __bumps, __reallocs)
                .map_err(|e| e.with_account_name("gummyroll_program"))?;
        if accounts.is_empty() {
            return Err(anchor_lang::error::ErrorCode::AccountNotEnoughKeys.into());
        }
        let merkle_slab = &accounts[0];
        *accounts = &accounts[1..];
        let __anchor_rent = Rent::get()?;
        let (__pda_address, __bump) =
            Pubkey::find_program_address(&[merkle_slab.key().as_ref()], program_id);
        __bumps.insert("authority".to_string(), __bump);
        let authority = {
            let actual_field = authority.to_account_info();
            let actual_owner = actual_field.owner;
            let space = TREE_AUTHORITY_SIZE;
            let pa: anchor_lang::accounts::account::Account<TreeConfig> =
                if !false || actual_owner == &anchor_lang::solana_program::system_program::ID {
                    let payer = payer.to_account_info();
                    let __current_lamports = authority.lamports();
                    if __current_lamports == 0 {
                        let lamports = __anchor_rent.minimum_balance(space);
                        let cpi_accounts = anchor_lang::system_program::CreateAccount {
                            from: payer.to_account_info(),
                            to: authority.to_account_info(),
                        };
                        let cpi_context = anchor_lang::context::CpiContext::new(
                            system_program.to_account_info(),
                            cpi_accounts,
                        );
                        anchor_lang::system_program::create_account(
                            cpi_context
                                .with_signer(&[&[merkle_slab.key().as_ref(), &[__bump][..]][..]]),
                            lamports,
                            space as u64,
                            program_id,
                        )?;
                    } else {
                        let required_lamports = __anchor_rent
                            .minimum_balance(space)
                            .max(1)
                            .saturating_sub(__current_lamports);
                        if required_lamports > 0 {
                            let cpi_accounts = anchor_lang::system_program::Transfer {
                                from: payer.to_account_info(),
                                to: authority.to_account_info(),
                            };
                            let cpi_context = anchor_lang::context::CpiContext::new(
                                system_program.to_account_info(),
                                cpi_accounts,
                            );
                            anchor_lang::system_program::transfer(cpi_context, required_lamports)?;
                        }
                        let cpi_accounts = anchor_lang::system_program::Allocate {
                            account_to_allocate: authority.to_account_info(),
                        };
                        let cpi_context = anchor_lang::context::CpiContext::new(
                            system_program.to_account_info(),
                            cpi_accounts,
                        );
                        anchor_lang::system_program::allocate(
                            cpi_context
                                .with_signer(&[&[merkle_slab.key().as_ref(), &[__bump][..]][..]]),
                            space as u64,
                        )?;
                        let cpi_accounts = anchor_lang::system_program::Assign {
                            account_to_assign: authority.to_account_info(),
                        };
                        let cpi_context = anchor_lang::context::CpiContext::new(
                            system_program.to_account_info(),
                            cpi_accounts,
                        );
                        anchor_lang::system_program::assign(
                            cpi_context
                                .with_signer(&[&[merkle_slab.key().as_ref(), &[__bump][..]][..]]),
                            program_id,
                        )?;
                    }
                    anchor_lang::accounts::account::Account::try_from_unchecked(&authority)
                        .map_err(|e| e.with_account_name("authority"))?
                } else {
                    anchor_lang::accounts::account::Account::try_from(&authority)
                        .map_err(|e| e.with_account_name("authority"))?
                };
            if false {
                if space != actual_field.data_len() {
                    return Err(anchor_lang::error::Error::from(
                        anchor_lang::error::ErrorCode::ConstraintSpace,
                    )
                    .with_account_name("authority")
                    .with_values((space, actual_field.data_len())));
                }
                if actual_owner != program_id {
                    return Err(anchor_lang::error::Error::from(
                        anchor_lang::error::ErrorCode::ConstraintOwner,
                    )
                    .with_account_name("authority")
                    .with_pubkeys((*actual_owner, *program_id)));
                }
                {
                    let required_lamports = __anchor_rent.minimum_balance(space);
                    if pa.to_account_info().lamports() < required_lamports {
                        return Err(anchor_lang::error::Error::from(
                            anchor_lang::error::ErrorCode::ConstraintRentExempt,
                        )
                        .with_account_name("authority"));
                    }
                }
            }
            pa
        };
        if authority.key() != __pda_address {
            return Err(anchor_lang::error::Error::from(
                anchor_lang::error::ErrorCode::ConstraintSeeds,
            )
            .with_account_name("authority")
            .with_pubkeys((authority.key(), __pda_address)));
        }
        if !authority.to_account_info().is_writable {
            return Err(anchor_lang::error::Error::from(
                anchor_lang::error::ErrorCode::ConstraintMut,
            )
            .with_account_name("authority"));
        }
        if !__anchor_rent.is_exempt(
            authority.to_account_info().lamports(),
            authority.to_account_info().try_data_len()?,
        ) {
            return Err(anchor_lang::error::Error::from(
                anchor_lang::error::ErrorCode::ConstraintRentExempt,
            )
            .with_account_name("authority"));
        }
        if !payer.to_account_info().is_writable {
            return Err(anchor_lang::error::Error::from(
                anchor_lang::error::ErrorCode::ConstraintMut,
            )
            .with_account_name("payer"));
        }
        let __anchor_rent = Rent::get()?;
        let merkle_slab: UncheckedAccount = {
            let mut __data: &[u8] = &merkle_slab.try_borrow_data()?;
            let mut __disc_bytes = [0u8; 8];
            __disc_bytes.copy_from_slice(&__data[..8]);
            let __discriminator = u64::from_le_bytes(__disc_bytes);
            if __discriminator != 0 {
                return Err(anchor_lang::error::Error::from(
                    anchor_lang::error::ErrorCode::ConstraintZero,
                )
                .with_account_name("merkle_slab"));
            }
            UncheckedAccount::try_from(merkle_slab.to_account_info())
        };
        if !merkle_slab.to_account_info().is_writable {
            return Err(anchor_lang::error::Error::from(
                anchor_lang::error::ErrorCode::ConstraintMut,
            )
            .with_account_name("merkle_slab"));
        }
        if !__anchor_rent.is_exempt(
            merkle_slab.to_account_info().lamports(),
            merkle_slab.to_account_info().try_data_len()?,
        ) {
            return Err(anchor_lang::error::Error::from(
                anchor_lang::error::ErrorCode::ConstraintRentExempt,
            )
            .with_account_name("merkle_slab"));
        }
        Ok(CreateTree {
            authority,
            payer,
            tree_creator,
            candy_wrapper,
            system_program,
            gummyroll_program,
            merkle_slab,
        })
    }
}
#[automatically_derived]
impl<'info> anchor_lang::ToAccountInfos<'info> for CreateTree<'info>
where
    'info: 'info,
{
    fn to_account_infos(
        &self,
    ) -> Vec<anchor_lang::solana_program::account_info::AccountInfo<'info>> {
        let mut account_infos = ::alloc::vec::Vec::new();
        account_infos.extend(self.authority.to_account_infos());
        account_infos.extend(self.payer.to_account_infos());
        account_infos.extend(self.tree_creator.to_account_infos());
        account_infos.extend(self.candy_wrapper.to_account_infos());
        account_infos.extend(self.system_program.to_account_infos());
        account_infos.extend(self.gummyroll_program.to_account_infos());
        account_infos.extend(self.merkle_slab.to_account_infos());
        account_infos
    }
}
#[automatically_derived]
impl<'info> anchor_lang::ToAccountMetas for CreateTree<'info> {
    fn to_account_metas(
        &self,
        is_signer: Option<bool>,
    ) -> Vec<anchor_lang::solana_program::instruction::AccountMeta> {
        let mut account_metas = ::alloc::vec::Vec::new();
        account_metas.extend(self.authority.to_account_metas(None));
        account_metas.extend(self.payer.to_account_metas(None));
        account_metas.extend(self.tree_creator.to_account_metas(None));
        account_metas.extend(self.candy_wrapper.to_account_metas(None));
        account_metas.extend(self.system_program.to_account_metas(None));
        account_metas.extend(self.gummyroll_program.to_account_metas(None));
        account_metas.extend(self.merkle_slab.to_account_metas(None));
        account_metas
    }
}
#[automatically_derived]
impl<'info> anchor_lang::AccountsExit<'info> for CreateTree<'info>
where
    'info: 'info,
{
    fn exit(
        &self,
        program_id: &anchor_lang::solana_program::pubkey::Pubkey,
    ) -> anchor_lang::Result<()> {
        anchor_lang::AccountsExit::exit(&self.authority, program_id)
            .map_err(|e| e.with_account_name("authority"))?;
        anchor_lang::AccountsExit::exit(&self.payer, program_id)
            .map_err(|e| e.with_account_name("payer"))?;
        anchor_lang::AccountsExit::exit(&self.merkle_slab, program_id)
            .map_err(|e| e.with_account_name("merkle_slab"))?;
        Ok(())
    }
}
/// An internal, Anchor generated module. This is used (as an
/// implementation detail), to generate a struct for a given
/// `#[derive(Accounts)]` implementation, where each field is a Pubkey,
/// instead of an `AccountInfo`. This is useful for clients that want
/// to generate a list of accounts, without explicitly knowing the
/// order all the fields should be in.
///
/// To access the struct in this module, one should use the sibling
/// `accounts` module (also generated), which re-exports this.
pub(crate) mod __client_accounts_create_tree {
    use super::*;
    use anchor_lang::prelude::borsh;
    /// Generated client accounts for [`CreateTree`].
    pub struct CreateTree {
        pub authority: anchor_lang::solana_program::pubkey::Pubkey,
        pub payer: anchor_lang::solana_program::pubkey::Pubkey,
        pub tree_creator: anchor_lang::solana_program::pubkey::Pubkey,
        pub candy_wrapper: anchor_lang::solana_program::pubkey::Pubkey,
        pub system_program: anchor_lang::solana_program::pubkey::Pubkey,
        pub gummyroll_program: anchor_lang::solana_program::pubkey::Pubkey,
        pub merkle_slab: anchor_lang::solana_program::pubkey::Pubkey,
    }
    impl borsh::ser::BorshSerialize for CreateTree
    where
        anchor_lang::solana_program::pubkey::Pubkey: borsh::ser::BorshSerialize,
        anchor_lang::solana_program::pubkey::Pubkey: borsh::ser::BorshSerialize,
        anchor_lang::solana_program::pubkey::Pubkey: borsh::ser::BorshSerialize,
        anchor_lang::solana_program::pubkey::Pubkey: borsh::ser::BorshSerialize,
        anchor_lang::solana_program::pubkey::Pubkey: borsh::ser::BorshSerialize,
        anchor_lang::solana_program::pubkey::Pubkey: borsh::ser::BorshSerialize,
        anchor_lang::solana_program::pubkey::Pubkey: borsh::ser::BorshSerialize,
    {
        fn serialize<W: borsh::maybestd::io::Write>(
            &self,
            writer: &mut W,
        ) -> ::core::result::Result<(), borsh::maybestd::io::Error> {
            borsh::BorshSerialize::serialize(&self.authority, writer)?;
            borsh::BorshSerialize::serialize(&self.payer, writer)?;
            borsh::BorshSerialize::serialize(&self.tree_creator, writer)?;
            borsh::BorshSerialize::serialize(&self.candy_wrapper, writer)?;
            borsh::BorshSerialize::serialize(&self.system_program, writer)?;
            borsh::BorshSerialize::serialize(&self.gummyroll_program, writer)?;
            borsh::BorshSerialize::serialize(&self.merkle_slab, writer)?;
            Ok(())
        }
    }
    #[automatically_derived]
    impl anchor_lang::ToAccountMetas for CreateTree {
        fn to_account_metas(
            &self,
            is_signer: Option<bool>,
        ) -> Vec<anchor_lang::solana_program::instruction::AccountMeta> {
            let mut account_metas = ::alloc::vec::Vec::new();
            account_metas.push(anchor_lang::solana_program::instruction::AccountMeta::new(
                self.authority,
                false,
            ));
            account_metas.push(anchor_lang::solana_program::instruction::AccountMeta::new(
                self.payer, true,
            ));
            account_metas.push(
                anchor_lang::solana_program::instruction::AccountMeta::new_readonly(
                    self.tree_creator,
                    true,
                ),
            );
            account_metas.push(
                anchor_lang::solana_program::instruction::AccountMeta::new_readonly(
                    self.candy_wrapper,
                    false,
                ),
            );
            account_metas.push(
                anchor_lang::solana_program::instruction::AccountMeta::new_readonly(
                    self.system_program,
                    false,
                ),
            );
            account_metas.push(
                anchor_lang::solana_program::instruction::AccountMeta::new_readonly(
                    self.gummyroll_program,
                    false,
                ),
            );
            account_metas.push(anchor_lang::solana_program::instruction::AccountMeta::new(
                self.merkle_slab,
                false,
            ));
            account_metas
        }
    }
}
/// An internal, Anchor generated module. This is used (as an
/// implementation detail), to generate a CPI struct for a given
/// `#[derive(Accounts)]` implementation, where each field is an
/// AccountInfo.
///
/// To access the struct in this module, one should use the sibling
/// [`cpi::accounts`] module (also generated), which re-exports this.
pub(crate) mod __cpi_client_accounts_create_tree {
    use super::*;
    /// Generated CPI struct of the accounts for [`CreateTree`].
    pub struct CreateTree<'info> {
        pub authority: anchor_lang::solana_program::account_info::AccountInfo<'info>,
        pub payer: anchor_lang::solana_program::account_info::AccountInfo<'info>,
        pub tree_creator: anchor_lang::solana_program::account_info::AccountInfo<'info>,
        pub candy_wrapper: anchor_lang::solana_program::account_info::AccountInfo<'info>,
        pub system_program: anchor_lang::solana_program::account_info::AccountInfo<'info>,
        pub gummyroll_program: anchor_lang::solana_program::account_info::AccountInfo<'info>,
        pub merkle_slab: anchor_lang::solana_program::account_info::AccountInfo<'info>,
    }
    #[automatically_derived]
    impl<'info> anchor_lang::ToAccountMetas for CreateTree<'info> {
        fn to_account_metas(
            &self,
            is_signer: Option<bool>,
        ) -> Vec<anchor_lang::solana_program::instruction::AccountMeta> {
            let mut account_metas = ::alloc::vec::Vec::new();
            account_metas.push(anchor_lang::solana_program::instruction::AccountMeta::new(
                anchor_lang::Key::key(&self.authority),
                false,
            ));
            account_metas.push(anchor_lang::solana_program::instruction::AccountMeta::new(
                anchor_lang::Key::key(&self.payer),
                true,
            ));
            account_metas.push(
                anchor_lang::solana_program::instruction::AccountMeta::new_readonly(
                    anchor_lang::Key::key(&self.tree_creator),
                    true,
                ),
            );
            account_metas.push(
                anchor_lang::solana_program::instruction::AccountMeta::new_readonly(
                    anchor_lang::Key::key(&self.candy_wrapper),
                    false,
                ),
            );
            account_metas.push(
                anchor_lang::solana_program::instruction::AccountMeta::new_readonly(
                    anchor_lang::Key::key(&self.system_program),
                    false,
                ),
            );
            account_metas.push(
                anchor_lang::solana_program::instruction::AccountMeta::new_readonly(
                    anchor_lang::Key::key(&self.gummyroll_program),
                    false,
                ),
            );
            account_metas.push(anchor_lang::solana_program::instruction::AccountMeta::new(
                anchor_lang::Key::key(&self.merkle_slab),
                false,
            ));
            account_metas
        }
    }
    #[automatically_derived]
    impl<'info> anchor_lang::ToAccountInfos<'info> for CreateTree<'info> {
        fn to_account_infos(
            &self,
        ) -> Vec<anchor_lang::solana_program::account_info::AccountInfo<'info>> {
            let mut account_infos = ::alloc::vec::Vec::new();
            account_infos.push(anchor_lang::ToAccountInfo::to_account_info(&self.authority));
            account_infos.push(anchor_lang::ToAccountInfo::to_account_info(&self.payer));
            account_infos.push(anchor_lang::ToAccountInfo::to_account_info(
                &self.tree_creator,
            ));
            account_infos.push(anchor_lang::ToAccountInfo::to_account_info(
                &self.candy_wrapper,
            ));
            account_infos.push(anchor_lang::ToAccountInfo::to_account_info(
                &self.system_program,
            ));
            account_infos.push(anchor_lang::ToAccountInfo::to_account_info(
                &self.gummyroll_program,
            ));
            account_infos.push(anchor_lang::ToAccountInfo::to_account_info(
                &self.merkle_slab,
            ));
            account_infos
        }
    }
}
pub struct MintV1<'info> {
    /// CHECK: This is checked in the instruction. Must be signer if it is not equal to the `authority`
    pub mint_authority: AccountInfo<'info>,
    # [account (mut , seeds = [merkle_slab . key () . as_ref ()] , bump ,)]
    pub authority: Account<'info, TreeConfig>,
    pub candy_wrapper: Program<'info, Wrapper>,
    pub gummyroll_program: Program<'info, SplCompression>,
    /// CHECK: This account is neither written to nor read from.
    pub owner: AccountInfo<'info>,
    /// CHECK: This account is neither written to nor read from.
    pub delegate: AccountInfo<'info>,
    # [account (mut , seeds = [merkle_slab . key () . as_ref () , mint_authority . key () . as_ref ()] , bump ,)]
    pub mint_authority_request: Account<'info, MintRequest>,
    #[account(mut)]
    /// CHECK: unsafe
    pub merkle_slab: UncheckedAccount<'info>,
}
#[automatically_derived]
impl<'info> anchor_lang::Accounts<'info> for MintV1<'info>
where
    'info: 'info,
{
    #[inline(never)]
    fn try_accounts(
        program_id: &anchor_lang::solana_program::pubkey::Pubkey,
        accounts: &mut &[anchor_lang::solana_program::account_info::AccountInfo<'info>],
        ix_data: &[u8],
        __bumps: &mut std::collections::BTreeMap<String, u8>,
        __reallocs: &mut std::collections::BTreeSet<anchor_lang::solana_program::pubkey::Pubkey>,
    ) -> anchor_lang::Result<Self> {
        let mint_authority: AccountInfo =
            anchor_lang::Accounts::try_accounts(program_id, accounts, ix_data, __bumps, __reallocs)
                .map_err(|e| e.with_account_name("mint_authority"))?;
        let authority: anchor_lang::accounts::account::Account<TreeConfig> =
            anchor_lang::Accounts::try_accounts(program_id, accounts, ix_data, __bumps, __reallocs)
                .map_err(|e| e.with_account_name("authority"))?;
        let candy_wrapper: anchor_lang::accounts::program::Program<Wrapper> =
            anchor_lang::Accounts::try_accounts(program_id, accounts, ix_data, __bumps, __reallocs)
                .map_err(|e| e.with_account_name("candy_wrapper"))?;
        let gummyroll_program: anchor_lang::accounts::program::Program<SplCompression> =
            anchor_lang::Accounts::try_accounts(program_id, accounts, ix_data, __bumps, __reallocs)
                .map_err(|e| e.with_account_name("gummyroll_program"))?;
        let owner: AccountInfo =
            anchor_lang::Accounts::try_accounts(program_id, accounts, ix_data, __bumps, __reallocs)
                .map_err(|e| e.with_account_name("owner"))?;
        let delegate: AccountInfo =
            anchor_lang::Accounts::try_accounts(program_id, accounts, ix_data, __bumps, __reallocs)
                .map_err(|e| e.with_account_name("delegate"))?;
        let mint_authority_request: anchor_lang::accounts::account::Account<MintRequest> =
            anchor_lang::Accounts::try_accounts(program_id, accounts, ix_data, __bumps, __reallocs)
                .map_err(|e| e.with_account_name("mint_authority_request"))?;
        let merkle_slab: UncheckedAccount =
            anchor_lang::Accounts::try_accounts(program_id, accounts, ix_data, __bumps, __reallocs)
                .map_err(|e| e.with_account_name("merkle_slab"))?;
        let (__pda_address, __bump) =
            Pubkey::find_program_address(&[merkle_slab.key().as_ref()], &program_id);
        __bumps.insert("authority".to_string(), __bump);
        if authority.key() != __pda_address {
            return Err(anchor_lang::error::Error::from(
                anchor_lang::error::ErrorCode::ConstraintSeeds,
            )
            .with_account_name("authority")
            .with_pubkeys((authority.key(), __pda_address)));
        }
        if !authority.to_account_info().is_writable {
            return Err(anchor_lang::error::Error::from(
                anchor_lang::error::ErrorCode::ConstraintMut,
            )
            .with_account_name("authority"));
        }
        let (__pda_address, __bump) = Pubkey::find_program_address(
            &[merkle_slab.key().as_ref(), mint_authority.key().as_ref()],
            &program_id,
        );
        __bumps.insert("mint_authority_request".to_string(), __bump);
        if mint_authority_request.key() != __pda_address {
            return Err(anchor_lang::error::Error::from(
                anchor_lang::error::ErrorCode::ConstraintSeeds,
            )
            .with_account_name("mint_authority_request")
            .with_pubkeys((mint_authority_request.key(), __pda_address)));
        }
        if !mint_authority_request.to_account_info().is_writable {
            return Err(anchor_lang::error::Error::from(
                anchor_lang::error::ErrorCode::ConstraintMut,
            )
            .with_account_name("mint_authority_request"));
        }
        if !merkle_slab.to_account_info().is_writable {
            return Err(anchor_lang::error::Error::from(
                anchor_lang::error::ErrorCode::ConstraintMut,
            )
            .with_account_name("merkle_slab"));
        }
        Ok(MintV1 {
            mint_authority,
            authority,
            candy_wrapper,
            gummyroll_program,
            owner,
            delegate,
            mint_authority_request,
            merkle_slab,
        })
    }
}
#[automatically_derived]
impl<'info> anchor_lang::ToAccountInfos<'info> for MintV1<'info>
where
    'info: 'info,
{
    fn to_account_infos(
        &self,
    ) -> Vec<anchor_lang::solana_program::account_info::AccountInfo<'info>> {
        let mut account_infos = ::alloc::vec::Vec::new();
        account_infos.extend(self.mint_authority.to_account_infos());
        account_infos.extend(self.authority.to_account_infos());
        account_infos.extend(self.candy_wrapper.to_account_infos());
        account_infos.extend(self.gummyroll_program.to_account_infos());
        account_infos.extend(self.owner.to_account_infos());
        account_infos.extend(self.delegate.to_account_infos());
        account_infos.extend(self.mint_authority_request.to_account_infos());
        account_infos.extend(self.merkle_slab.to_account_infos());
        account_infos
    }
}
#[automatically_derived]
impl<'info> anchor_lang::ToAccountMetas for MintV1<'info> {
    fn to_account_metas(
        &self,
        is_signer: Option<bool>,
    ) -> Vec<anchor_lang::solana_program::instruction::AccountMeta> {
        let mut account_metas = ::alloc::vec::Vec::new();
        account_metas.extend(self.mint_authority.to_account_metas(None));
        account_metas.extend(self.authority.to_account_metas(None));
        account_metas.extend(self.candy_wrapper.to_account_metas(None));
        account_metas.extend(self.gummyroll_program.to_account_metas(None));
        account_metas.extend(self.owner.to_account_metas(None));
        account_metas.extend(self.delegate.to_account_metas(None));
        account_metas.extend(self.mint_authority_request.to_account_metas(None));
        account_metas.extend(self.merkle_slab.to_account_metas(None));
        account_metas
    }
}
#[automatically_derived]
impl<'info> anchor_lang::AccountsExit<'info> for MintV1<'info>
where
    'info: 'info,
{
    fn exit(
        &self,
        program_id: &anchor_lang::solana_program::pubkey::Pubkey,
    ) -> anchor_lang::Result<()> {
        anchor_lang::AccountsExit::exit(&self.authority, program_id)
            .map_err(|e| e.with_account_name("authority"))?;
        anchor_lang::AccountsExit::exit(&self.mint_authority_request, program_id)
            .map_err(|e| e.with_account_name("mint_authority_request"))?;
        anchor_lang::AccountsExit::exit(&self.merkle_slab, program_id)
            .map_err(|e| e.with_account_name("merkle_slab"))?;
        Ok(())
    }
}
/// An internal, Anchor generated module. This is used (as an
/// implementation detail), to generate a struct for a given
/// `#[derive(Accounts)]` implementation, where each field is a Pubkey,
/// instead of an `AccountInfo`. This is useful for clients that want
/// to generate a list of accounts, without explicitly knowing the
/// order all the fields should be in.
///
/// To access the struct in this module, one should use the sibling
/// `accounts` module (also generated), which re-exports this.
pub(crate) mod __client_accounts_mint_v1 {
    use super::*;
    use anchor_lang::prelude::borsh;
    /// Generated client accounts for [`MintV1`].
    pub struct MintV1 {
        pub mint_authority: anchor_lang::solana_program::pubkey::Pubkey,
        pub authority: anchor_lang::solana_program::pubkey::Pubkey,
        pub candy_wrapper: anchor_lang::solana_program::pubkey::Pubkey,
        pub gummyroll_program: anchor_lang::solana_program::pubkey::Pubkey,
        pub owner: anchor_lang::solana_program::pubkey::Pubkey,
        pub delegate: anchor_lang::solana_program::pubkey::Pubkey,
        pub mint_authority_request: anchor_lang::solana_program::pubkey::Pubkey,
        pub merkle_slab: anchor_lang::solana_program::pubkey::Pubkey,
    }
    impl borsh::ser::BorshSerialize for MintV1
    where
        anchor_lang::solana_program::pubkey::Pubkey: borsh::ser::BorshSerialize,
        anchor_lang::solana_program::pubkey::Pubkey: borsh::ser::BorshSerialize,
        anchor_lang::solana_program::pubkey::Pubkey: borsh::ser::BorshSerialize,
        anchor_lang::solana_program::pubkey::Pubkey: borsh::ser::BorshSerialize,
        anchor_lang::solana_program::pubkey::Pubkey: borsh::ser::BorshSerialize,
        anchor_lang::solana_program::pubkey::Pubkey: borsh::ser::BorshSerialize,
        anchor_lang::solana_program::pubkey::Pubkey: borsh::ser::BorshSerialize,
        anchor_lang::solana_program::pubkey::Pubkey: borsh::ser::BorshSerialize,
    {
        fn serialize<W: borsh::maybestd::io::Write>(
            &self,
            writer: &mut W,
        ) -> ::core::result::Result<(), borsh::maybestd::io::Error> {
            borsh::BorshSerialize::serialize(&self.mint_authority, writer)?;
            borsh::BorshSerialize::serialize(&self.authority, writer)?;
            borsh::BorshSerialize::serialize(&self.candy_wrapper, writer)?;
            borsh::BorshSerialize::serialize(&self.gummyroll_program, writer)?;
            borsh::BorshSerialize::serialize(&self.owner, writer)?;
            borsh::BorshSerialize::serialize(&self.delegate, writer)?;
            borsh::BorshSerialize::serialize(&self.mint_authority_request, writer)?;
            borsh::BorshSerialize::serialize(&self.merkle_slab, writer)?;
            Ok(())
        }
    }
    #[automatically_derived]
    impl anchor_lang::ToAccountMetas for MintV1 {
        fn to_account_metas(
            &self,
            is_signer: Option<bool>,
        ) -> Vec<anchor_lang::solana_program::instruction::AccountMeta> {
            let mut account_metas = ::alloc::vec::Vec::new();
            account_metas.push(
                anchor_lang::solana_program::instruction::AccountMeta::new_readonly(
                    self.mint_authority,
                    false,
                ),
            );
            account_metas.push(anchor_lang::solana_program::instruction::AccountMeta::new(
                self.authority,
                false,
            ));
            account_metas.push(
                anchor_lang::solana_program::instruction::AccountMeta::new_readonly(
                    self.candy_wrapper,
                    false,
                ),
            );
            account_metas.push(
                anchor_lang::solana_program::instruction::AccountMeta::new_readonly(
                    self.gummyroll_program,
                    false,
                ),
            );
            account_metas.push(
                anchor_lang::solana_program::instruction::AccountMeta::new_readonly(
                    self.owner, false,
                ),
            );
            account_metas.push(
                anchor_lang::solana_program::instruction::AccountMeta::new_readonly(
                    self.delegate,
                    false,
                ),
            );
            account_metas.push(anchor_lang::solana_program::instruction::AccountMeta::new(
                self.mint_authority_request,
                false,
            ));
            account_metas.push(anchor_lang::solana_program::instruction::AccountMeta::new(
                self.merkle_slab,
                false,
            ));
            account_metas
        }
    }
}
/// An internal, Anchor generated module. This is used (as an
/// implementation detail), to generate a CPI struct for a given
/// `#[derive(Accounts)]` implementation, where each field is an
/// AccountInfo.
///
/// To access the struct in this module, one should use the sibling
/// [`cpi::accounts`] module (also generated), which re-exports this.
pub(crate) mod __cpi_client_accounts_mint_v1 {
    use super::*;
    /// Generated CPI struct of the accounts for [`MintV1`].
    pub struct MintV1<'info> {
        pub mint_authority: anchor_lang::solana_program::account_info::AccountInfo<'info>,
        pub authority: anchor_lang::solana_program::account_info::AccountInfo<'info>,
        pub candy_wrapper: anchor_lang::solana_program::account_info::AccountInfo<'info>,
        pub gummyroll_program: anchor_lang::solana_program::account_info::AccountInfo<'info>,
        pub owner: anchor_lang::solana_program::account_info::AccountInfo<'info>,
        pub delegate: anchor_lang::solana_program::account_info::AccountInfo<'info>,
        pub mint_authority_request: anchor_lang::solana_program::account_info::AccountInfo<'info>,
        pub merkle_slab: anchor_lang::solana_program::account_info::AccountInfo<'info>,
    }
    #[automatically_derived]
    impl<'info> anchor_lang::ToAccountMetas for MintV1<'info> {
        fn to_account_metas(
            &self,
            is_signer: Option<bool>,
        ) -> Vec<anchor_lang::solana_program::instruction::AccountMeta> {
            let mut account_metas = ::alloc::vec::Vec::new();
            account_metas.push(
                anchor_lang::solana_program::instruction::AccountMeta::new_readonly(
                    anchor_lang::Key::key(&self.mint_authority),
                    false,
                ),
            );
            account_metas.push(anchor_lang::solana_program::instruction::AccountMeta::new(
                anchor_lang::Key::key(&self.authority),
                false,
            ));
            account_metas.push(
                anchor_lang::solana_program::instruction::AccountMeta::new_readonly(
                    anchor_lang::Key::key(&self.candy_wrapper),
                    false,
                ),
            );
            account_metas.push(
                anchor_lang::solana_program::instruction::AccountMeta::new_readonly(
                    anchor_lang::Key::key(&self.gummyroll_program),
                    false,
                ),
            );
            account_metas.push(
                anchor_lang::solana_program::instruction::AccountMeta::new_readonly(
                    anchor_lang::Key::key(&self.owner),
                    false,
                ),
            );
            account_metas.push(
                anchor_lang::solana_program::instruction::AccountMeta::new_readonly(
                    anchor_lang::Key::key(&self.delegate),
                    false,
                ),
            );
            account_metas.push(anchor_lang::solana_program::instruction::AccountMeta::new(
                anchor_lang::Key::key(&self.mint_authority_request),
                false,
            ));
            account_metas.push(anchor_lang::solana_program::instruction::AccountMeta::new(
                anchor_lang::Key::key(&self.merkle_slab),
                false,
            ));
            account_metas
        }
    }
    #[automatically_derived]
    impl<'info> anchor_lang::ToAccountInfos<'info> for MintV1<'info> {
        fn to_account_infos(
            &self,
        ) -> Vec<anchor_lang::solana_program::account_info::AccountInfo<'info>> {
            let mut account_infos = ::alloc::vec::Vec::new();
            account_infos.push(anchor_lang::ToAccountInfo::to_account_info(
                &self.mint_authority,
            ));
            account_infos.push(anchor_lang::ToAccountInfo::to_account_info(&self.authority));
            account_infos.push(anchor_lang::ToAccountInfo::to_account_info(
                &self.candy_wrapper,
            ));
            account_infos.push(anchor_lang::ToAccountInfo::to_account_info(
                &self.gummyroll_program,
            ));
            account_infos.push(anchor_lang::ToAccountInfo::to_account_info(&self.owner));
            account_infos.push(anchor_lang::ToAccountInfo::to_account_info(&self.delegate));
            account_infos.push(anchor_lang::ToAccountInfo::to_account_info(
                &self.mint_authority_request,
            ));
            account_infos.push(anchor_lang::ToAccountInfo::to_account_info(
                &self.merkle_slab,
            ));
            account_infos
        }
    }
}
pub struct Burn<'info> {
    # [account (seeds = [merkle_slab . key () . as_ref ()] , bump ,)]
    pub authority: Account<'info, TreeConfig>,
    pub candy_wrapper: Program<'info, Wrapper>,
    pub gummyroll_program: Program<'info, SplCompression>,
    /// CHECK: This account is checked in the instruction
    pub owner: UncheckedAccount<'info>,
    /// CHECK: This account is checked in the instruction
    pub delegate: UncheckedAccount<'info>,
    #[account(mut)]
    /// CHECK: This account is modified in the downstream program
    pub merkle_slab: UncheckedAccount<'info>,
}
#[automatically_derived]
impl<'info> anchor_lang::Accounts<'info> for Burn<'info>
where
    'info: 'info,
{
    #[inline(never)]
    fn try_accounts(
        program_id: &anchor_lang::solana_program::pubkey::Pubkey,
        accounts: &mut &[anchor_lang::solana_program::account_info::AccountInfo<'info>],
        ix_data: &[u8],
        __bumps: &mut std::collections::BTreeMap<String, u8>,
        __reallocs: &mut std::collections::BTreeSet<anchor_lang::solana_program::pubkey::Pubkey>,
    ) -> anchor_lang::Result<Self> {
        let authority: anchor_lang::accounts::account::Account<TreeConfig> =
            anchor_lang::Accounts::try_accounts(program_id, accounts, ix_data, __bumps, __reallocs)
                .map_err(|e| e.with_account_name("authority"))?;
        let candy_wrapper: anchor_lang::accounts::program::Program<Wrapper> =
            anchor_lang::Accounts::try_accounts(program_id, accounts, ix_data, __bumps, __reallocs)
                .map_err(|e| e.with_account_name("candy_wrapper"))?;
        let gummyroll_program: anchor_lang::accounts::program::Program<SplCompression> =
            anchor_lang::Accounts::try_accounts(program_id, accounts, ix_data, __bumps, __reallocs)
                .map_err(|e| e.with_account_name("gummyroll_program"))?;
        let owner: UncheckedAccount =
            anchor_lang::Accounts::try_accounts(program_id, accounts, ix_data, __bumps, __reallocs)
                .map_err(|e| e.with_account_name("owner"))?;
        let delegate: UncheckedAccount =
            anchor_lang::Accounts::try_accounts(program_id, accounts, ix_data, __bumps, __reallocs)
                .map_err(|e| e.with_account_name("delegate"))?;
        let merkle_slab: UncheckedAccount =
            anchor_lang::Accounts::try_accounts(program_id, accounts, ix_data, __bumps, __reallocs)
                .map_err(|e| e.with_account_name("merkle_slab"))?;
        let (__pda_address, __bump) =
            Pubkey::find_program_address(&[merkle_slab.key().as_ref()], &program_id);
        __bumps.insert("authority".to_string(), __bump);
        if authority.key() != __pda_address {
            return Err(anchor_lang::error::Error::from(
                anchor_lang::error::ErrorCode::ConstraintSeeds,
            )
            .with_account_name("authority")
            .with_pubkeys((authority.key(), __pda_address)));
        }
        if !merkle_slab.to_account_info().is_writable {
            return Err(anchor_lang::error::Error::from(
                anchor_lang::error::ErrorCode::ConstraintMut,
            )
            .with_account_name("merkle_slab"));
        }
        Ok(Burn {
            authority,
            candy_wrapper,
            gummyroll_program,
            owner,
            delegate,
            merkle_slab,
        })
    }
}
#[automatically_derived]
impl<'info> anchor_lang::ToAccountInfos<'info> for Burn<'info>
where
    'info: 'info,
{
    fn to_account_infos(
        &self,
    ) -> Vec<anchor_lang::solana_program::account_info::AccountInfo<'info>> {
        let mut account_infos = ::alloc::vec::Vec::new();
        account_infos.extend(self.authority.to_account_infos());
        account_infos.extend(self.candy_wrapper.to_account_infos());
        account_infos.extend(self.gummyroll_program.to_account_infos());
        account_infos.extend(self.owner.to_account_infos());
        account_infos.extend(self.delegate.to_account_infos());
        account_infos.extend(self.merkle_slab.to_account_infos());
        account_infos
    }
}
#[automatically_derived]
impl<'info> anchor_lang::ToAccountMetas for Burn<'info> {
    fn to_account_metas(
        &self,
        is_signer: Option<bool>,
    ) -> Vec<anchor_lang::solana_program::instruction::AccountMeta> {
        let mut account_metas = ::alloc::vec::Vec::new();
        account_metas.extend(self.authority.to_account_metas(None));
        account_metas.extend(self.candy_wrapper.to_account_metas(None));
        account_metas.extend(self.gummyroll_program.to_account_metas(None));
        account_metas.extend(self.owner.to_account_metas(None));
        account_metas.extend(self.delegate.to_account_metas(None));
        account_metas.extend(self.merkle_slab.to_account_metas(None));
        account_metas
    }
}
#[automatically_derived]
impl<'info> anchor_lang::AccountsExit<'info> for Burn<'info>
where
    'info: 'info,
{
    fn exit(
        &self,
        program_id: &anchor_lang::solana_program::pubkey::Pubkey,
    ) -> anchor_lang::Result<()> {
        anchor_lang::AccountsExit::exit(&self.merkle_slab, program_id)
            .map_err(|e| e.with_account_name("merkle_slab"))?;
        Ok(())
    }
}
/// An internal, Anchor generated module. This is used (as an
/// implementation detail), to generate a struct for a given
/// `#[derive(Accounts)]` implementation, where each field is a Pubkey,
/// instead of an `AccountInfo`. This is useful for clients that want
/// to generate a list of accounts, without explicitly knowing the
/// order all the fields should be in.
///
/// To access the struct in this module, one should use the sibling
/// `accounts` module (also generated), which re-exports this.
pub(crate) mod __client_accounts_burn {
    use super::*;
    use anchor_lang::prelude::borsh;
    /// Generated client accounts for [`Burn`].
    pub struct Burn {
        pub authority: anchor_lang::solana_program::pubkey::Pubkey,
        pub candy_wrapper: anchor_lang::solana_program::pubkey::Pubkey,
        pub gummyroll_program: anchor_lang::solana_program::pubkey::Pubkey,
        pub owner: anchor_lang::solana_program::pubkey::Pubkey,
        pub delegate: anchor_lang::solana_program::pubkey::Pubkey,
        pub merkle_slab: anchor_lang::solana_program::pubkey::Pubkey,
    }
    impl borsh::ser::BorshSerialize for Burn
    where
        anchor_lang::solana_program::pubkey::Pubkey: borsh::ser::BorshSerialize,
        anchor_lang::solana_program::pubkey::Pubkey: borsh::ser::BorshSerialize,
        anchor_lang::solana_program::pubkey::Pubkey: borsh::ser::BorshSerialize,
        anchor_lang::solana_program::pubkey::Pubkey: borsh::ser::BorshSerialize,
        anchor_lang::solana_program::pubkey::Pubkey: borsh::ser::BorshSerialize,
        anchor_lang::solana_program::pubkey::Pubkey: borsh::ser::BorshSerialize,
    {
        fn serialize<W: borsh::maybestd::io::Write>(
            &self,
            writer: &mut W,
        ) -> ::core::result::Result<(), borsh::maybestd::io::Error> {
            borsh::BorshSerialize::serialize(&self.authority, writer)?;
            borsh::BorshSerialize::serialize(&self.candy_wrapper, writer)?;
            borsh::BorshSerialize::serialize(&self.gummyroll_program, writer)?;
            borsh::BorshSerialize::serialize(&self.owner, writer)?;
            borsh::BorshSerialize::serialize(&self.delegate, writer)?;
            borsh::BorshSerialize::serialize(&self.merkle_slab, writer)?;
            Ok(())
        }
    }
    #[automatically_derived]
    impl anchor_lang::ToAccountMetas for Burn {
        fn to_account_metas(
            &self,
            is_signer: Option<bool>,
        ) -> Vec<anchor_lang::solana_program::instruction::AccountMeta> {
            let mut account_metas = ::alloc::vec::Vec::new();
            account_metas.push(
                anchor_lang::solana_program::instruction::AccountMeta::new_readonly(
                    self.authority,
                    false,
                ),
            );
            account_metas.push(
                anchor_lang::solana_program::instruction::AccountMeta::new_readonly(
                    self.candy_wrapper,
                    false,
                ),
            );
            account_metas.push(
                anchor_lang::solana_program::instruction::AccountMeta::new_readonly(
                    self.gummyroll_program,
                    false,
                ),
            );
            account_metas.push(
                anchor_lang::solana_program::instruction::AccountMeta::new_readonly(
                    self.owner, false,
                ),
            );
            account_metas.push(
                anchor_lang::solana_program::instruction::AccountMeta::new_readonly(
                    self.delegate,
                    false,
                ),
            );
            account_metas.push(anchor_lang::solana_program::instruction::AccountMeta::new(
                self.merkle_slab,
                false,
            ));
            account_metas
        }
    }
}
/// An internal, Anchor generated module. This is used (as an
/// implementation detail), to generate a CPI struct for a given
/// `#[derive(Accounts)]` implementation, where each field is an
/// AccountInfo.
///
/// To access the struct in this module, one should use the sibling
/// [`cpi::accounts`] module (also generated), which re-exports this.
pub(crate) mod __cpi_client_accounts_burn {
    use super::*;
    /// Generated CPI struct of the accounts for [`Burn`].
    pub struct Burn<'info> {
        pub authority: anchor_lang::solana_program::account_info::AccountInfo<'info>,
        pub candy_wrapper: anchor_lang::solana_program::account_info::AccountInfo<'info>,
        pub gummyroll_program: anchor_lang::solana_program::account_info::AccountInfo<'info>,
        pub owner: anchor_lang::solana_program::account_info::AccountInfo<'info>,
        pub delegate: anchor_lang::solana_program::account_info::AccountInfo<'info>,
        pub merkle_slab: anchor_lang::solana_program::account_info::AccountInfo<'info>,
    }
    #[automatically_derived]
    impl<'info> anchor_lang::ToAccountMetas for Burn<'info> {
        fn to_account_metas(
            &self,
            is_signer: Option<bool>,
        ) -> Vec<anchor_lang::solana_program::instruction::AccountMeta> {
            let mut account_metas = ::alloc::vec::Vec::new();
            account_metas.push(
                anchor_lang::solana_program::instruction::AccountMeta::new_readonly(
                    anchor_lang::Key::key(&self.authority),
                    false,
                ),
            );
            account_metas.push(
                anchor_lang::solana_program::instruction::AccountMeta::new_readonly(
                    anchor_lang::Key::key(&self.candy_wrapper),
                    false,
                ),
            );
            account_metas.push(
                anchor_lang::solana_program::instruction::AccountMeta::new_readonly(
                    anchor_lang::Key::key(&self.gummyroll_program),
                    false,
                ),
            );
            account_metas.push(
                anchor_lang::solana_program::instruction::AccountMeta::new_readonly(
                    anchor_lang::Key::key(&self.owner),
                    false,
                ),
            );
            account_metas.push(
                anchor_lang::solana_program::instruction::AccountMeta::new_readonly(
                    anchor_lang::Key::key(&self.delegate),
                    false,
                ),
            );
            account_metas.push(anchor_lang::solana_program::instruction::AccountMeta::new(
                anchor_lang::Key::key(&self.merkle_slab),
                false,
            ));
            account_metas
        }
    }
    #[automatically_derived]
    impl<'info> anchor_lang::ToAccountInfos<'info> for Burn<'info> {
        fn to_account_infos(
            &self,
        ) -> Vec<anchor_lang::solana_program::account_info::AccountInfo<'info>> {
            let mut account_infos = ::alloc::vec::Vec::new();
            account_infos.push(anchor_lang::ToAccountInfo::to_account_info(&self.authority));
            account_infos.push(anchor_lang::ToAccountInfo::to_account_info(
                &self.candy_wrapper,
            ));
            account_infos.push(anchor_lang::ToAccountInfo::to_account_info(
                &self.gummyroll_program,
            ));
            account_infos.push(anchor_lang::ToAccountInfo::to_account_info(&self.owner));
            account_infos.push(anchor_lang::ToAccountInfo::to_account_info(&self.delegate));
            account_infos.push(anchor_lang::ToAccountInfo::to_account_info(
                &self.merkle_slab,
            ));
            account_infos
        }
    }
}
pub struct CreatorVerification<'info> {
    # [account (seeds = [merkle_slab . key () . as_ref ()] , bump ,)]
    pub authority: Account<'info, TreeConfig>,
    /// CHECK: This account is checked in the instruction
    pub owner: UncheckedAccount<'info>,
    /// CHECK: This account is chekced in the instruction
    pub delegate: UncheckedAccount<'info>,
    pub creator: Signer<'info>,
    pub candy_wrapper: Program<'info, Wrapper>,
    pub gummyroll_program: Program<'info, SplCompression>,
    #[account(mut)]
    /// CHECK: This account is modified in the downstream program
    pub merkle_slab: UncheckedAccount<'info>,
}
#[automatically_derived]
impl<'info> anchor_lang::Accounts<'info> for CreatorVerification<'info>
where
    'info: 'info,
{
    #[inline(never)]
    fn try_accounts(
        program_id: &anchor_lang::solana_program::pubkey::Pubkey,
        accounts: &mut &[anchor_lang::solana_program::account_info::AccountInfo<'info>],
        ix_data: &[u8],
        __bumps: &mut std::collections::BTreeMap<String, u8>,
        __reallocs: &mut std::collections::BTreeSet<anchor_lang::solana_program::pubkey::Pubkey>,
    ) -> anchor_lang::Result<Self> {
        let authority: anchor_lang::accounts::account::Account<TreeConfig> =
            anchor_lang::Accounts::try_accounts(program_id, accounts, ix_data, __bumps, __reallocs)
                .map_err(|e| e.with_account_name("authority"))?;
        let owner: UncheckedAccount =
            anchor_lang::Accounts::try_accounts(program_id, accounts, ix_data, __bumps, __reallocs)
                .map_err(|e| e.with_account_name("owner"))?;
        let delegate: UncheckedAccount =
            anchor_lang::Accounts::try_accounts(program_id, accounts, ix_data, __bumps, __reallocs)
                .map_err(|e| e.with_account_name("delegate"))?;
        let creator: Signer =
            anchor_lang::Accounts::try_accounts(program_id, accounts, ix_data, __bumps, __reallocs)
                .map_err(|e| e.with_account_name("creator"))?;
        let candy_wrapper: anchor_lang::accounts::program::Program<Wrapper> =
            anchor_lang::Accounts::try_accounts(program_id, accounts, ix_data, __bumps, __reallocs)
                .map_err(|e| e.with_account_name("candy_wrapper"))?;
        let gummyroll_program: anchor_lang::accounts::program::Program<SplCompression> =
            anchor_lang::Accounts::try_accounts(program_id, accounts, ix_data, __bumps, __reallocs)
                .map_err(|e| e.with_account_name("gummyroll_program"))?;
        let merkle_slab: UncheckedAccount =
            anchor_lang::Accounts::try_accounts(program_id, accounts, ix_data, __bumps, __reallocs)
                .map_err(|e| e.with_account_name("merkle_slab"))?;
        let (__pda_address, __bump) =
            Pubkey::find_program_address(&[merkle_slab.key().as_ref()], &program_id);
        __bumps.insert("authority".to_string(), __bump);
        if authority.key() != __pda_address {
            return Err(anchor_lang::error::Error::from(
                anchor_lang::error::ErrorCode::ConstraintSeeds,
            )
            .with_account_name("authority")
            .with_pubkeys((authority.key(), __pda_address)));
        }
        if !merkle_slab.to_account_info().is_writable {
            return Err(anchor_lang::error::Error::from(
                anchor_lang::error::ErrorCode::ConstraintMut,
            )
            .with_account_name("merkle_slab"));
        }
        Ok(CreatorVerification {
            authority,
            owner,
            delegate,
            creator,
            candy_wrapper,
            gummyroll_program,
            merkle_slab,
        })
    }
}
#[automatically_derived]
impl<'info> anchor_lang::ToAccountInfos<'info> for CreatorVerification<'info>
where
    'info: 'info,
{
    fn to_account_infos(
        &self,
    ) -> Vec<anchor_lang::solana_program::account_info::AccountInfo<'info>> {
        let mut account_infos = ::alloc::vec::Vec::new();
        account_infos.extend(self.authority.to_account_infos());
        account_infos.extend(self.owner.to_account_infos());
        account_infos.extend(self.delegate.to_account_infos());
        account_infos.extend(self.creator.to_account_infos());
        account_infos.extend(self.candy_wrapper.to_account_infos());
        account_infos.extend(self.gummyroll_program.to_account_infos());
        account_infos.extend(self.merkle_slab.to_account_infos());
        account_infos
    }
}
#[automatically_derived]
impl<'info> anchor_lang::ToAccountMetas for CreatorVerification<'info> {
    fn to_account_metas(
        &self,
        is_signer: Option<bool>,
    ) -> Vec<anchor_lang::solana_program::instruction::AccountMeta> {
        let mut account_metas = ::alloc::vec::Vec::new();
        account_metas.extend(self.authority.to_account_metas(None));
        account_metas.extend(self.owner.to_account_metas(None));
        account_metas.extend(self.delegate.to_account_metas(None));
        account_metas.extend(self.creator.to_account_metas(None));
        account_metas.extend(self.candy_wrapper.to_account_metas(None));
        account_metas.extend(self.gummyroll_program.to_account_metas(None));
        account_metas.extend(self.merkle_slab.to_account_metas(None));
        account_metas
    }
}
#[automatically_derived]
impl<'info> anchor_lang::AccountsExit<'info> for CreatorVerification<'info>
where
    'info: 'info,
{
    fn exit(
        &self,
        program_id: &anchor_lang::solana_program::pubkey::Pubkey,
    ) -> anchor_lang::Result<()> {
        anchor_lang::AccountsExit::exit(&self.merkle_slab, program_id)
            .map_err(|e| e.with_account_name("merkle_slab"))?;
        Ok(())
    }
}
/// An internal, Anchor generated module. This is used (as an
/// implementation detail), to generate a struct for a given
/// `#[derive(Accounts)]` implementation, where each field is a Pubkey,
/// instead of an `AccountInfo`. This is useful for clients that want
/// to generate a list of accounts, without explicitly knowing the
/// order all the fields should be in.
///
/// To access the struct in this module, one should use the sibling
/// `accounts` module (also generated), which re-exports this.
pub(crate) mod __client_accounts_creator_verification {
    use super::*;
    use anchor_lang::prelude::borsh;
    /// Generated client accounts for [`CreatorVerification`].
    pub struct CreatorVerification {
        pub authority: anchor_lang::solana_program::pubkey::Pubkey,
        pub owner: anchor_lang::solana_program::pubkey::Pubkey,
        pub delegate: anchor_lang::solana_program::pubkey::Pubkey,
        pub creator: anchor_lang::solana_program::pubkey::Pubkey,
        pub candy_wrapper: anchor_lang::solana_program::pubkey::Pubkey,
        pub gummyroll_program: anchor_lang::solana_program::pubkey::Pubkey,
        pub merkle_slab: anchor_lang::solana_program::pubkey::Pubkey,
    }
    impl borsh::ser::BorshSerialize for CreatorVerification
    where
        anchor_lang::solana_program::pubkey::Pubkey: borsh::ser::BorshSerialize,
        anchor_lang::solana_program::pubkey::Pubkey: borsh::ser::BorshSerialize,
        anchor_lang::solana_program::pubkey::Pubkey: borsh::ser::BorshSerialize,
        anchor_lang::solana_program::pubkey::Pubkey: borsh::ser::BorshSerialize,
        anchor_lang::solana_program::pubkey::Pubkey: borsh::ser::BorshSerialize,
        anchor_lang::solana_program::pubkey::Pubkey: borsh::ser::BorshSerialize,
        anchor_lang::solana_program::pubkey::Pubkey: borsh::ser::BorshSerialize,
    {
        fn serialize<W: borsh::maybestd::io::Write>(
            &self,
            writer: &mut W,
        ) -> ::core::result::Result<(), borsh::maybestd::io::Error> {
            borsh::BorshSerialize::serialize(&self.authority, writer)?;
            borsh::BorshSerialize::serialize(&self.owner, writer)?;
            borsh::BorshSerialize::serialize(&self.delegate, writer)?;
            borsh::BorshSerialize::serialize(&self.creator, writer)?;
            borsh::BorshSerialize::serialize(&self.candy_wrapper, writer)?;
            borsh::BorshSerialize::serialize(&self.gummyroll_program, writer)?;
            borsh::BorshSerialize::serialize(&self.merkle_slab, writer)?;
            Ok(())
        }
    }
    #[automatically_derived]
    impl anchor_lang::ToAccountMetas for CreatorVerification {
        fn to_account_metas(
            &self,
            is_signer: Option<bool>,
        ) -> Vec<anchor_lang::solana_program::instruction::AccountMeta> {
            let mut account_metas = ::alloc::vec::Vec::new();
            account_metas.push(
                anchor_lang::solana_program::instruction::AccountMeta::new_readonly(
                    self.authority,
                    false,
                ),
            );
            account_metas.push(
                anchor_lang::solana_program::instruction::AccountMeta::new_readonly(
                    self.owner, false,
                ),
            );
            account_metas.push(
                anchor_lang::solana_program::instruction::AccountMeta::new_readonly(
                    self.delegate,
                    false,
                ),
            );
            account_metas.push(
                anchor_lang::solana_program::instruction::AccountMeta::new_readonly(
                    self.creator,
                    true,
                ),
            );
            account_metas.push(
                anchor_lang::solana_program::instruction::AccountMeta::new_readonly(
                    self.candy_wrapper,
                    false,
                ),
            );
            account_metas.push(
                anchor_lang::solana_program::instruction::AccountMeta::new_readonly(
                    self.gummyroll_program,
                    false,
                ),
            );
            account_metas.push(anchor_lang::solana_program::instruction::AccountMeta::new(
                self.merkle_slab,
                false,
            ));
            account_metas
        }
    }
}
/// An internal, Anchor generated module. This is used (as an
/// implementation detail), to generate a CPI struct for a given
/// `#[derive(Accounts)]` implementation, where each field is an
/// AccountInfo.
///
/// To access the struct in this module, one should use the sibling
/// [`cpi::accounts`] module (also generated), which re-exports this.
pub(crate) mod __cpi_client_accounts_creator_verification {
    use super::*;
    /// Generated CPI struct of the accounts for [`CreatorVerification`].
    pub struct CreatorVerification<'info> {
        pub authority: anchor_lang::solana_program::account_info::AccountInfo<'info>,
        pub owner: anchor_lang::solana_program::account_info::AccountInfo<'info>,
        pub delegate: anchor_lang::solana_program::account_info::AccountInfo<'info>,
        pub creator: anchor_lang::solana_program::account_info::AccountInfo<'info>,
        pub candy_wrapper: anchor_lang::solana_program::account_info::AccountInfo<'info>,
        pub gummyroll_program: anchor_lang::solana_program::account_info::AccountInfo<'info>,
        pub merkle_slab: anchor_lang::solana_program::account_info::AccountInfo<'info>,
    }
    #[automatically_derived]
    impl<'info> anchor_lang::ToAccountMetas for CreatorVerification<'info> {
        fn to_account_metas(
            &self,
            is_signer: Option<bool>,
        ) -> Vec<anchor_lang::solana_program::instruction::AccountMeta> {
            let mut account_metas = ::alloc::vec::Vec::new();
            account_metas.push(
                anchor_lang::solana_program::instruction::AccountMeta::new_readonly(
                    anchor_lang::Key::key(&self.authority),
                    false,
                ),
            );
            account_metas.push(
                anchor_lang::solana_program::instruction::AccountMeta::new_readonly(
                    anchor_lang::Key::key(&self.owner),
                    false,
                ),
            );
            account_metas.push(
                anchor_lang::solana_program::instruction::AccountMeta::new_readonly(
                    anchor_lang::Key::key(&self.delegate),
                    false,
                ),
            );
            account_metas.push(
                anchor_lang::solana_program::instruction::AccountMeta::new_readonly(
                    anchor_lang::Key::key(&self.creator),
                    true,
                ),
            );
            account_metas.push(
                anchor_lang::solana_program::instruction::AccountMeta::new_readonly(
                    anchor_lang::Key::key(&self.candy_wrapper),
                    false,
                ),
            );
            account_metas.push(
                anchor_lang::solana_program::instruction::AccountMeta::new_readonly(
                    anchor_lang::Key::key(&self.gummyroll_program),
                    false,
                ),
            );
            account_metas.push(anchor_lang::solana_program::instruction::AccountMeta::new(
                anchor_lang::Key::key(&self.merkle_slab),
                false,
            ));
            account_metas
        }
    }
    #[automatically_derived]
    impl<'info> anchor_lang::ToAccountInfos<'info> for CreatorVerification<'info> {
        fn to_account_infos(
            &self,
        ) -> Vec<anchor_lang::solana_program::account_info::AccountInfo<'info>> {
            let mut account_infos = ::alloc::vec::Vec::new();
            account_infos.push(anchor_lang::ToAccountInfo::to_account_info(&self.authority));
            account_infos.push(anchor_lang::ToAccountInfo::to_account_info(&self.owner));
            account_infos.push(anchor_lang::ToAccountInfo::to_account_info(&self.delegate));
            account_infos.push(anchor_lang::ToAccountInfo::to_account_info(&self.creator));
            account_infos.push(anchor_lang::ToAccountInfo::to_account_info(
                &self.candy_wrapper,
            ));
            account_infos.push(anchor_lang::ToAccountInfo::to_account_info(
                &self.gummyroll_program,
            ));
            account_infos.push(anchor_lang::ToAccountInfo::to_account_info(
                &self.merkle_slab,
            ));
            account_infos
        }
    }
}
pub struct Transfer<'info> {
    # [account (seeds = [merkle_slab . key () . as_ref ()] , bump ,)]
    /// CHECK: This account is neither written to nor read from.
    pub authority: Account<'info, TreeConfig>,
    /// CHECK: This account is checked in the instruction
    pub owner: UncheckedAccount<'info>,
    /// CHECK: This account is chekced in the instruction
    pub delegate: UncheckedAccount<'info>,
    /// CHECK: This account is neither written to nor read from.
    pub new_owner: UncheckedAccount<'info>,
    pub candy_wrapper: Program<'info, Wrapper>,
    pub gummyroll_program: Program<'info, SplCompression>,
    #[account(mut)]
    /// CHECK: This account is modified in the downstream program
    pub merkle_slab: UncheckedAccount<'info>,
}
#[automatically_derived]
impl<'info> anchor_lang::Accounts<'info> for Transfer<'info>
where
    'info: 'info,
{
    #[inline(never)]
    fn try_accounts(
        program_id: &anchor_lang::solana_program::pubkey::Pubkey,
        accounts: &mut &[anchor_lang::solana_program::account_info::AccountInfo<'info>],
        ix_data: &[u8],
        __bumps: &mut std::collections::BTreeMap<String, u8>,
        __reallocs: &mut std::collections::BTreeSet<anchor_lang::solana_program::pubkey::Pubkey>,
    ) -> anchor_lang::Result<Self> {
        let authority: anchor_lang::accounts::account::Account<TreeConfig> =
            anchor_lang::Accounts::try_accounts(program_id, accounts, ix_data, __bumps, __reallocs)
                .map_err(|e| e.with_account_name("authority"))?;
        let owner: UncheckedAccount =
            anchor_lang::Accounts::try_accounts(program_id, accounts, ix_data, __bumps, __reallocs)
                .map_err(|e| e.with_account_name("owner"))?;
        let delegate: UncheckedAccount =
            anchor_lang::Accounts::try_accounts(program_id, accounts, ix_data, __bumps, __reallocs)
                .map_err(|e| e.with_account_name("delegate"))?;
        let new_owner: UncheckedAccount =
            anchor_lang::Accounts::try_accounts(program_id, accounts, ix_data, __bumps, __reallocs)
                .map_err(|e| e.with_account_name("new_owner"))?;
        let candy_wrapper: anchor_lang::accounts::program::Program<Wrapper> =
            anchor_lang::Accounts::try_accounts(program_id, accounts, ix_data, __bumps, __reallocs)
                .map_err(|e| e.with_account_name("candy_wrapper"))?;
        let gummyroll_program: anchor_lang::accounts::program::Program<SplCompression> =
            anchor_lang::Accounts::try_accounts(program_id, accounts, ix_data, __bumps, __reallocs)
                .map_err(|e| e.with_account_name("gummyroll_program"))?;
        let merkle_slab: UncheckedAccount =
            anchor_lang::Accounts::try_accounts(program_id, accounts, ix_data, __bumps, __reallocs)
                .map_err(|e| e.with_account_name("merkle_slab"))?;
        let (__pda_address, __bump) =
            Pubkey::find_program_address(&[merkle_slab.key().as_ref()], &program_id);
        __bumps.insert("authority".to_string(), __bump);
        if authority.key() != __pda_address {
            return Err(anchor_lang::error::Error::from(
                anchor_lang::error::ErrorCode::ConstraintSeeds,
            )
            .with_account_name("authority")
            .with_pubkeys((authority.key(), __pda_address)));
        }
        if !merkle_slab.to_account_info().is_writable {
            return Err(anchor_lang::error::Error::from(
                anchor_lang::error::ErrorCode::ConstraintMut,
            )
            .with_account_name("merkle_slab"));
        }
        Ok(Transfer {
            authority,
            owner,
            delegate,
            new_owner,
            candy_wrapper,
            gummyroll_program,
            merkle_slab,
        })
    }
}
#[automatically_derived]
impl<'info> anchor_lang::ToAccountInfos<'info> for Transfer<'info>
where
    'info: 'info,
{
    fn to_account_infos(
        &self,
    ) -> Vec<anchor_lang::solana_program::account_info::AccountInfo<'info>> {
        let mut account_infos = ::alloc::vec::Vec::new();
        account_infos.extend(self.authority.to_account_infos());
        account_infos.extend(self.owner.to_account_infos());
        account_infos.extend(self.delegate.to_account_infos());
        account_infos.extend(self.new_owner.to_account_infos());
        account_infos.extend(self.candy_wrapper.to_account_infos());
        account_infos.extend(self.gummyroll_program.to_account_infos());
        account_infos.extend(self.merkle_slab.to_account_infos());
        account_infos
    }
}
#[automatically_derived]
impl<'info> anchor_lang::ToAccountMetas for Transfer<'info> {
    fn to_account_metas(
        &self,
        is_signer: Option<bool>,
    ) -> Vec<anchor_lang::solana_program::instruction::AccountMeta> {
        let mut account_metas = ::alloc::vec::Vec::new();
        account_metas.extend(self.authority.to_account_metas(None));
        account_metas.extend(self.owner.to_account_metas(None));
        account_metas.extend(self.delegate.to_account_metas(None));
        account_metas.extend(self.new_owner.to_account_metas(None));
        account_metas.extend(self.candy_wrapper.to_account_metas(None));
        account_metas.extend(self.gummyroll_program.to_account_metas(None));
        account_metas.extend(self.merkle_slab.to_account_metas(None));
        account_metas
    }
}
#[automatically_derived]
impl<'info> anchor_lang::AccountsExit<'info> for Transfer<'info>
where
    'info: 'info,
{
    fn exit(
        &self,
        program_id: &anchor_lang::solana_program::pubkey::Pubkey,
    ) -> anchor_lang::Result<()> {
        anchor_lang::AccountsExit::exit(&self.merkle_slab, program_id)
            .map_err(|e| e.with_account_name("merkle_slab"))?;
        Ok(())
    }
}
/// An internal, Anchor generated module. This is used (as an
/// implementation detail), to generate a struct for a given
/// `#[derive(Accounts)]` implementation, where each field is a Pubkey,
/// instead of an `AccountInfo`. This is useful for clients that want
/// to generate a list of accounts, without explicitly knowing the
/// order all the fields should be in.
///
/// To access the struct in this module, one should use the sibling
/// `accounts` module (also generated), which re-exports this.
pub(crate) mod __client_accounts_transfer {
    use super::*;
    use anchor_lang::prelude::borsh;
    /// Generated client accounts for [`Transfer`].
    pub struct Transfer {
        pub authority: anchor_lang::solana_program::pubkey::Pubkey,
        pub owner: anchor_lang::solana_program::pubkey::Pubkey,
        pub delegate: anchor_lang::solana_program::pubkey::Pubkey,
        pub new_owner: anchor_lang::solana_program::pubkey::Pubkey,
        pub candy_wrapper: anchor_lang::solana_program::pubkey::Pubkey,
        pub gummyroll_program: anchor_lang::solana_program::pubkey::Pubkey,
        pub merkle_slab: anchor_lang::solana_program::pubkey::Pubkey,
    }
    impl borsh::ser::BorshSerialize for Transfer
    where
        anchor_lang::solana_program::pubkey::Pubkey: borsh::ser::BorshSerialize,
        anchor_lang::solana_program::pubkey::Pubkey: borsh::ser::BorshSerialize,
        anchor_lang::solana_program::pubkey::Pubkey: borsh::ser::BorshSerialize,
        anchor_lang::solana_program::pubkey::Pubkey: borsh::ser::BorshSerialize,
        anchor_lang::solana_program::pubkey::Pubkey: borsh::ser::BorshSerialize,
        anchor_lang::solana_program::pubkey::Pubkey: borsh::ser::BorshSerialize,
        anchor_lang::solana_program::pubkey::Pubkey: borsh::ser::BorshSerialize,
    {
        fn serialize<W: borsh::maybestd::io::Write>(
            &self,
            writer: &mut W,
        ) -> ::core::result::Result<(), borsh::maybestd::io::Error> {
            borsh::BorshSerialize::serialize(&self.authority, writer)?;
            borsh::BorshSerialize::serialize(&self.owner, writer)?;
            borsh::BorshSerialize::serialize(&self.delegate, writer)?;
            borsh::BorshSerialize::serialize(&self.new_owner, writer)?;
            borsh::BorshSerialize::serialize(&self.candy_wrapper, writer)?;
            borsh::BorshSerialize::serialize(&self.gummyroll_program, writer)?;
            borsh::BorshSerialize::serialize(&self.merkle_slab, writer)?;
            Ok(())
        }
    }
    #[automatically_derived]
    impl anchor_lang::ToAccountMetas for Transfer {
        fn to_account_metas(
            &self,
            is_signer: Option<bool>,
        ) -> Vec<anchor_lang::solana_program::instruction::AccountMeta> {
            let mut account_metas = ::alloc::vec::Vec::new();
            account_metas.push(
                anchor_lang::solana_program::instruction::AccountMeta::new_readonly(
                    self.authority,
                    false,
                ),
            );
            account_metas.push(
                anchor_lang::solana_program::instruction::AccountMeta::new_readonly(
                    self.owner, false,
                ),
            );
            account_metas.push(
                anchor_lang::solana_program::instruction::AccountMeta::new_readonly(
                    self.delegate,
                    false,
                ),
            );
            account_metas.push(
                anchor_lang::solana_program::instruction::AccountMeta::new_readonly(
                    self.new_owner,
                    false,
                ),
            );
            account_metas.push(
                anchor_lang::solana_program::instruction::AccountMeta::new_readonly(
                    self.candy_wrapper,
                    false,
                ),
            );
            account_metas.push(
                anchor_lang::solana_program::instruction::AccountMeta::new_readonly(
                    self.gummyroll_program,
                    false,
                ),
            );
            account_metas.push(anchor_lang::solana_program::instruction::AccountMeta::new(
                self.merkle_slab,
                false,
            ));
            account_metas
        }
    }
}
/// An internal, Anchor generated module. This is used (as an
/// implementation detail), to generate a CPI struct for a given
/// `#[derive(Accounts)]` implementation, where each field is an
/// AccountInfo.
///
/// To access the struct in this module, one should use the sibling
/// [`cpi::accounts`] module (also generated), which re-exports this.
pub(crate) mod __cpi_client_accounts_transfer {
    use super::*;
    /// Generated CPI struct of the accounts for [`Transfer`].
    pub struct Transfer<'info> {
        pub authority: anchor_lang::solana_program::account_info::AccountInfo<'info>,
        pub owner: anchor_lang::solana_program::account_info::AccountInfo<'info>,
        pub delegate: anchor_lang::solana_program::account_info::AccountInfo<'info>,
        pub new_owner: anchor_lang::solana_program::account_info::AccountInfo<'info>,
        pub candy_wrapper: anchor_lang::solana_program::account_info::AccountInfo<'info>,
        pub gummyroll_program: anchor_lang::solana_program::account_info::AccountInfo<'info>,
        pub merkle_slab: anchor_lang::solana_program::account_info::AccountInfo<'info>,
    }
    #[automatically_derived]
    impl<'info> anchor_lang::ToAccountMetas for Transfer<'info> {
        fn to_account_metas(
            &self,
            is_signer: Option<bool>,
        ) -> Vec<anchor_lang::solana_program::instruction::AccountMeta> {
            let mut account_metas = ::alloc::vec::Vec::new();
            account_metas.push(
                anchor_lang::solana_program::instruction::AccountMeta::new_readonly(
                    anchor_lang::Key::key(&self.authority),
                    false,
                ),
            );
            account_metas.push(
                anchor_lang::solana_program::instruction::AccountMeta::new_readonly(
                    anchor_lang::Key::key(&self.owner),
                    false,
                ),
            );
            account_metas.push(
                anchor_lang::solana_program::instruction::AccountMeta::new_readonly(
                    anchor_lang::Key::key(&self.delegate),
                    false,
                ),
            );
            account_metas.push(
                anchor_lang::solana_program::instruction::AccountMeta::new_readonly(
                    anchor_lang::Key::key(&self.new_owner),
                    false,
                ),
            );
            account_metas.push(
                anchor_lang::solana_program::instruction::AccountMeta::new_readonly(
                    anchor_lang::Key::key(&self.candy_wrapper),
                    false,
                ),
            );
            account_metas.push(
                anchor_lang::solana_program::instruction::AccountMeta::new_readonly(
                    anchor_lang::Key::key(&self.gummyroll_program),
                    false,
                ),
            );
            account_metas.push(anchor_lang::solana_program::instruction::AccountMeta::new(
                anchor_lang::Key::key(&self.merkle_slab),
                false,
            ));
            account_metas
        }
    }
    #[automatically_derived]
    impl<'info> anchor_lang::ToAccountInfos<'info> for Transfer<'info> {
        fn to_account_infos(
            &self,
        ) -> Vec<anchor_lang::solana_program::account_info::AccountInfo<'info>> {
            let mut account_infos = ::alloc::vec::Vec::new();
            account_infos.push(anchor_lang::ToAccountInfo::to_account_info(&self.authority));
            account_infos.push(anchor_lang::ToAccountInfo::to_account_info(&self.owner));
            account_infos.push(anchor_lang::ToAccountInfo::to_account_info(&self.delegate));
            account_infos.push(anchor_lang::ToAccountInfo::to_account_info(&self.new_owner));
            account_infos.push(anchor_lang::ToAccountInfo::to_account_info(
                &self.candy_wrapper,
            ));
            account_infos.push(anchor_lang::ToAccountInfo::to_account_info(
                &self.gummyroll_program,
            ));
            account_infos.push(anchor_lang::ToAccountInfo::to_account_info(
                &self.merkle_slab,
            ));
            account_infos
        }
    }
}
pub struct Delegate<'info> {
    # [account (seeds = [merkle_slab . key () . as_ref ()] , bump ,)]
    /// CHECK: This account is neither written to nor read from.
    pub authority: Account<'info, TreeConfig>,
    pub owner: Signer<'info>,
    /// CHECK: This account is neither written to nor read from.
    pub previous_delegate: UncheckedAccount<'info>,
    /// CHECK: This account is neither written to nor read from.
    pub new_delegate: UncheckedAccount<'info>,
    pub candy_wrapper: Program<'info, Wrapper>,
    pub gummyroll_program: Program<'info, SplCompression>,
    #[account(mut)]
    /// CHECK: This account is modified in the downstream program
    pub merkle_slab: UncheckedAccount<'info>,
}
#[automatically_derived]
impl<'info> anchor_lang::Accounts<'info> for Delegate<'info>
where
    'info: 'info,
{
    #[inline(never)]
    fn try_accounts(
        program_id: &anchor_lang::solana_program::pubkey::Pubkey,
        accounts: &mut &[anchor_lang::solana_program::account_info::AccountInfo<'info>],
        ix_data: &[u8],
        __bumps: &mut std::collections::BTreeMap<String, u8>,
        __reallocs: &mut std::collections::BTreeSet<anchor_lang::solana_program::pubkey::Pubkey>,
    ) -> anchor_lang::Result<Self> {
        let authority: anchor_lang::accounts::account::Account<TreeConfig> =
            anchor_lang::Accounts::try_accounts(program_id, accounts, ix_data, __bumps, __reallocs)
                .map_err(|e| e.with_account_name("authority"))?;
        let owner: Signer =
            anchor_lang::Accounts::try_accounts(program_id, accounts, ix_data, __bumps, __reallocs)
                .map_err(|e| e.with_account_name("owner"))?;
        let previous_delegate: UncheckedAccount =
            anchor_lang::Accounts::try_accounts(program_id, accounts, ix_data, __bumps, __reallocs)
                .map_err(|e| e.with_account_name("previous_delegate"))?;
        let new_delegate: UncheckedAccount =
            anchor_lang::Accounts::try_accounts(program_id, accounts, ix_data, __bumps, __reallocs)
                .map_err(|e| e.with_account_name("new_delegate"))?;
        let candy_wrapper: anchor_lang::accounts::program::Program<Wrapper> =
            anchor_lang::Accounts::try_accounts(program_id, accounts, ix_data, __bumps, __reallocs)
                .map_err(|e| e.with_account_name("candy_wrapper"))?;
        let gummyroll_program: anchor_lang::accounts::program::Program<SplCompression> =
            anchor_lang::Accounts::try_accounts(program_id, accounts, ix_data, __bumps, __reallocs)
                .map_err(|e| e.with_account_name("gummyroll_program"))?;
        let merkle_slab: UncheckedAccount =
            anchor_lang::Accounts::try_accounts(program_id, accounts, ix_data, __bumps, __reallocs)
                .map_err(|e| e.with_account_name("merkle_slab"))?;
        let (__pda_address, __bump) =
            Pubkey::find_program_address(&[merkle_slab.key().as_ref()], &program_id);
        __bumps.insert("authority".to_string(), __bump);
        if authority.key() != __pda_address {
            return Err(anchor_lang::error::Error::from(
                anchor_lang::error::ErrorCode::ConstraintSeeds,
            )
            .with_account_name("authority")
            .with_pubkeys((authority.key(), __pda_address)));
        }
        if !merkle_slab.to_account_info().is_writable {
            return Err(anchor_lang::error::Error::from(
                anchor_lang::error::ErrorCode::ConstraintMut,
            )
            .with_account_name("merkle_slab"));
        }
        Ok(Delegate {
            authority,
            owner,
            previous_delegate,
            new_delegate,
            candy_wrapper,
            gummyroll_program,
            merkle_slab,
        })
    }
}
#[automatically_derived]
impl<'info> anchor_lang::ToAccountInfos<'info> for Delegate<'info>
where
    'info: 'info,
{
    fn to_account_infos(
        &self,
    ) -> Vec<anchor_lang::solana_program::account_info::AccountInfo<'info>> {
        let mut account_infos = ::alloc::vec::Vec::new();
        account_infos.extend(self.authority.to_account_infos());
        account_infos.extend(self.owner.to_account_infos());
        account_infos.extend(self.previous_delegate.to_account_infos());
        account_infos.extend(self.new_delegate.to_account_infos());
        account_infos.extend(self.candy_wrapper.to_account_infos());
        account_infos.extend(self.gummyroll_program.to_account_infos());
        account_infos.extend(self.merkle_slab.to_account_infos());
        account_infos
    }
}
#[automatically_derived]
impl<'info> anchor_lang::ToAccountMetas for Delegate<'info> {
    fn to_account_metas(
        &self,
        is_signer: Option<bool>,
    ) -> Vec<anchor_lang::solana_program::instruction::AccountMeta> {
        let mut account_metas = ::alloc::vec::Vec::new();
        account_metas.extend(self.authority.to_account_metas(None));
        account_metas.extend(self.owner.to_account_metas(None));
        account_metas.extend(self.previous_delegate.to_account_metas(None));
        account_metas.extend(self.new_delegate.to_account_metas(None));
        account_metas.extend(self.candy_wrapper.to_account_metas(None));
        account_metas.extend(self.gummyroll_program.to_account_metas(None));
        account_metas.extend(self.merkle_slab.to_account_metas(None));
        account_metas
    }
}
#[automatically_derived]
impl<'info> anchor_lang::AccountsExit<'info> for Delegate<'info>
where
    'info: 'info,
{
    fn exit(
        &self,
        program_id: &anchor_lang::solana_program::pubkey::Pubkey,
    ) -> anchor_lang::Result<()> {
        anchor_lang::AccountsExit::exit(&self.merkle_slab, program_id)
            .map_err(|e| e.with_account_name("merkle_slab"))?;
        Ok(())
    }
}
/// An internal, Anchor generated module. This is used (as an
/// implementation detail), to generate a struct for a given
/// `#[derive(Accounts)]` implementation, where each field is a Pubkey,
/// instead of an `AccountInfo`. This is useful for clients that want
/// to generate a list of accounts, without explicitly knowing the
/// order all the fields should be in.
///
/// To access the struct in this module, one should use the sibling
/// `accounts` module (also generated), which re-exports this.
pub(crate) mod __client_accounts_delegate {
    use super::*;
    use anchor_lang::prelude::borsh;
    /// Generated client accounts for [`Delegate`].
    pub struct Delegate {
        pub authority: anchor_lang::solana_program::pubkey::Pubkey,
        pub owner: anchor_lang::solana_program::pubkey::Pubkey,
        pub previous_delegate: anchor_lang::solana_program::pubkey::Pubkey,
        pub new_delegate: anchor_lang::solana_program::pubkey::Pubkey,
        pub candy_wrapper: anchor_lang::solana_program::pubkey::Pubkey,
        pub gummyroll_program: anchor_lang::solana_program::pubkey::Pubkey,
        pub merkle_slab: anchor_lang::solana_program::pubkey::Pubkey,
    }
    impl borsh::ser::BorshSerialize for Delegate
    where
        anchor_lang::solana_program::pubkey::Pubkey: borsh::ser::BorshSerialize,
        anchor_lang::solana_program::pubkey::Pubkey: borsh::ser::BorshSerialize,
        anchor_lang::solana_program::pubkey::Pubkey: borsh::ser::BorshSerialize,
        anchor_lang::solana_program::pubkey::Pubkey: borsh::ser::BorshSerialize,
        anchor_lang::solana_program::pubkey::Pubkey: borsh::ser::BorshSerialize,
        anchor_lang::solana_program::pubkey::Pubkey: borsh::ser::BorshSerialize,
        anchor_lang::solana_program::pubkey::Pubkey: borsh::ser::BorshSerialize,
    {
        fn serialize<W: borsh::maybestd::io::Write>(
            &self,
            writer: &mut W,
        ) -> ::core::result::Result<(), borsh::maybestd::io::Error> {
            borsh::BorshSerialize::serialize(&self.authority, writer)?;
            borsh::BorshSerialize::serialize(&self.owner, writer)?;
            borsh::BorshSerialize::serialize(&self.previous_delegate, writer)?;
            borsh::BorshSerialize::serialize(&self.new_delegate, writer)?;
            borsh::BorshSerialize::serialize(&self.candy_wrapper, writer)?;
            borsh::BorshSerialize::serialize(&self.gummyroll_program, writer)?;
            borsh::BorshSerialize::serialize(&self.merkle_slab, writer)?;
            Ok(())
        }
    }
    #[automatically_derived]
    impl anchor_lang::ToAccountMetas for Delegate {
        fn to_account_metas(
            &self,
            is_signer: Option<bool>,
        ) -> Vec<anchor_lang::solana_program::instruction::AccountMeta> {
            let mut account_metas = ::alloc::vec::Vec::new();
            account_metas.push(
                anchor_lang::solana_program::instruction::AccountMeta::new_readonly(
                    self.authority,
                    false,
                ),
            );
            account_metas.push(
                anchor_lang::solana_program::instruction::AccountMeta::new_readonly(
                    self.owner, true,
                ),
            );
            account_metas.push(
                anchor_lang::solana_program::instruction::AccountMeta::new_readonly(
                    self.previous_delegate,
                    false,
                ),
            );
            account_metas.push(
                anchor_lang::solana_program::instruction::AccountMeta::new_readonly(
                    self.new_delegate,
                    false,
                ),
            );
            account_metas.push(
                anchor_lang::solana_program::instruction::AccountMeta::new_readonly(
                    self.candy_wrapper,
                    false,
                ),
            );
            account_metas.push(
                anchor_lang::solana_program::instruction::AccountMeta::new_readonly(
                    self.gummyroll_program,
                    false,
                ),
            );
            account_metas.push(anchor_lang::solana_program::instruction::AccountMeta::new(
                self.merkle_slab,
                false,
            ));
            account_metas
        }
    }
}
/// An internal, Anchor generated module. This is used (as an
/// implementation detail), to generate a CPI struct for a given
/// `#[derive(Accounts)]` implementation, where each field is an
/// AccountInfo.
///
/// To access the struct in this module, one should use the sibling
/// [`cpi::accounts`] module (also generated), which re-exports this.
pub(crate) mod __cpi_client_accounts_delegate {
    use super::*;
    /// Generated CPI struct of the accounts for [`Delegate`].
    pub struct Delegate<'info> {
        pub authority: anchor_lang::solana_program::account_info::AccountInfo<'info>,
        pub owner: anchor_lang::solana_program::account_info::AccountInfo<'info>,
        pub previous_delegate: anchor_lang::solana_program::account_info::AccountInfo<'info>,
        pub new_delegate: anchor_lang::solana_program::account_info::AccountInfo<'info>,
        pub candy_wrapper: anchor_lang::solana_program::account_info::AccountInfo<'info>,
        pub gummyroll_program: anchor_lang::solana_program::account_info::AccountInfo<'info>,
        pub merkle_slab: anchor_lang::solana_program::account_info::AccountInfo<'info>,
    }
    #[automatically_derived]
    impl<'info> anchor_lang::ToAccountMetas for Delegate<'info> {
        fn to_account_metas(
            &self,
            is_signer: Option<bool>,
        ) -> Vec<anchor_lang::solana_program::instruction::AccountMeta> {
            let mut account_metas = ::alloc::vec::Vec::new();
            account_metas.push(
                anchor_lang::solana_program::instruction::AccountMeta::new_readonly(
                    anchor_lang::Key::key(&self.authority),
                    false,
                ),
            );
            account_metas.push(
                anchor_lang::solana_program::instruction::AccountMeta::new_readonly(
                    anchor_lang::Key::key(&self.owner),
                    true,
                ),
            );
            account_metas.push(
                anchor_lang::solana_program::instruction::AccountMeta::new_readonly(
                    anchor_lang::Key::key(&self.previous_delegate),
                    false,
                ),
            );
            account_metas.push(
                anchor_lang::solana_program::instruction::AccountMeta::new_readonly(
                    anchor_lang::Key::key(&self.new_delegate),
                    false,
                ),
            );
            account_metas.push(
                anchor_lang::solana_program::instruction::AccountMeta::new_readonly(
                    anchor_lang::Key::key(&self.candy_wrapper),
                    false,
                ),
            );
            account_metas.push(
                anchor_lang::solana_program::instruction::AccountMeta::new_readonly(
                    anchor_lang::Key::key(&self.gummyroll_program),
                    false,
                ),
            );
            account_metas.push(anchor_lang::solana_program::instruction::AccountMeta::new(
                anchor_lang::Key::key(&self.merkle_slab),
                false,
            ));
            account_metas
        }
    }
    #[automatically_derived]
    impl<'info> anchor_lang::ToAccountInfos<'info> for Delegate<'info> {
        fn to_account_infos(
            &self,
        ) -> Vec<anchor_lang::solana_program::account_info::AccountInfo<'info>> {
            let mut account_infos = ::alloc::vec::Vec::new();
            account_infos.push(anchor_lang::ToAccountInfo::to_account_info(&self.authority));
            account_infos.push(anchor_lang::ToAccountInfo::to_account_info(&self.owner));
            account_infos.push(anchor_lang::ToAccountInfo::to_account_info(
                &self.previous_delegate,
            ));
            account_infos.push(anchor_lang::ToAccountInfo::to_account_info(
                &self.new_delegate,
            ));
            account_infos.push(anchor_lang::ToAccountInfo::to_account_info(
                &self.candy_wrapper,
            ));
            account_infos.push(anchor_lang::ToAccountInfo::to_account_info(
                &self.gummyroll_program,
            ));
            account_infos.push(anchor_lang::ToAccountInfo::to_account_info(
                &self.merkle_slab,
            ));
            account_infos
        }
    }
}
# [instruction (_root : [u8 ; 32] , _data_hash : [u8 ; 32] , _creator_hash : [u8 ; 32] , nonce : u64 , _index : u32 ,)]
pub struct Redeem<'info> {
    # [account (seeds = [merkle_slab . key () . as_ref ()] , bump ,)]
    /// CHECK: This account is neither written to nor read from.
    pub authority: Account<'info, TreeConfig>,
    pub candy_wrapper: Program<'info, Wrapper>,
    pub gummyroll_program: Program<'info, SplCompression>,
    #[account(mut)]
    pub owner: Signer<'info>,
    /// CHECK: This account is chekced in the instruction
    pub delegate: UncheckedAccount<'info>,
    #[account(mut)]
    /// CHECK: checked in cpi
    pub merkle_slab: UncheckedAccount<'info>,
    # [account (init , seeds = [VOUCHER_PREFIX . as_ref () , merkle_slab . key () . as_ref () , & nonce . to_le_bytes ()] , payer = owner , space = VOUCHER_SIZE , bump)]
    pub voucher: Account<'info, Voucher>,
    pub system_program: Program<'info, System>,
}
#[automatically_derived]
impl<'info> anchor_lang::Accounts<'info> for Redeem<'info>
where
    'info: 'info,
{
    #[inline(never)]
    fn try_accounts(
        program_id: &anchor_lang::solana_program::pubkey::Pubkey,
        accounts: &mut &[anchor_lang::solana_program::account_info::AccountInfo<'info>],
        ix_data: &[u8],
        __bumps: &mut std::collections::BTreeMap<String, u8>,
        __reallocs: &mut std::collections::BTreeSet<anchor_lang::solana_program::pubkey::Pubkey>,
    ) -> anchor_lang::Result<Self> {
        let mut ix_data = ix_data;
        struct __Args {
            _root: [u8; 32],
            _data_hash: [u8; 32],
            _creator_hash: [u8; 32],
            nonce: u64,
            _index: u32,
        }
        impl borsh::ser::BorshSerialize for __Args
        where
            [u8; 32]: borsh::ser::BorshSerialize,
            [u8; 32]: borsh::ser::BorshSerialize,
            [u8; 32]: borsh::ser::BorshSerialize,
            u64: borsh::ser::BorshSerialize,
            u32: borsh::ser::BorshSerialize,
        {
            fn serialize<W: borsh::maybestd::io::Write>(
                &self,
                writer: &mut W,
            ) -> ::core::result::Result<(), borsh::maybestd::io::Error> {
                borsh::BorshSerialize::serialize(&self._root, writer)?;
                borsh::BorshSerialize::serialize(&self._data_hash, writer)?;
                borsh::BorshSerialize::serialize(&self._creator_hash, writer)?;
                borsh::BorshSerialize::serialize(&self.nonce, writer)?;
                borsh::BorshSerialize::serialize(&self._index, writer)?;
                Ok(())
            }
        }
        impl borsh::de::BorshDeserialize for __Args
        where
            [u8; 32]: borsh::BorshDeserialize,
            [u8; 32]: borsh::BorshDeserialize,
            [u8; 32]: borsh::BorshDeserialize,
            u64: borsh::BorshDeserialize,
            u32: borsh::BorshDeserialize,
        {
            fn deserialize(
                buf: &mut &[u8],
            ) -> ::core::result::Result<Self, borsh::maybestd::io::Error> {
                Ok(Self {
                    _root: borsh::BorshDeserialize::deserialize(buf)?,
                    _data_hash: borsh::BorshDeserialize::deserialize(buf)?,
                    _creator_hash: borsh::BorshDeserialize::deserialize(buf)?,
                    nonce: borsh::BorshDeserialize::deserialize(buf)?,
                    _index: borsh::BorshDeserialize::deserialize(buf)?,
                })
            }
        }
        let __Args {
            _root,
            _data_hash,
            _creator_hash,
            nonce,
            _index,
        } = __Args::deserialize(&mut ix_data)
            .map_err(|_| anchor_lang::error::ErrorCode::InstructionDidNotDeserialize)?;
        let authority: anchor_lang::accounts::account::Account<TreeConfig> =
            anchor_lang::Accounts::try_accounts(program_id, accounts, ix_data, __bumps, __reallocs)
                .map_err(|e| e.with_account_name("authority"))?;
        let candy_wrapper: anchor_lang::accounts::program::Program<Wrapper> =
            anchor_lang::Accounts::try_accounts(program_id, accounts, ix_data, __bumps, __reallocs)
                .map_err(|e| e.with_account_name("candy_wrapper"))?;
        let gummyroll_program: anchor_lang::accounts::program::Program<SplCompression> =
            anchor_lang::Accounts::try_accounts(program_id, accounts, ix_data, __bumps, __reallocs)
                .map_err(|e| e.with_account_name("gummyroll_program"))?;
        let owner: Signer =
            anchor_lang::Accounts::try_accounts(program_id, accounts, ix_data, __bumps, __reallocs)
                .map_err(|e| e.with_account_name("owner"))?;
        let delegate: UncheckedAccount =
            anchor_lang::Accounts::try_accounts(program_id, accounts, ix_data, __bumps, __reallocs)
                .map_err(|e| e.with_account_name("delegate"))?;
        let merkle_slab: UncheckedAccount =
            anchor_lang::Accounts::try_accounts(program_id, accounts, ix_data, __bumps, __reallocs)
                .map_err(|e| e.with_account_name("merkle_slab"))?;
        if accounts.is_empty() {
            return Err(anchor_lang::error::ErrorCode::AccountNotEnoughKeys.into());
        }
        let voucher = &accounts[0];
        *accounts = &accounts[1..];
        let system_program: anchor_lang::accounts::program::Program<System> =
            anchor_lang::Accounts::try_accounts(program_id, accounts, ix_data, __bumps, __reallocs)
                .map_err(|e| e.with_account_name("system_program"))?;
        let __anchor_rent = Rent::get()?;
        let (__pda_address, __bump) = Pubkey::find_program_address(
            &[
                VOUCHER_PREFIX.as_ref(),
                merkle_slab.key().as_ref(),
                &nonce.to_le_bytes(),
            ],
            program_id,
        );
        __bumps.insert("voucher".to_string(), __bump);
        let voucher = {
            let actual_field = voucher.to_account_info();
            let actual_owner = actual_field.owner;
            let space = VOUCHER_SIZE;
            let pa: anchor_lang::accounts::account::Account<Voucher> =
                if !false || actual_owner == &anchor_lang::solana_program::system_program::ID {
                    let payer = owner.to_account_info();
                    let __current_lamports = voucher.lamports();
                    if __current_lamports == 0 {
                        let lamports = __anchor_rent.minimum_balance(space);
                        let cpi_accounts = anchor_lang::system_program::CreateAccount {
                            from: payer.to_account_info(),
                            to: voucher.to_account_info(),
                        };
                        let cpi_context = anchor_lang::context::CpiContext::new(
                            system_program.to_account_info(),
                            cpi_accounts,
                        );
                        anchor_lang::system_program::create_account(
                            cpi_context.with_signer(&[&[
                                VOUCHER_PREFIX.as_ref(),
                                merkle_slab.key().as_ref(),
                                &nonce.to_le_bytes(),
                                &[__bump][..],
                            ][..]]),
                            lamports,
                            space as u64,
                            program_id,
                        )?;
                    } else {
                        let required_lamports = __anchor_rent
                            .minimum_balance(space)
                            .max(1)
                            .saturating_sub(__current_lamports);
                        if required_lamports > 0 {
                            let cpi_accounts = anchor_lang::system_program::Transfer {
                                from: payer.to_account_info(),
                                to: voucher.to_account_info(),
                            };
                            let cpi_context = anchor_lang::context::CpiContext::new(
                                system_program.to_account_info(),
                                cpi_accounts,
                            );
                            anchor_lang::system_program::transfer(cpi_context, required_lamports)?;
                        }
                        let cpi_accounts = anchor_lang::system_program::Allocate {
                            account_to_allocate: voucher.to_account_info(),
                        };
                        let cpi_context = anchor_lang::context::CpiContext::new(
                            system_program.to_account_info(),
                            cpi_accounts,
                        );
                        anchor_lang::system_program::allocate(
                            cpi_context.with_signer(&[&[
                                VOUCHER_PREFIX.as_ref(),
                                merkle_slab.key().as_ref(),
                                &nonce.to_le_bytes(),
                                &[__bump][..],
                            ][..]]),
                            space as u64,
                        )?;
                        let cpi_accounts = anchor_lang::system_program::Assign {
                            account_to_assign: voucher.to_account_info(),
                        };
                        let cpi_context = anchor_lang::context::CpiContext::new(
                            system_program.to_account_info(),
                            cpi_accounts,
                        );
                        anchor_lang::system_program::assign(
                            cpi_context.with_signer(&[&[
                                VOUCHER_PREFIX.as_ref(),
                                merkle_slab.key().as_ref(),
                                &nonce.to_le_bytes(),
                                &[__bump][..],
                            ][..]]),
                            program_id,
                        )?;
                    }
                    anchor_lang::accounts::account::Account::try_from_unchecked(&voucher)
                        .map_err(|e| e.with_account_name("voucher"))?
                } else {
                    anchor_lang::accounts::account::Account::try_from(&voucher)
                        .map_err(|e| e.with_account_name("voucher"))?
                };
            if false {
                if space != actual_field.data_len() {
                    return Err(anchor_lang::error::Error::from(
                        anchor_lang::error::ErrorCode::ConstraintSpace,
                    )
                    .with_account_name("voucher")
                    .with_values((space, actual_field.data_len())));
                }
                if actual_owner != program_id {
                    return Err(anchor_lang::error::Error::from(
                        anchor_lang::error::ErrorCode::ConstraintOwner,
                    )
                    .with_account_name("voucher")
                    .with_pubkeys((*actual_owner, *program_id)));
                }
                {
                    let required_lamports = __anchor_rent.minimum_balance(space);
                    if pa.to_account_info().lamports() < required_lamports {
                        return Err(anchor_lang::error::Error::from(
                            anchor_lang::error::ErrorCode::ConstraintRentExempt,
                        )
                        .with_account_name("voucher"));
                    }
                }
            }
            pa
        };
        if voucher.key() != __pda_address {
            return Err(anchor_lang::error::Error::from(
                anchor_lang::error::ErrorCode::ConstraintSeeds,
            )
            .with_account_name("voucher")
            .with_pubkeys((voucher.key(), __pda_address)));
        }
        if !voucher.to_account_info().is_writable {
            return Err(anchor_lang::error::Error::from(
                anchor_lang::error::ErrorCode::ConstraintMut,
            )
            .with_account_name("voucher"));
        }
        if !__anchor_rent.is_exempt(
            voucher.to_account_info().lamports(),
            voucher.to_account_info().try_data_len()?,
        ) {
            return Err(anchor_lang::error::Error::from(
                anchor_lang::error::ErrorCode::ConstraintRentExempt,
            )
            .with_account_name("voucher"));
        }
        let (__pda_address, __bump) =
            Pubkey::find_program_address(&[merkle_slab.key().as_ref()], &program_id);
        __bumps.insert("authority".to_string(), __bump);
        if authority.key() != __pda_address {
            return Err(anchor_lang::error::Error::from(
                anchor_lang::error::ErrorCode::ConstraintSeeds,
            )
            .with_account_name("authority")
            .with_pubkeys((authority.key(), __pda_address)));
        }
        if !owner.to_account_info().is_writable {
            return Err(anchor_lang::error::Error::from(
                anchor_lang::error::ErrorCode::ConstraintMut,
            )
            .with_account_name("owner"));
        }
        if !merkle_slab.to_account_info().is_writable {
            return Err(anchor_lang::error::Error::from(
                anchor_lang::error::ErrorCode::ConstraintMut,
            )
            .with_account_name("merkle_slab"));
        }
        Ok(Redeem {
            authority,
            candy_wrapper,
            gummyroll_program,
            owner,
            delegate,
            merkle_slab,
            voucher,
            system_program,
        })
    }
}
#[automatically_derived]
impl<'info> anchor_lang::ToAccountInfos<'info> for Redeem<'info>
where
    'info: 'info,
{
    fn to_account_infos(
        &self,
    ) -> Vec<anchor_lang::solana_program::account_info::AccountInfo<'info>> {
        let mut account_infos = ::alloc::vec::Vec::new();
        account_infos.extend(self.authority.to_account_infos());
        account_infos.extend(self.candy_wrapper.to_account_infos());
        account_infos.extend(self.gummyroll_program.to_account_infos());
        account_infos.extend(self.owner.to_account_infos());
        account_infos.extend(self.delegate.to_account_infos());
        account_infos.extend(self.merkle_slab.to_account_infos());
        account_infos.extend(self.voucher.to_account_infos());
        account_infos.extend(self.system_program.to_account_infos());
        account_infos
    }
}
#[automatically_derived]
impl<'info> anchor_lang::ToAccountMetas for Redeem<'info> {
    fn to_account_metas(
        &self,
        is_signer: Option<bool>,
    ) -> Vec<anchor_lang::solana_program::instruction::AccountMeta> {
        let mut account_metas = ::alloc::vec::Vec::new();
        account_metas.extend(self.authority.to_account_metas(None));
        account_metas.extend(self.candy_wrapper.to_account_metas(None));
        account_metas.extend(self.gummyroll_program.to_account_metas(None));
        account_metas.extend(self.owner.to_account_metas(None));
        account_metas.extend(self.delegate.to_account_metas(None));
        account_metas.extend(self.merkle_slab.to_account_metas(None));
        account_metas.extend(self.voucher.to_account_metas(None));
        account_metas.extend(self.system_program.to_account_metas(None));
        account_metas
    }
}
#[automatically_derived]
impl<'info> anchor_lang::AccountsExit<'info> for Redeem<'info>
where
    'info: 'info,
{
    fn exit(
        &self,
        program_id: &anchor_lang::solana_program::pubkey::Pubkey,
    ) -> anchor_lang::Result<()> {
        anchor_lang::AccountsExit::exit(&self.owner, program_id)
            .map_err(|e| e.with_account_name("owner"))?;
        anchor_lang::AccountsExit::exit(&self.merkle_slab, program_id)
            .map_err(|e| e.with_account_name("merkle_slab"))?;
        anchor_lang::AccountsExit::exit(&self.voucher, program_id)
            .map_err(|e| e.with_account_name("voucher"))?;
        Ok(())
    }
}
/// An internal, Anchor generated module. This is used (as an
/// implementation detail), to generate a struct for a given
/// `#[derive(Accounts)]` implementation, where each field is a Pubkey,
/// instead of an `AccountInfo`. This is useful for clients that want
/// to generate a list of accounts, without explicitly knowing the
/// order all the fields should be in.
///
/// To access the struct in this module, one should use the sibling
/// `accounts` module (also generated), which re-exports this.
pub(crate) mod __client_accounts_redeem {
    use super::*;
    use anchor_lang::prelude::borsh;
    /// Generated client accounts for [`Redeem`].
    pub struct Redeem {
        pub authority: anchor_lang::solana_program::pubkey::Pubkey,
        pub candy_wrapper: anchor_lang::solana_program::pubkey::Pubkey,
        pub gummyroll_program: anchor_lang::solana_program::pubkey::Pubkey,
        pub owner: anchor_lang::solana_program::pubkey::Pubkey,
        pub delegate: anchor_lang::solana_program::pubkey::Pubkey,
        pub merkle_slab: anchor_lang::solana_program::pubkey::Pubkey,
        pub voucher: anchor_lang::solana_program::pubkey::Pubkey,
        pub system_program: anchor_lang::solana_program::pubkey::Pubkey,
    }
    impl borsh::ser::BorshSerialize for Redeem
    where
        anchor_lang::solana_program::pubkey::Pubkey: borsh::ser::BorshSerialize,
        anchor_lang::solana_program::pubkey::Pubkey: borsh::ser::BorshSerialize,
        anchor_lang::solana_program::pubkey::Pubkey: borsh::ser::BorshSerialize,
        anchor_lang::solana_program::pubkey::Pubkey: borsh::ser::BorshSerialize,
        anchor_lang::solana_program::pubkey::Pubkey: borsh::ser::BorshSerialize,
        anchor_lang::solana_program::pubkey::Pubkey: borsh::ser::BorshSerialize,
        anchor_lang::solana_program::pubkey::Pubkey: borsh::ser::BorshSerialize,
        anchor_lang::solana_program::pubkey::Pubkey: borsh::ser::BorshSerialize,
    {
        fn serialize<W: borsh::maybestd::io::Write>(
            &self,
            writer: &mut W,
        ) -> ::core::result::Result<(), borsh::maybestd::io::Error> {
            borsh::BorshSerialize::serialize(&self.authority, writer)?;
            borsh::BorshSerialize::serialize(&self.candy_wrapper, writer)?;
            borsh::BorshSerialize::serialize(&self.gummyroll_program, writer)?;
            borsh::BorshSerialize::serialize(&self.owner, writer)?;
            borsh::BorshSerialize::serialize(&self.delegate, writer)?;
            borsh::BorshSerialize::serialize(&self.merkle_slab, writer)?;
            borsh::BorshSerialize::serialize(&self.voucher, writer)?;
            borsh::BorshSerialize::serialize(&self.system_program, writer)?;
            Ok(())
        }
    }
    #[automatically_derived]
    impl anchor_lang::ToAccountMetas for Redeem {
        fn to_account_metas(
            &self,
            is_signer: Option<bool>,
        ) -> Vec<anchor_lang::solana_program::instruction::AccountMeta> {
            let mut account_metas = ::alloc::vec::Vec::new();
            account_metas.push(
                anchor_lang::solana_program::instruction::AccountMeta::new_readonly(
                    self.authority,
                    false,
                ),
            );
            account_metas.push(
                anchor_lang::solana_program::instruction::AccountMeta::new_readonly(
                    self.candy_wrapper,
                    false,
                ),
            );
            account_metas.push(
                anchor_lang::solana_program::instruction::AccountMeta::new_readonly(
                    self.gummyroll_program,
                    false,
                ),
            );
            account_metas.push(anchor_lang::solana_program::instruction::AccountMeta::new(
                self.owner, true,
            ));
            account_metas.push(
                anchor_lang::solana_program::instruction::AccountMeta::new_readonly(
                    self.delegate,
                    false,
                ),
            );
            account_metas.push(anchor_lang::solana_program::instruction::AccountMeta::new(
                self.merkle_slab,
                false,
            ));
            account_metas.push(anchor_lang::solana_program::instruction::AccountMeta::new(
                self.voucher,
                false,
            ));
            account_metas.push(
                anchor_lang::solana_program::instruction::AccountMeta::new_readonly(
                    self.system_program,
                    false,
                ),
            );
            account_metas
        }
    }
}
/// An internal, Anchor generated module. This is used (as an
/// implementation detail), to generate a CPI struct for a given
/// `#[derive(Accounts)]` implementation, where each field is an
/// AccountInfo.
///
/// To access the struct in this module, one should use the sibling
/// [`cpi::accounts`] module (also generated), which re-exports this.
pub(crate) mod __cpi_client_accounts_redeem {
    use super::*;
    /// Generated CPI struct of the accounts for [`Redeem`].
    pub struct Redeem<'info> {
        pub authority: anchor_lang::solana_program::account_info::AccountInfo<'info>,
        pub candy_wrapper: anchor_lang::solana_program::account_info::AccountInfo<'info>,
        pub gummyroll_program: anchor_lang::solana_program::account_info::AccountInfo<'info>,
        pub owner: anchor_lang::solana_program::account_info::AccountInfo<'info>,
        pub delegate: anchor_lang::solana_program::account_info::AccountInfo<'info>,
        pub merkle_slab: anchor_lang::solana_program::account_info::AccountInfo<'info>,
        pub voucher: anchor_lang::solana_program::account_info::AccountInfo<'info>,
        pub system_program: anchor_lang::solana_program::account_info::AccountInfo<'info>,
    }
    #[automatically_derived]
    impl<'info> anchor_lang::ToAccountMetas for Redeem<'info> {
        fn to_account_metas(
            &self,
            is_signer: Option<bool>,
        ) -> Vec<anchor_lang::solana_program::instruction::AccountMeta> {
            let mut account_metas = ::alloc::vec::Vec::new();
            account_metas.push(
                anchor_lang::solana_program::instruction::AccountMeta::new_readonly(
                    anchor_lang::Key::key(&self.authority),
                    false,
                ),
            );
            account_metas.push(
                anchor_lang::solana_program::instruction::AccountMeta::new_readonly(
                    anchor_lang::Key::key(&self.candy_wrapper),
                    false,
                ),
            );
            account_metas.push(
                anchor_lang::solana_program::instruction::AccountMeta::new_readonly(
                    anchor_lang::Key::key(&self.gummyroll_program),
                    false,
                ),
            );
            account_metas.push(anchor_lang::solana_program::instruction::AccountMeta::new(
                anchor_lang::Key::key(&self.owner),
                true,
            ));
            account_metas.push(
                anchor_lang::solana_program::instruction::AccountMeta::new_readonly(
                    anchor_lang::Key::key(&self.delegate),
                    false,
                ),
            );
            account_metas.push(anchor_lang::solana_program::instruction::AccountMeta::new(
                anchor_lang::Key::key(&self.merkle_slab),
                false,
            ));
            account_metas.push(anchor_lang::solana_program::instruction::AccountMeta::new(
                anchor_lang::Key::key(&self.voucher),
                false,
            ));
            account_metas.push(
                anchor_lang::solana_program::instruction::AccountMeta::new_readonly(
                    anchor_lang::Key::key(&self.system_program),
                    false,
                ),
            );
            account_metas
        }
    }
    #[automatically_derived]
    impl<'info> anchor_lang::ToAccountInfos<'info> for Redeem<'info> {
        fn to_account_infos(
            &self,
        ) -> Vec<anchor_lang::solana_program::account_info::AccountInfo<'info>> {
            let mut account_infos = ::alloc::vec::Vec::new();
            account_infos.push(anchor_lang::ToAccountInfo::to_account_info(&self.authority));
            account_infos.push(anchor_lang::ToAccountInfo::to_account_info(
                &self.candy_wrapper,
            ));
            account_infos.push(anchor_lang::ToAccountInfo::to_account_info(
                &self.gummyroll_program,
            ));
            account_infos.push(anchor_lang::ToAccountInfo::to_account_info(&self.owner));
            account_infos.push(anchor_lang::ToAccountInfo::to_account_info(&self.delegate));
            account_infos.push(anchor_lang::ToAccountInfo::to_account_info(
                &self.merkle_slab,
            ));
            account_infos.push(anchor_lang::ToAccountInfo::to_account_info(&self.voucher));
            account_infos.push(anchor_lang::ToAccountInfo::to_account_info(
                &self.system_program,
            ));
            account_infos
        }
    }
}
pub struct CancelRedeem<'info> {
    # [account (seeds = [merkle_slab . key () . as_ref ()] , bump ,)]
    /// CHECK: This account is neither written to nor read from.
    pub authority: Account<'info, TreeConfig>,
    pub candy_wrapper: Program<'info, Wrapper>,
    pub gummyroll_program: Program<'info, SplCompression>,
    #[account(mut)]
    /// CHECK: unsafe
    pub merkle_slab: UncheckedAccount<'info>,
    # [account (mut , close = owner , seeds = [VOUCHER_PREFIX . as_ref () , merkle_slab . key () . as_ref () , & voucher . leaf_schema . nonce () . to_le_bytes ()] , bump)]
    pub voucher: Account<'info, Voucher>,
    #[account(mut)]
    pub owner: Signer<'info>,
}
#[automatically_derived]
impl<'info> anchor_lang::Accounts<'info> for CancelRedeem<'info>
where
    'info: 'info,
{
    #[inline(never)]
    fn try_accounts(
        program_id: &anchor_lang::solana_program::pubkey::Pubkey,
        accounts: &mut &[anchor_lang::solana_program::account_info::AccountInfo<'info>],
        ix_data: &[u8],
        __bumps: &mut std::collections::BTreeMap<String, u8>,
        __reallocs: &mut std::collections::BTreeSet<anchor_lang::solana_program::pubkey::Pubkey>,
    ) -> anchor_lang::Result<Self> {
        let authority: anchor_lang::accounts::account::Account<TreeConfig> =
            anchor_lang::Accounts::try_accounts(program_id, accounts, ix_data, __bumps, __reallocs)
                .map_err(|e| e.with_account_name("authority"))?;
        let candy_wrapper: anchor_lang::accounts::program::Program<Wrapper> =
            anchor_lang::Accounts::try_accounts(program_id, accounts, ix_data, __bumps, __reallocs)
                .map_err(|e| e.with_account_name("candy_wrapper"))?;
        let gummyroll_program: anchor_lang::accounts::program::Program<SplCompression> =
            anchor_lang::Accounts::try_accounts(program_id, accounts, ix_data, __bumps, __reallocs)
                .map_err(|e| e.with_account_name("gummyroll_program"))?;
        let merkle_slab: UncheckedAccount =
            anchor_lang::Accounts::try_accounts(program_id, accounts, ix_data, __bumps, __reallocs)
                .map_err(|e| e.with_account_name("merkle_slab"))?;
        let voucher: anchor_lang::accounts::account::Account<Voucher> =
            anchor_lang::Accounts::try_accounts(program_id, accounts, ix_data, __bumps, __reallocs)
                .map_err(|e| e.with_account_name("voucher"))?;
        let owner: Signer =
            anchor_lang::Accounts::try_accounts(program_id, accounts, ix_data, __bumps, __reallocs)
                .map_err(|e| e.with_account_name("owner"))?;
        let (__pda_address, __bump) =
            Pubkey::find_program_address(&[merkle_slab.key().as_ref()], &program_id);
        __bumps.insert("authority".to_string(), __bump);
        if authority.key() != __pda_address {
            return Err(anchor_lang::error::Error::from(
                anchor_lang::error::ErrorCode::ConstraintSeeds,
            )
            .with_account_name("authority")
            .with_pubkeys((authority.key(), __pda_address)));
        }
        if !merkle_slab.to_account_info().is_writable {
            return Err(anchor_lang::error::Error::from(
                anchor_lang::error::ErrorCode::ConstraintMut,
            )
            .with_account_name("merkle_slab"));
        }
        let (__pda_address, __bump) = Pubkey::find_program_address(
            &[
                VOUCHER_PREFIX.as_ref(),
                merkle_slab.key().as_ref(),
                &voucher.leaf_schema.nonce().to_le_bytes(),
            ],
            &program_id,
        );
        __bumps.insert("voucher".to_string(), __bump);
        if voucher.key() != __pda_address {
            return Err(anchor_lang::error::Error::from(
                anchor_lang::error::ErrorCode::ConstraintSeeds,
            )
            .with_account_name("voucher")
            .with_pubkeys((voucher.key(), __pda_address)));
        }
        if !voucher.to_account_info().is_writable {
            return Err(anchor_lang::error::Error::from(
                anchor_lang::error::ErrorCode::ConstraintMut,
            )
            .with_account_name("voucher"));
        }
        if voucher.key() == owner.key() {
            return Err(anchor_lang::error::Error::from(
                anchor_lang::error::ErrorCode::ConstraintClose,
            )
            .with_account_name("voucher"));
        }
        if !owner.to_account_info().is_writable {
            return Err(anchor_lang::error::Error::from(
                anchor_lang::error::ErrorCode::ConstraintMut,
            )
            .with_account_name("owner"));
        }
        Ok(CancelRedeem {
            authority,
            candy_wrapper,
            gummyroll_program,
            merkle_slab,
            voucher,
            owner,
        })
    }
}
#[automatically_derived]
impl<'info> anchor_lang::ToAccountInfos<'info> for CancelRedeem<'info>
where
    'info: 'info,
{
    fn to_account_infos(
        &self,
    ) -> Vec<anchor_lang::solana_program::account_info::AccountInfo<'info>> {
        let mut account_infos = ::alloc::vec::Vec::new();
        account_infos.extend(self.authority.to_account_infos());
        account_infos.extend(self.candy_wrapper.to_account_infos());
        account_infos.extend(self.gummyroll_program.to_account_infos());
        account_infos.extend(self.merkle_slab.to_account_infos());
        account_infos.extend(self.voucher.to_account_infos());
        account_infos.extend(self.owner.to_account_infos());
        account_infos
    }
}
#[automatically_derived]
impl<'info> anchor_lang::ToAccountMetas for CancelRedeem<'info> {
    fn to_account_metas(
        &self,
        is_signer: Option<bool>,
    ) -> Vec<anchor_lang::solana_program::instruction::AccountMeta> {
        let mut account_metas = ::alloc::vec::Vec::new();
        account_metas.extend(self.authority.to_account_metas(None));
        account_metas.extend(self.candy_wrapper.to_account_metas(None));
        account_metas.extend(self.gummyroll_program.to_account_metas(None));
        account_metas.extend(self.merkle_slab.to_account_metas(None));
        account_metas.extend(self.voucher.to_account_metas(None));
        account_metas.extend(self.owner.to_account_metas(None));
        account_metas
    }
}
#[automatically_derived]
impl<'info> anchor_lang::AccountsExit<'info> for CancelRedeem<'info>
where
    'info: 'info,
{
    fn exit(
        &self,
        program_id: &anchor_lang::solana_program::pubkey::Pubkey,
    ) -> anchor_lang::Result<()> {
        anchor_lang::AccountsExit::exit(&self.merkle_slab, program_id)
            .map_err(|e| e.with_account_name("merkle_slab"))?;
        anchor_lang::AccountsClose::close(&self.voucher, self.owner.to_account_info())
            .map_err(|e| e.with_account_name("voucher"))?;
        anchor_lang::AccountsExit::exit(&self.owner, program_id)
            .map_err(|e| e.with_account_name("owner"))?;
        Ok(())
    }
}
/// An internal, Anchor generated module. This is used (as an
/// implementation detail), to generate a struct for a given
/// `#[derive(Accounts)]` implementation, where each field is a Pubkey,
/// instead of an `AccountInfo`. This is useful for clients that want
/// to generate a list of accounts, without explicitly knowing the
/// order all the fields should be in.
///
/// To access the struct in this module, one should use the sibling
/// `accounts` module (also generated), which re-exports this.
pub(crate) mod __client_accounts_cancel_redeem {
    use super::*;
    use anchor_lang::prelude::borsh;
    /// Generated client accounts for [`CancelRedeem`].
    pub struct CancelRedeem {
        pub authority: anchor_lang::solana_program::pubkey::Pubkey,
        pub candy_wrapper: anchor_lang::solana_program::pubkey::Pubkey,
        pub gummyroll_program: anchor_lang::solana_program::pubkey::Pubkey,
        pub merkle_slab: anchor_lang::solana_program::pubkey::Pubkey,
        pub voucher: anchor_lang::solana_program::pubkey::Pubkey,
        pub owner: anchor_lang::solana_program::pubkey::Pubkey,
    }
    impl borsh::ser::BorshSerialize for CancelRedeem
    where
        anchor_lang::solana_program::pubkey::Pubkey: borsh::ser::BorshSerialize,
        anchor_lang::solana_program::pubkey::Pubkey: borsh::ser::BorshSerialize,
        anchor_lang::solana_program::pubkey::Pubkey: borsh::ser::BorshSerialize,
        anchor_lang::solana_program::pubkey::Pubkey: borsh::ser::BorshSerialize,
        anchor_lang::solana_program::pubkey::Pubkey: borsh::ser::BorshSerialize,
        anchor_lang::solana_program::pubkey::Pubkey: borsh::ser::BorshSerialize,
    {
        fn serialize<W: borsh::maybestd::io::Write>(
            &self,
            writer: &mut W,
        ) -> ::core::result::Result<(), borsh::maybestd::io::Error> {
            borsh::BorshSerialize::serialize(&self.authority, writer)?;
            borsh::BorshSerialize::serialize(&self.candy_wrapper, writer)?;
            borsh::BorshSerialize::serialize(&self.gummyroll_program, writer)?;
            borsh::BorshSerialize::serialize(&self.merkle_slab, writer)?;
            borsh::BorshSerialize::serialize(&self.voucher, writer)?;
            borsh::BorshSerialize::serialize(&self.owner, writer)?;
            Ok(())
        }
    }
    #[automatically_derived]
    impl anchor_lang::ToAccountMetas for CancelRedeem {
        fn to_account_metas(
            &self,
            is_signer: Option<bool>,
        ) -> Vec<anchor_lang::solana_program::instruction::AccountMeta> {
            let mut account_metas = ::alloc::vec::Vec::new();
            account_metas.push(
                anchor_lang::solana_program::instruction::AccountMeta::new_readonly(
                    self.authority,
                    false,
                ),
            );
            account_metas.push(
                anchor_lang::solana_program::instruction::AccountMeta::new_readonly(
                    self.candy_wrapper,
                    false,
                ),
            );
            account_metas.push(
                anchor_lang::solana_program::instruction::AccountMeta::new_readonly(
                    self.gummyroll_program,
                    false,
                ),
            );
            account_metas.push(anchor_lang::solana_program::instruction::AccountMeta::new(
                self.merkle_slab,
                false,
            ));
            account_metas.push(anchor_lang::solana_program::instruction::AccountMeta::new(
                self.voucher,
                false,
            ));
            account_metas.push(anchor_lang::solana_program::instruction::AccountMeta::new(
                self.owner, true,
            ));
            account_metas
        }
    }
}
/// An internal, Anchor generated module. This is used (as an
/// implementation detail), to generate a CPI struct for a given
/// `#[derive(Accounts)]` implementation, where each field is an
/// AccountInfo.
///
/// To access the struct in this module, one should use the sibling
/// [`cpi::accounts`] module (also generated), which re-exports this.
pub(crate) mod __cpi_client_accounts_cancel_redeem {
    use super::*;
    /// Generated CPI struct of the accounts for [`CancelRedeem`].
    pub struct CancelRedeem<'info> {
        pub authority: anchor_lang::solana_program::account_info::AccountInfo<'info>,
        pub candy_wrapper: anchor_lang::solana_program::account_info::AccountInfo<'info>,
        pub gummyroll_program: anchor_lang::solana_program::account_info::AccountInfo<'info>,
        pub merkle_slab: anchor_lang::solana_program::account_info::AccountInfo<'info>,
        pub voucher: anchor_lang::solana_program::account_info::AccountInfo<'info>,
        pub owner: anchor_lang::solana_program::account_info::AccountInfo<'info>,
    }
    #[automatically_derived]
    impl<'info> anchor_lang::ToAccountMetas for CancelRedeem<'info> {
        fn to_account_metas(
            &self,
            is_signer: Option<bool>,
        ) -> Vec<anchor_lang::solana_program::instruction::AccountMeta> {
            let mut account_metas = ::alloc::vec::Vec::new();
            account_metas.push(
                anchor_lang::solana_program::instruction::AccountMeta::new_readonly(
                    anchor_lang::Key::key(&self.authority),
                    false,
                ),
            );
            account_metas.push(
                anchor_lang::solana_program::instruction::AccountMeta::new_readonly(
                    anchor_lang::Key::key(&self.candy_wrapper),
                    false,
                ),
            );
            account_metas.push(
                anchor_lang::solana_program::instruction::AccountMeta::new_readonly(
                    anchor_lang::Key::key(&self.gummyroll_program),
                    false,
                ),
            );
            account_metas.push(anchor_lang::solana_program::instruction::AccountMeta::new(
                anchor_lang::Key::key(&self.merkle_slab),
                false,
            ));
            account_metas.push(anchor_lang::solana_program::instruction::AccountMeta::new(
                anchor_lang::Key::key(&self.voucher),
                false,
            ));
            account_metas.push(anchor_lang::solana_program::instruction::AccountMeta::new(
                anchor_lang::Key::key(&self.owner),
                true,
            ));
            account_metas
        }
    }
    #[automatically_derived]
    impl<'info> anchor_lang::ToAccountInfos<'info> for CancelRedeem<'info> {
        fn to_account_infos(
            &self,
        ) -> Vec<anchor_lang::solana_program::account_info::AccountInfo<'info>> {
            let mut account_infos = ::alloc::vec::Vec::new();
            account_infos.push(anchor_lang::ToAccountInfo::to_account_info(&self.authority));
            account_infos.push(anchor_lang::ToAccountInfo::to_account_info(
                &self.candy_wrapper,
            ));
            account_infos.push(anchor_lang::ToAccountInfo::to_account_info(
                &self.gummyroll_program,
            ));
            account_infos.push(anchor_lang::ToAccountInfo::to_account_info(
                &self.merkle_slab,
            ));
            account_infos.push(anchor_lang::ToAccountInfo::to_account_info(&self.voucher));
            account_infos.push(anchor_lang::ToAccountInfo::to_account_info(&self.owner));
            account_infos
        }
    }
}
pub struct DecompressV1<'info> {
    # [account (mut , close = owner , seeds = [VOUCHER_PREFIX . as_ref () , voucher . merkle_slab . as_ref () , voucher . leaf_schema . nonce () . to_le_bytes () . as_ref ()] , bump)]
    pub voucher: Box<Account<'info, Voucher>>,
    #[account(mut)]
    pub owner: Signer<'info>,
    /// CHECK: versioning is handled in the instruction
    #[account(mut)]
    pub token_account: UncheckedAccount<'info>,
    /// CHECK: versioning is handled in the instruction
    # [account (mut , seeds = [ASSET_PREFIX . as_ref () , voucher . merkle_slab . as_ref () , voucher . leaf_schema . nonce () . to_le_bytes () . as_ref () ,] , bump)]
    pub mint: UncheckedAccount<'info>,
    /// CHECK:
    # [account (seeds = [mint . key () . as_ref ()] , bump ,)]
    pub mint_authority: UncheckedAccount<'info>,
    /// CHECK:
    #[account(mut)]
    pub metadata: UncheckedAccount<'info>,
    /// CHECK: Initialized in Token Metadata Program
    #[account(mut)]
    pub master_edition: UncheckedAccount<'info>,
    pub system_program: Program<'info, System>,
    pub sysvar_rent: Sysvar<'info, Rent>,
    /// CHECK:
    pub token_metadata_program: Program<'info, MplTokenMetadata>,
    /// CHECK: versioning is handled in the instruction
    pub token_program: UncheckedAccount<'info>,
    /// CHECK:
    pub associated_token_program: UncheckedAccount<'info>,
}
#[automatically_derived]
impl<'info> anchor_lang::Accounts<'info> for DecompressV1<'info>
where
    'info: 'info,
{
    #[inline(never)]
    fn try_accounts(
        program_id: &anchor_lang::solana_program::pubkey::Pubkey,
        accounts: &mut &[anchor_lang::solana_program::account_info::AccountInfo<'info>],
        ix_data: &[u8],
        __bumps: &mut std::collections::BTreeMap<String, u8>,
        __reallocs: &mut std::collections::BTreeSet<anchor_lang::solana_program::pubkey::Pubkey>,
    ) -> anchor_lang::Result<Self> {
        let voucher: Box<anchor_lang::accounts::account::Account<Voucher>> =
            anchor_lang::Accounts::try_accounts(program_id, accounts, ix_data, __bumps, __reallocs)
                .map_err(|e| e.with_account_name("voucher"))?;
        let owner: Signer =
            anchor_lang::Accounts::try_accounts(program_id, accounts, ix_data, __bumps, __reallocs)
                .map_err(|e| e.with_account_name("owner"))?;
        let token_account: UncheckedAccount =
            anchor_lang::Accounts::try_accounts(program_id, accounts, ix_data, __bumps, __reallocs)
                .map_err(|e| e.with_account_name("token_account"))?;
        let mint: UncheckedAccount =
            anchor_lang::Accounts::try_accounts(program_id, accounts, ix_data, __bumps, __reallocs)
                .map_err(|e| e.with_account_name("mint"))?;
        let mint_authority: UncheckedAccount =
            anchor_lang::Accounts::try_accounts(program_id, accounts, ix_data, __bumps, __reallocs)
                .map_err(|e| e.with_account_name("mint_authority"))?;
        let metadata: UncheckedAccount =
            anchor_lang::Accounts::try_accounts(program_id, accounts, ix_data, __bumps, __reallocs)
                .map_err(|e| e.with_account_name("metadata"))?;
        let master_edition: UncheckedAccount =
            anchor_lang::Accounts::try_accounts(program_id, accounts, ix_data, __bumps, __reallocs)
                .map_err(|e| e.with_account_name("master_edition"))?;
        let system_program: anchor_lang::accounts::program::Program<System> =
            anchor_lang::Accounts::try_accounts(program_id, accounts, ix_data, __bumps, __reallocs)
                .map_err(|e| e.with_account_name("system_program"))?;
        let sysvar_rent: Sysvar<Rent> =
            anchor_lang::Accounts::try_accounts(program_id, accounts, ix_data, __bumps, __reallocs)
                .map_err(|e| e.with_account_name("sysvar_rent"))?;
        let token_metadata_program: anchor_lang::accounts::program::Program<MplTokenMetadata> =
            anchor_lang::Accounts::try_accounts(program_id, accounts, ix_data, __bumps, __reallocs)
                .map_err(|e| e.with_account_name("token_metadata_program"))?;
        let token_program: UncheckedAccount =
            anchor_lang::Accounts::try_accounts(program_id, accounts, ix_data, __bumps, __reallocs)
                .map_err(|e| e.with_account_name("token_program"))?;
        let associated_token_program: UncheckedAccount =
            anchor_lang::Accounts::try_accounts(program_id, accounts, ix_data, __bumps, __reallocs)
                .map_err(|e| e.with_account_name("associated_token_program"))?;
        let (__pda_address, __bump) = Pubkey::find_program_address(
            &[
                VOUCHER_PREFIX.as_ref(),
                voucher.merkle_slab.as_ref(),
                voucher.leaf_schema.nonce().to_le_bytes().as_ref(),
            ],
            &program_id,
        );
        __bumps.insert("voucher".to_string(), __bump);
        if voucher.key() != __pda_address {
            return Err(anchor_lang::error::Error::from(
                anchor_lang::error::ErrorCode::ConstraintSeeds,
            )
            .with_account_name("voucher")
            .with_pubkeys((voucher.key(), __pda_address)));
        }
        if !voucher.to_account_info().is_writable {
            return Err(anchor_lang::error::Error::from(
                anchor_lang::error::ErrorCode::ConstraintMut,
            )
            .with_account_name("voucher"));
        }
        if voucher.key() == owner.key() {
            return Err(anchor_lang::error::Error::from(
                anchor_lang::error::ErrorCode::ConstraintClose,
            )
            .with_account_name("voucher"));
        }
        if !owner.to_account_info().is_writable {
            return Err(anchor_lang::error::Error::from(
                anchor_lang::error::ErrorCode::ConstraintMut,
            )
            .with_account_name("owner"));
        }
        if !token_account.to_account_info().is_writable {
            return Err(anchor_lang::error::Error::from(
                anchor_lang::error::ErrorCode::ConstraintMut,
            )
            .with_account_name("token_account"));
        }
        let (__pda_address, __bump) = Pubkey::find_program_address(
            &[
                ASSET_PREFIX.as_ref(),
                voucher.merkle_slab.as_ref(),
                voucher.leaf_schema.nonce().to_le_bytes().as_ref(),
            ],
            &program_id,
        );
        __bumps.insert("mint".to_string(), __bump);
        if mint.key() != __pda_address {
            return Err(anchor_lang::error::Error::from(
                anchor_lang::error::ErrorCode::ConstraintSeeds,
            )
            .with_account_name("mint")
            .with_pubkeys((mint.key(), __pda_address)));
        }
        if !mint.to_account_info().is_writable {
            return Err(anchor_lang::error::Error::from(
                anchor_lang::error::ErrorCode::ConstraintMut,
            )
            .with_account_name("mint"));
        }
        let (__pda_address, __bump) =
            Pubkey::find_program_address(&[mint.key().as_ref()], &program_id);
        __bumps.insert("mint_authority".to_string(), __bump);
        if mint_authority.key() != __pda_address {
            return Err(anchor_lang::error::Error::from(
                anchor_lang::error::ErrorCode::ConstraintSeeds,
            )
            .with_account_name("mint_authority")
            .with_pubkeys((mint_authority.key(), __pda_address)));
        }
        if !metadata.to_account_info().is_writable {
            return Err(anchor_lang::error::Error::from(
                anchor_lang::error::ErrorCode::ConstraintMut,
            )
            .with_account_name("metadata"));
        }
        if !master_edition.to_account_info().is_writable {
            return Err(anchor_lang::error::Error::from(
                anchor_lang::error::ErrorCode::ConstraintMut,
            )
            .with_account_name("master_edition"));
        }
        Ok(DecompressV1 {
            voucher,
            owner,
            token_account,
            mint,
            mint_authority,
            metadata,
            master_edition,
            system_program,
            sysvar_rent,
            token_metadata_program,
            token_program,
            associated_token_program,
        })
    }
}
#[automatically_derived]
impl<'info> anchor_lang::ToAccountInfos<'info> for DecompressV1<'info>
where
    'info: 'info,
{
    fn to_account_infos(
        &self,
    ) -> Vec<anchor_lang::solana_program::account_info::AccountInfo<'info>> {
        let mut account_infos = ::alloc::vec::Vec::new();
        account_infos.extend(self.voucher.to_account_infos());
        account_infos.extend(self.owner.to_account_infos());
        account_infos.extend(self.token_account.to_account_infos());
        account_infos.extend(self.mint.to_account_infos());
        account_infos.extend(self.mint_authority.to_account_infos());
        account_infos.extend(self.metadata.to_account_infos());
        account_infos.extend(self.master_edition.to_account_infos());
        account_infos.extend(self.system_program.to_account_infos());
        account_infos.extend(self.sysvar_rent.to_account_infos());
        account_infos.extend(self.token_metadata_program.to_account_infos());
        account_infos.extend(self.token_program.to_account_infos());
        account_infos.extend(self.associated_token_program.to_account_infos());
        account_infos
    }
}
#[automatically_derived]
impl<'info> anchor_lang::ToAccountMetas for DecompressV1<'info> {
    fn to_account_metas(
        &self,
        is_signer: Option<bool>,
    ) -> Vec<anchor_lang::solana_program::instruction::AccountMeta> {
        let mut account_metas = ::alloc::vec::Vec::new();
        account_metas.extend(self.voucher.to_account_metas(None));
        account_metas.extend(self.owner.to_account_metas(None));
        account_metas.extend(self.token_account.to_account_metas(None));
        account_metas.extend(self.mint.to_account_metas(None));
        account_metas.extend(self.mint_authority.to_account_metas(None));
        account_metas.extend(self.metadata.to_account_metas(None));
        account_metas.extend(self.master_edition.to_account_metas(None));
        account_metas.extend(self.system_program.to_account_metas(None));
        account_metas.extend(self.sysvar_rent.to_account_metas(None));
        account_metas.extend(self.token_metadata_program.to_account_metas(None));
        account_metas.extend(self.token_program.to_account_metas(None));
        account_metas.extend(self.associated_token_program.to_account_metas(None));
        account_metas
    }
}
#[automatically_derived]
impl<'info> anchor_lang::AccountsExit<'info> for DecompressV1<'info>
where
    'info: 'info,
{
    fn exit(
        &self,
        program_id: &anchor_lang::solana_program::pubkey::Pubkey,
    ) -> anchor_lang::Result<()> {
        anchor_lang::AccountsClose::close(&self.voucher, self.owner.to_account_info())
            .map_err(|e| e.with_account_name("voucher"))?;
        anchor_lang::AccountsExit::exit(&self.owner, program_id)
            .map_err(|e| e.with_account_name("owner"))?;
        anchor_lang::AccountsExit::exit(&self.token_account, program_id)
            .map_err(|e| e.with_account_name("token_account"))?;
        anchor_lang::AccountsExit::exit(&self.mint, program_id)
            .map_err(|e| e.with_account_name("mint"))?;
        anchor_lang::AccountsExit::exit(&self.metadata, program_id)
            .map_err(|e| e.with_account_name("metadata"))?;
        anchor_lang::AccountsExit::exit(&self.master_edition, program_id)
            .map_err(|e| e.with_account_name("master_edition"))?;
        Ok(())
    }
}
/// An internal, Anchor generated module. This is used (as an
/// implementation detail), to generate a struct for a given
/// `#[derive(Accounts)]` implementation, where each field is a Pubkey,
/// instead of an `AccountInfo`. This is useful for clients that want
/// to generate a list of accounts, without explicitly knowing the
/// order all the fields should be in.
///
/// To access the struct in this module, one should use the sibling
/// `accounts` module (also generated), which re-exports this.
pub(crate) mod __client_accounts_decompress_v1 {
    use super::*;
    use anchor_lang::prelude::borsh;
    /// Generated client accounts for [`DecompressV1`].
    pub struct DecompressV1 {
        pub voucher: anchor_lang::solana_program::pubkey::Pubkey,
        pub owner: anchor_lang::solana_program::pubkey::Pubkey,
        pub token_account: anchor_lang::solana_program::pubkey::Pubkey,
        pub mint: anchor_lang::solana_program::pubkey::Pubkey,
        pub mint_authority: anchor_lang::solana_program::pubkey::Pubkey,
        pub metadata: anchor_lang::solana_program::pubkey::Pubkey,
        pub master_edition: anchor_lang::solana_program::pubkey::Pubkey,
        pub system_program: anchor_lang::solana_program::pubkey::Pubkey,
        pub sysvar_rent: anchor_lang::solana_program::pubkey::Pubkey,
        pub token_metadata_program: anchor_lang::solana_program::pubkey::Pubkey,
        pub token_program: anchor_lang::solana_program::pubkey::Pubkey,
        pub associated_token_program: anchor_lang::solana_program::pubkey::Pubkey,
    }
    impl borsh::ser::BorshSerialize for DecompressV1
    where
        anchor_lang::solana_program::pubkey::Pubkey: borsh::ser::BorshSerialize,
        anchor_lang::solana_program::pubkey::Pubkey: borsh::ser::BorshSerialize,
        anchor_lang::solana_program::pubkey::Pubkey: borsh::ser::BorshSerialize,
        anchor_lang::solana_program::pubkey::Pubkey: borsh::ser::BorshSerialize,
        anchor_lang::solana_program::pubkey::Pubkey: borsh::ser::BorshSerialize,
        anchor_lang::solana_program::pubkey::Pubkey: borsh::ser::BorshSerialize,
        anchor_lang::solana_program::pubkey::Pubkey: borsh::ser::BorshSerialize,
        anchor_lang::solana_program::pubkey::Pubkey: borsh::ser::BorshSerialize,
        anchor_lang::solana_program::pubkey::Pubkey: borsh::ser::BorshSerialize,
        anchor_lang::solana_program::pubkey::Pubkey: borsh::ser::BorshSerialize,
        anchor_lang::solana_program::pubkey::Pubkey: borsh::ser::BorshSerialize,
        anchor_lang::solana_program::pubkey::Pubkey: borsh::ser::BorshSerialize,
    {
        fn serialize<W: borsh::maybestd::io::Write>(
            &self,
            writer: &mut W,
        ) -> ::core::result::Result<(), borsh::maybestd::io::Error> {
            borsh::BorshSerialize::serialize(&self.voucher, writer)?;
            borsh::BorshSerialize::serialize(&self.owner, writer)?;
            borsh::BorshSerialize::serialize(&self.token_account, writer)?;
            borsh::BorshSerialize::serialize(&self.mint, writer)?;
            borsh::BorshSerialize::serialize(&self.mint_authority, writer)?;
            borsh::BorshSerialize::serialize(&self.metadata, writer)?;
            borsh::BorshSerialize::serialize(&self.master_edition, writer)?;
            borsh::BorshSerialize::serialize(&self.system_program, writer)?;
            borsh::BorshSerialize::serialize(&self.sysvar_rent, writer)?;
            borsh::BorshSerialize::serialize(&self.token_metadata_program, writer)?;
            borsh::BorshSerialize::serialize(&self.token_program, writer)?;
            borsh::BorshSerialize::serialize(&self.associated_token_program, writer)?;
            Ok(())
        }
    }
    #[automatically_derived]
    impl anchor_lang::ToAccountMetas for DecompressV1 {
        fn to_account_metas(
            &self,
            is_signer: Option<bool>,
        ) -> Vec<anchor_lang::solana_program::instruction::AccountMeta> {
            let mut account_metas = ::alloc::vec::Vec::new();
            account_metas.push(anchor_lang::solana_program::instruction::AccountMeta::new(
                self.voucher,
                false,
            ));
            account_metas.push(anchor_lang::solana_program::instruction::AccountMeta::new(
                self.owner, true,
            ));
            account_metas.push(anchor_lang::solana_program::instruction::AccountMeta::new(
                self.token_account,
                false,
            ));
            account_metas.push(anchor_lang::solana_program::instruction::AccountMeta::new(
                self.mint, false,
            ));
            account_metas.push(
                anchor_lang::solana_program::instruction::AccountMeta::new_readonly(
                    self.mint_authority,
                    false,
                ),
            );
            account_metas.push(anchor_lang::solana_program::instruction::AccountMeta::new(
                self.metadata,
                false,
            ));
            account_metas.push(anchor_lang::solana_program::instruction::AccountMeta::new(
                self.master_edition,
                false,
            ));
            account_metas.push(
                anchor_lang::solana_program::instruction::AccountMeta::new_readonly(
                    self.system_program,
                    false,
                ),
            );
            account_metas.push(
                anchor_lang::solana_program::instruction::AccountMeta::new_readonly(
                    self.sysvar_rent,
                    false,
                ),
            );
            account_metas.push(
                anchor_lang::solana_program::instruction::AccountMeta::new_readonly(
                    self.token_metadata_program,
                    false,
                ),
            );
            account_metas.push(
                anchor_lang::solana_program::instruction::AccountMeta::new_readonly(
                    self.token_program,
                    false,
                ),
            );
            account_metas.push(
                anchor_lang::solana_program::instruction::AccountMeta::new_readonly(
                    self.associated_token_program,
                    false,
                ),
            );
            account_metas
        }
    }
}
/// An internal, Anchor generated module. This is used (as an
/// implementation detail), to generate a CPI struct for a given
/// `#[derive(Accounts)]` implementation, where each field is an
/// AccountInfo.
///
/// To access the struct in this module, one should use the sibling
/// [`cpi::accounts`] module (also generated), which re-exports this.
pub(crate) mod __cpi_client_accounts_decompress_v1 {
    use super::*;
    /// Generated CPI struct of the accounts for [`DecompressV1`].
    pub struct DecompressV1<'info> {
        pub voucher: anchor_lang::solana_program::account_info::AccountInfo<'info>,
        pub owner: anchor_lang::solana_program::account_info::AccountInfo<'info>,
        pub token_account: anchor_lang::solana_program::account_info::AccountInfo<'info>,
        pub mint: anchor_lang::solana_program::account_info::AccountInfo<'info>,
        pub mint_authority: anchor_lang::solana_program::account_info::AccountInfo<'info>,
        pub metadata: anchor_lang::solana_program::account_info::AccountInfo<'info>,
        pub master_edition: anchor_lang::solana_program::account_info::AccountInfo<'info>,
        pub system_program: anchor_lang::solana_program::account_info::AccountInfo<'info>,
        pub sysvar_rent: anchor_lang::solana_program::account_info::AccountInfo<'info>,
        pub token_metadata_program: anchor_lang::solana_program::account_info::AccountInfo<'info>,
        pub token_program: anchor_lang::solana_program::account_info::AccountInfo<'info>,
        pub associated_token_program: anchor_lang::solana_program::account_info::AccountInfo<'info>,
    }
    #[automatically_derived]
    impl<'info> anchor_lang::ToAccountMetas for DecompressV1<'info> {
        fn to_account_metas(
            &self,
            is_signer: Option<bool>,
        ) -> Vec<anchor_lang::solana_program::instruction::AccountMeta> {
            let mut account_metas = ::alloc::vec::Vec::new();
            account_metas.push(anchor_lang::solana_program::instruction::AccountMeta::new(
                anchor_lang::Key::key(&self.voucher),
                false,
            ));
            account_metas.push(anchor_lang::solana_program::instruction::AccountMeta::new(
                anchor_lang::Key::key(&self.owner),
                true,
            ));
            account_metas.push(anchor_lang::solana_program::instruction::AccountMeta::new(
                anchor_lang::Key::key(&self.token_account),
                false,
            ));
            account_metas.push(anchor_lang::solana_program::instruction::AccountMeta::new(
                anchor_lang::Key::key(&self.mint),
                false,
            ));
            account_metas.push(
                anchor_lang::solana_program::instruction::AccountMeta::new_readonly(
                    anchor_lang::Key::key(&self.mint_authority),
                    false,
                ),
            );
            account_metas.push(anchor_lang::solana_program::instruction::AccountMeta::new(
                anchor_lang::Key::key(&self.metadata),
                false,
            ));
            account_metas.push(anchor_lang::solana_program::instruction::AccountMeta::new(
                anchor_lang::Key::key(&self.master_edition),
                false,
            ));
            account_metas.push(
                anchor_lang::solana_program::instruction::AccountMeta::new_readonly(
                    anchor_lang::Key::key(&self.system_program),
                    false,
                ),
            );
            account_metas.push(
                anchor_lang::solana_program::instruction::AccountMeta::new_readonly(
                    anchor_lang::Key::key(&self.sysvar_rent),
                    false,
                ),
            );
            account_metas.push(
                anchor_lang::solana_program::instruction::AccountMeta::new_readonly(
                    anchor_lang::Key::key(&self.token_metadata_program),
                    false,
                ),
            );
            account_metas.push(
                anchor_lang::solana_program::instruction::AccountMeta::new_readonly(
                    anchor_lang::Key::key(&self.token_program),
                    false,
                ),
            );
            account_metas.push(
                anchor_lang::solana_program::instruction::AccountMeta::new_readonly(
                    anchor_lang::Key::key(&self.associated_token_program),
                    false,
                ),
            );
            account_metas
        }
    }
    #[automatically_derived]
    impl<'info> anchor_lang::ToAccountInfos<'info> for DecompressV1<'info> {
        fn to_account_infos(
            &self,
        ) -> Vec<anchor_lang::solana_program::account_info::AccountInfo<'info>> {
            let mut account_infos = ::alloc::vec::Vec::new();
            account_infos.push(anchor_lang::ToAccountInfo::to_account_info(&self.voucher));
            account_infos.push(anchor_lang::ToAccountInfo::to_account_info(&self.owner));
            account_infos.push(anchor_lang::ToAccountInfo::to_account_info(
                &self.token_account,
            ));
            account_infos.push(anchor_lang::ToAccountInfo::to_account_info(&self.mint));
            account_infos.push(anchor_lang::ToAccountInfo::to_account_info(
                &self.mint_authority,
            ));
            account_infos.push(anchor_lang::ToAccountInfo::to_account_info(&self.metadata));
            account_infos.push(anchor_lang::ToAccountInfo::to_account_info(
                &self.master_edition,
            ));
            account_infos.push(anchor_lang::ToAccountInfo::to_account_info(
                &self.system_program,
            ));
            account_infos.push(anchor_lang::ToAccountInfo::to_account_info(
                &self.sysvar_rent,
            ));
            account_infos.push(anchor_lang::ToAccountInfo::to_account_info(
                &self.token_metadata_program,
            ));
            account_infos.push(anchor_lang::ToAccountInfo::to_account_info(
                &self.token_program,
            ));
            account_infos.push(anchor_lang::ToAccountInfo::to_account_info(
                &self.associated_token_program,
            ));
            account_infos
        }
    }
}
pub struct Compress<'info> {
    # [account (seeds = [merkle_slab . key () . as_ref ()] , bump ,)]
    /// CHECK: This account is neither written to nor read from.
    pub authority: UncheckedAccount<'info>,
    /// CHECK: This account is not read
    pub merkle_slab: UncheckedAccount<'info>,
    /// CHECK: This account is checked in the instruction
    pub owner: Signer<'info>,
    /// CHECK: This account is chekced in the instruction
    pub delegate: UncheckedAccount<'info>,
    /// CHECK: versioning is handled in the instruction
    #[account(mut)]
    pub token_account: AccountInfo<'info>,
    /// CHECK: versioning is handled in the instruction
    #[account(mut)]
    pub mint: AccountInfo<'info>,
    #[account(mut)]
    pub metadata: Box<Account<'info, TokenMetadata>>,
    #[account(mut)]
    pub master_edition: Box<Account<'info, MasterEdition>>,
    #[account(mut)]
    pub payer: Signer<'info>,
    pub system_program: Program<'info, System>,
    /// CHECK:
    pub token_metadata_program: UncheckedAccount<'info>,
    /// CHECK:
    pub token_program: UncheckedAccount<'info>,
    pub candy_wrapper: Program<'info, Wrapper>,
    pub gummyroll_program: Program<'info, SplCompression>,
}
#[automatically_derived]
impl<'info> anchor_lang::Accounts<'info> for Compress<'info>
where
    'info: 'info,
{
    #[inline(never)]
    fn try_accounts(
        program_id: &anchor_lang::solana_program::pubkey::Pubkey,
        accounts: &mut &[anchor_lang::solana_program::account_info::AccountInfo<'info>],
        ix_data: &[u8],
        __bumps: &mut std::collections::BTreeMap<String, u8>,
        __reallocs: &mut std::collections::BTreeSet<anchor_lang::solana_program::pubkey::Pubkey>,
    ) -> anchor_lang::Result<Self> {
        let authority: UncheckedAccount =
            anchor_lang::Accounts::try_accounts(program_id, accounts, ix_data, __bumps, __reallocs)
                .map_err(|e| e.with_account_name("authority"))?;
        let merkle_slab: UncheckedAccount =
            anchor_lang::Accounts::try_accounts(program_id, accounts, ix_data, __bumps, __reallocs)
                .map_err(|e| e.with_account_name("merkle_slab"))?;
        let owner: Signer =
            anchor_lang::Accounts::try_accounts(program_id, accounts, ix_data, __bumps, __reallocs)
                .map_err(|e| e.with_account_name("owner"))?;
        let delegate: UncheckedAccount =
            anchor_lang::Accounts::try_accounts(program_id, accounts, ix_data, __bumps, __reallocs)
                .map_err(|e| e.with_account_name("delegate"))?;
        let token_account: AccountInfo =
            anchor_lang::Accounts::try_accounts(program_id, accounts, ix_data, __bumps, __reallocs)
                .map_err(|e| e.with_account_name("token_account"))?;
        let mint: AccountInfo =
            anchor_lang::Accounts::try_accounts(program_id, accounts, ix_data, __bumps, __reallocs)
                .map_err(|e| e.with_account_name("mint"))?;
        let metadata: Box<anchor_lang::accounts::account::Account<TokenMetadata>> =
            anchor_lang::Accounts::try_accounts(program_id, accounts, ix_data, __bumps, __reallocs)
                .map_err(|e| e.with_account_name("metadata"))?;
        let master_edition: Box<anchor_lang::accounts::account::Account<MasterEdition>> =
            anchor_lang::Accounts::try_accounts(program_id, accounts, ix_data, __bumps, __reallocs)
                .map_err(|e| e.with_account_name("master_edition"))?;
        let payer: Signer =
            anchor_lang::Accounts::try_accounts(program_id, accounts, ix_data, __bumps, __reallocs)
                .map_err(|e| e.with_account_name("payer"))?;
        let system_program: anchor_lang::accounts::program::Program<System> =
            anchor_lang::Accounts::try_accounts(program_id, accounts, ix_data, __bumps, __reallocs)
                .map_err(|e| e.with_account_name("system_program"))?;
        let token_metadata_program: UncheckedAccount =
            anchor_lang::Accounts::try_accounts(program_id, accounts, ix_data, __bumps, __reallocs)
                .map_err(|e| e.with_account_name("token_metadata_program"))?;
        let token_program: UncheckedAccount =
            anchor_lang::Accounts::try_accounts(program_id, accounts, ix_data, __bumps, __reallocs)
                .map_err(|e| e.with_account_name("token_program"))?;
        let candy_wrapper: anchor_lang::accounts::program::Program<Wrapper> =
            anchor_lang::Accounts::try_accounts(program_id, accounts, ix_data, __bumps, __reallocs)
                .map_err(|e| e.with_account_name("candy_wrapper"))?;
        let gummyroll_program: anchor_lang::accounts::program::Program<SplCompression> =
            anchor_lang::Accounts::try_accounts(program_id, accounts, ix_data, __bumps, __reallocs)
                .map_err(|e| e.with_account_name("gummyroll_program"))?;
        let (__pda_address, __bump) =
            Pubkey::find_program_address(&[merkle_slab.key().as_ref()], &program_id);
        __bumps.insert("authority".to_string(), __bump);
        if authority.key() != __pda_address {
            return Err(anchor_lang::error::Error::from(
                anchor_lang::error::ErrorCode::ConstraintSeeds,
            )
            .with_account_name("authority")
            .with_pubkeys((authority.key(), __pda_address)));
        }
        if !token_account.to_account_info().is_writable {
            return Err(anchor_lang::error::Error::from(
                anchor_lang::error::ErrorCode::ConstraintMut,
            )
            .with_account_name("token_account"));
        }
        if !mint.to_account_info().is_writable {
            return Err(anchor_lang::error::Error::from(
                anchor_lang::error::ErrorCode::ConstraintMut,
            )
            .with_account_name("mint"));
        }
        if !metadata.to_account_info().is_writable {
            return Err(anchor_lang::error::Error::from(
                anchor_lang::error::ErrorCode::ConstraintMut,
            )
            .with_account_name("metadata"));
        }
        if !master_edition.to_account_info().is_writable {
            return Err(anchor_lang::error::Error::from(
                anchor_lang::error::ErrorCode::ConstraintMut,
            )
            .with_account_name("master_edition"));
        }
        if !payer.to_account_info().is_writable {
            return Err(anchor_lang::error::Error::from(
                anchor_lang::error::ErrorCode::ConstraintMut,
            )
            .with_account_name("payer"));
        }
        Ok(Compress {
            authority,
            merkle_slab,
            owner,
            delegate,
            token_account,
            mint,
            metadata,
            master_edition,
            payer,
            system_program,
            token_metadata_program,
            token_program,
            candy_wrapper,
            gummyroll_program,
        })
    }
}
#[automatically_derived]
impl<'info> anchor_lang::ToAccountInfos<'info> for Compress<'info>
where
    'info: 'info,
{
    fn to_account_infos(
        &self,
    ) -> Vec<anchor_lang::solana_program::account_info::AccountInfo<'info>> {
        let mut account_infos = ::alloc::vec::Vec::new();
        account_infos.extend(self.authority.to_account_infos());
        account_infos.extend(self.merkle_slab.to_account_infos());
        account_infos.extend(self.owner.to_account_infos());
        account_infos.extend(self.delegate.to_account_infos());
        account_infos.extend(self.token_account.to_account_infos());
        account_infos.extend(self.mint.to_account_infos());
        account_infos.extend(self.metadata.to_account_infos());
        account_infos.extend(self.master_edition.to_account_infos());
        account_infos.extend(self.payer.to_account_infos());
        account_infos.extend(self.system_program.to_account_infos());
        account_infos.extend(self.token_metadata_program.to_account_infos());
        account_infos.extend(self.token_program.to_account_infos());
        account_infos.extend(self.candy_wrapper.to_account_infos());
        account_infos.extend(self.gummyroll_program.to_account_infos());
        account_infos
    }
}
#[automatically_derived]
impl<'info> anchor_lang::ToAccountMetas for Compress<'info> {
    fn to_account_metas(
        &self,
        is_signer: Option<bool>,
    ) -> Vec<anchor_lang::solana_program::instruction::AccountMeta> {
        let mut account_metas = ::alloc::vec::Vec::new();
        account_metas.extend(self.authority.to_account_metas(None));
        account_metas.extend(self.merkle_slab.to_account_metas(None));
        account_metas.extend(self.owner.to_account_metas(None));
        account_metas.extend(self.delegate.to_account_metas(None));
        account_metas.extend(self.token_account.to_account_metas(None));
        account_metas.extend(self.mint.to_account_metas(None));
        account_metas.extend(self.metadata.to_account_metas(None));
        account_metas.extend(self.master_edition.to_account_metas(None));
        account_metas.extend(self.payer.to_account_metas(None));
        account_metas.extend(self.system_program.to_account_metas(None));
        account_metas.extend(self.token_metadata_program.to_account_metas(None));
        account_metas.extend(self.token_program.to_account_metas(None));
        account_metas.extend(self.candy_wrapper.to_account_metas(None));
        account_metas.extend(self.gummyroll_program.to_account_metas(None));
        account_metas
    }
}
#[automatically_derived]
impl<'info> anchor_lang::AccountsExit<'info> for Compress<'info>
where
    'info: 'info,
{
    fn exit(
        &self,
        program_id: &anchor_lang::solana_program::pubkey::Pubkey,
    ) -> anchor_lang::Result<()> {
        anchor_lang::AccountsExit::exit(&self.token_account, program_id)
            .map_err(|e| e.with_account_name("token_account"))?;
        anchor_lang::AccountsExit::exit(&self.mint, program_id)
            .map_err(|e| e.with_account_name("mint"))?;
        anchor_lang::AccountsExit::exit(&self.metadata, program_id)
            .map_err(|e| e.with_account_name("metadata"))?;
        anchor_lang::AccountsExit::exit(&self.master_edition, program_id)
            .map_err(|e| e.with_account_name("master_edition"))?;
        anchor_lang::AccountsExit::exit(&self.payer, program_id)
            .map_err(|e| e.with_account_name("payer"))?;
        Ok(())
    }
}
/// An internal, Anchor generated module. This is used (as an
/// implementation detail), to generate a struct for a given
/// `#[derive(Accounts)]` implementation, where each field is a Pubkey,
/// instead of an `AccountInfo`. This is useful for clients that want
/// to generate a list of accounts, without explicitly knowing the
/// order all the fields should be in.
///
/// To access the struct in this module, one should use the sibling
/// `accounts` module (also generated), which re-exports this.
pub(crate) mod __client_accounts_compress {
    use super::*;
    use anchor_lang::prelude::borsh;
    /// Generated client accounts for [`Compress`].
    pub struct Compress {
        pub authority: anchor_lang::solana_program::pubkey::Pubkey,
        pub merkle_slab: anchor_lang::solana_program::pubkey::Pubkey,
        pub owner: anchor_lang::solana_program::pubkey::Pubkey,
        pub delegate: anchor_lang::solana_program::pubkey::Pubkey,
        pub token_account: anchor_lang::solana_program::pubkey::Pubkey,
        pub mint: anchor_lang::solana_program::pubkey::Pubkey,
        pub metadata: anchor_lang::solana_program::pubkey::Pubkey,
        pub master_edition: anchor_lang::solana_program::pubkey::Pubkey,
        pub payer: anchor_lang::solana_program::pubkey::Pubkey,
        pub system_program: anchor_lang::solana_program::pubkey::Pubkey,
        pub token_metadata_program: anchor_lang::solana_program::pubkey::Pubkey,
        pub token_program: anchor_lang::solana_program::pubkey::Pubkey,
        pub candy_wrapper: anchor_lang::solana_program::pubkey::Pubkey,
        pub gummyroll_program: anchor_lang::solana_program::pubkey::Pubkey,
    }
    impl borsh::ser::BorshSerialize for Compress
    where
        anchor_lang::solana_program::pubkey::Pubkey: borsh::ser::BorshSerialize,
        anchor_lang::solana_program::pubkey::Pubkey: borsh::ser::BorshSerialize,
        anchor_lang::solana_program::pubkey::Pubkey: borsh::ser::BorshSerialize,
        anchor_lang::solana_program::pubkey::Pubkey: borsh::ser::BorshSerialize,
        anchor_lang::solana_program::pubkey::Pubkey: borsh::ser::BorshSerialize,
        anchor_lang::solana_program::pubkey::Pubkey: borsh::ser::BorshSerialize,
        anchor_lang::solana_program::pubkey::Pubkey: borsh::ser::BorshSerialize,
        anchor_lang::solana_program::pubkey::Pubkey: borsh::ser::BorshSerialize,
        anchor_lang::solana_program::pubkey::Pubkey: borsh::ser::BorshSerialize,
        anchor_lang::solana_program::pubkey::Pubkey: borsh::ser::BorshSerialize,
        anchor_lang::solana_program::pubkey::Pubkey: borsh::ser::BorshSerialize,
        anchor_lang::solana_program::pubkey::Pubkey: borsh::ser::BorshSerialize,
        anchor_lang::solana_program::pubkey::Pubkey: borsh::ser::BorshSerialize,
        anchor_lang::solana_program::pubkey::Pubkey: borsh::ser::BorshSerialize,
    {
        fn serialize<W: borsh::maybestd::io::Write>(
            &self,
            writer: &mut W,
        ) -> ::core::result::Result<(), borsh::maybestd::io::Error> {
            borsh::BorshSerialize::serialize(&self.authority, writer)?;
            borsh::BorshSerialize::serialize(&self.merkle_slab, writer)?;
            borsh::BorshSerialize::serialize(&self.owner, writer)?;
            borsh::BorshSerialize::serialize(&self.delegate, writer)?;
            borsh::BorshSerialize::serialize(&self.token_account, writer)?;
            borsh::BorshSerialize::serialize(&self.mint, writer)?;
            borsh::BorshSerialize::serialize(&self.metadata, writer)?;
            borsh::BorshSerialize::serialize(&self.master_edition, writer)?;
            borsh::BorshSerialize::serialize(&self.payer, writer)?;
            borsh::BorshSerialize::serialize(&self.system_program, writer)?;
            borsh::BorshSerialize::serialize(&self.token_metadata_program, writer)?;
            borsh::BorshSerialize::serialize(&self.token_program, writer)?;
            borsh::BorshSerialize::serialize(&self.candy_wrapper, writer)?;
            borsh::BorshSerialize::serialize(&self.gummyroll_program, writer)?;
            Ok(())
        }
    }
    #[automatically_derived]
    impl anchor_lang::ToAccountMetas for Compress {
        fn to_account_metas(
            &self,
            is_signer: Option<bool>,
        ) -> Vec<anchor_lang::solana_program::instruction::AccountMeta> {
            let mut account_metas = ::alloc::vec::Vec::new();
            account_metas.push(
                anchor_lang::solana_program::instruction::AccountMeta::new_readonly(
                    self.authority,
                    false,
                ),
            );
            account_metas.push(
                anchor_lang::solana_program::instruction::AccountMeta::new_readonly(
                    self.merkle_slab,
                    false,
                ),
            );
            account_metas.push(
                anchor_lang::solana_program::instruction::AccountMeta::new_readonly(
                    self.owner, true,
                ),
            );
            account_metas.push(
                anchor_lang::solana_program::instruction::AccountMeta::new_readonly(
                    self.delegate,
                    false,
                ),
            );
            account_metas.push(anchor_lang::solana_program::instruction::AccountMeta::new(
                self.token_account,
                false,
            ));
            account_metas.push(anchor_lang::solana_program::instruction::AccountMeta::new(
                self.mint, false,
            ));
            account_metas.push(anchor_lang::solana_program::instruction::AccountMeta::new(
                self.metadata,
                false,
            ));
            account_metas.push(anchor_lang::solana_program::instruction::AccountMeta::new(
                self.master_edition,
                false,
            ));
            account_metas.push(anchor_lang::solana_program::instruction::AccountMeta::new(
                self.payer, true,
            ));
            account_metas.push(
                anchor_lang::solana_program::instruction::AccountMeta::new_readonly(
                    self.system_program,
                    false,
                ),
            );
            account_metas.push(
                anchor_lang::solana_program::instruction::AccountMeta::new_readonly(
                    self.token_metadata_program,
                    false,
                ),
            );
            account_metas.push(
                anchor_lang::solana_program::instruction::AccountMeta::new_readonly(
                    self.token_program,
                    false,
                ),
            );
            account_metas.push(
                anchor_lang::solana_program::instruction::AccountMeta::new_readonly(
                    self.candy_wrapper,
                    false,
                ),
            );
            account_metas.push(
                anchor_lang::solana_program::instruction::AccountMeta::new_readonly(
                    self.gummyroll_program,
                    false,
                ),
            );
            account_metas
        }
    }
}
/// An internal, Anchor generated module. This is used (as an
/// implementation detail), to generate a CPI struct for a given
/// `#[derive(Accounts)]` implementation, where each field is an
/// AccountInfo.
///
/// To access the struct in this module, one should use the sibling
/// [`cpi::accounts`] module (also generated), which re-exports this.
pub(crate) mod __cpi_client_accounts_compress {
    use super::*;
    /// Generated CPI struct of the accounts for [`Compress`].
    pub struct Compress<'info> {
        pub authority: anchor_lang::solana_program::account_info::AccountInfo<'info>,
        pub merkle_slab: anchor_lang::solana_program::account_info::AccountInfo<'info>,
        pub owner: anchor_lang::solana_program::account_info::AccountInfo<'info>,
        pub delegate: anchor_lang::solana_program::account_info::AccountInfo<'info>,
        pub token_account: anchor_lang::solana_program::account_info::AccountInfo<'info>,
        pub mint: anchor_lang::solana_program::account_info::AccountInfo<'info>,
        pub metadata: anchor_lang::solana_program::account_info::AccountInfo<'info>,
        pub master_edition: anchor_lang::solana_program::account_info::AccountInfo<'info>,
        pub payer: anchor_lang::solana_program::account_info::AccountInfo<'info>,
        pub system_program: anchor_lang::solana_program::account_info::AccountInfo<'info>,
        pub token_metadata_program: anchor_lang::solana_program::account_info::AccountInfo<'info>,
        pub token_program: anchor_lang::solana_program::account_info::AccountInfo<'info>,
        pub candy_wrapper: anchor_lang::solana_program::account_info::AccountInfo<'info>,
        pub gummyroll_program: anchor_lang::solana_program::account_info::AccountInfo<'info>,
    }
    #[automatically_derived]
    impl<'info> anchor_lang::ToAccountMetas for Compress<'info> {
        fn to_account_metas(
            &self,
            is_signer: Option<bool>,
        ) -> Vec<anchor_lang::solana_program::instruction::AccountMeta> {
            let mut account_metas = ::alloc::vec::Vec::new();
            account_metas.push(
                anchor_lang::solana_program::instruction::AccountMeta::new_readonly(
                    anchor_lang::Key::key(&self.authority),
                    false,
                ),
            );
            account_metas.push(
                anchor_lang::solana_program::instruction::AccountMeta::new_readonly(
                    anchor_lang::Key::key(&self.merkle_slab),
                    false,
                ),
            );
            account_metas.push(
                anchor_lang::solana_program::instruction::AccountMeta::new_readonly(
                    anchor_lang::Key::key(&self.owner),
                    true,
                ),
            );
            account_metas.push(
                anchor_lang::solana_program::instruction::AccountMeta::new_readonly(
                    anchor_lang::Key::key(&self.delegate),
                    false,
                ),
            );
            account_metas.push(anchor_lang::solana_program::instruction::AccountMeta::new(
                anchor_lang::Key::key(&self.token_account),
                false,
            ));
            account_metas.push(anchor_lang::solana_program::instruction::AccountMeta::new(
                anchor_lang::Key::key(&self.mint),
                false,
            ));
            account_metas.push(anchor_lang::solana_program::instruction::AccountMeta::new(
                anchor_lang::Key::key(&self.metadata),
                false,
            ));
            account_metas.push(anchor_lang::solana_program::instruction::AccountMeta::new(
                anchor_lang::Key::key(&self.master_edition),
                false,
            ));
            account_metas.push(anchor_lang::solana_program::instruction::AccountMeta::new(
                anchor_lang::Key::key(&self.payer),
                true,
            ));
            account_metas.push(
                anchor_lang::solana_program::instruction::AccountMeta::new_readonly(
                    anchor_lang::Key::key(&self.system_program),
                    false,
                ),
            );
            account_metas.push(
                anchor_lang::solana_program::instruction::AccountMeta::new_readonly(
                    anchor_lang::Key::key(&self.token_metadata_program),
                    false,
                ),
            );
            account_metas.push(
                anchor_lang::solana_program::instruction::AccountMeta::new_readonly(
                    anchor_lang::Key::key(&self.token_program),
                    false,
                ),
            );
            account_metas.push(
                anchor_lang::solana_program::instruction::AccountMeta::new_readonly(
                    anchor_lang::Key::key(&self.candy_wrapper),
                    false,
                ),
            );
            account_metas.push(
                anchor_lang::solana_program::instruction::AccountMeta::new_readonly(
                    anchor_lang::Key::key(&self.gummyroll_program),
                    false,
                ),
            );
            account_metas
        }
    }
    #[automatically_derived]
    impl<'info> anchor_lang::ToAccountInfos<'info> for Compress<'info> {
        fn to_account_infos(
            &self,
        ) -> Vec<anchor_lang::solana_program::account_info::AccountInfo<'info>> {
            let mut account_infos = ::alloc::vec::Vec::new();
            account_infos.push(anchor_lang::ToAccountInfo::to_account_info(&self.authority));
            account_infos.push(anchor_lang::ToAccountInfo::to_account_info(
                &self.merkle_slab,
            ));
            account_infos.push(anchor_lang::ToAccountInfo::to_account_info(&self.owner));
            account_infos.push(anchor_lang::ToAccountInfo::to_account_info(&self.delegate));
            account_infos.push(anchor_lang::ToAccountInfo::to_account_info(
                &self.token_account,
            ));
            account_infos.push(anchor_lang::ToAccountInfo::to_account_info(&self.mint));
            account_infos.push(anchor_lang::ToAccountInfo::to_account_info(&self.metadata));
            account_infos.push(anchor_lang::ToAccountInfo::to_account_info(
                &self.master_edition,
            ));
            account_infos.push(anchor_lang::ToAccountInfo::to_account_info(&self.payer));
            account_infos.push(anchor_lang::ToAccountInfo::to_account_info(
                &self.system_program,
            ));
            account_infos.push(anchor_lang::ToAccountInfo::to_account_info(
                &self.token_metadata_program,
            ));
            account_infos.push(anchor_lang::ToAccountInfo::to_account_info(
                &self.token_program,
            ));
            account_infos.push(anchor_lang::ToAccountInfo::to_account_info(
                &self.candy_wrapper,
            ));
            account_infos.push(anchor_lang::ToAccountInfo::to_account_info(
                &self.gummyroll_program,
            ));
            account_infos
        }
    }
}
pub struct SetMintRequest<'info> {
    # [account (init_if_needed , space = MINT_REQUEST_SIZE , seeds = [merkle_slab . key () . as_ref () , mint_authority . key () . as_ref ()] , payer = payer , bump)]
    pub mint_authority_request: Account<'info, MintRequest>,
    #[account(mut)]
    pub payer: Signer<'info>,
    pub mint_authority: Signer<'info>,
    # [account (mut , seeds = [merkle_slab . key () . as_ref ()] , bump)]
    pub tree_authority: Account<'info, TreeConfig>,
    pub system_program: Program<'info, System>,
    /// CHECK: this account is neither read from or written to
    pub merkle_slab: UncheckedAccount<'info>,
}
#[automatically_derived]
impl<'info> anchor_lang::Accounts<'info> for SetMintRequest<'info>
where
    'info: 'info,
{
    #[inline(never)]
    fn try_accounts(
        program_id: &anchor_lang::solana_program::pubkey::Pubkey,
        accounts: &mut &[anchor_lang::solana_program::account_info::AccountInfo<'info>],
        ix_data: &[u8],
        __bumps: &mut std::collections::BTreeMap<String, u8>,
        __reallocs: &mut std::collections::BTreeSet<anchor_lang::solana_program::pubkey::Pubkey>,
    ) -> anchor_lang::Result<Self> {
        if accounts.is_empty() {
            return Err(anchor_lang::error::ErrorCode::AccountNotEnoughKeys.into());
        }
        let mint_authority_request = &accounts[0];
        *accounts = &accounts[1..];
        let payer: Signer =
            anchor_lang::Accounts::try_accounts(program_id, accounts, ix_data, __bumps, __reallocs)
                .map_err(|e| e.with_account_name("payer"))?;
        let mint_authority: Signer =
            anchor_lang::Accounts::try_accounts(program_id, accounts, ix_data, __bumps, __reallocs)
                .map_err(|e| e.with_account_name("mint_authority"))?;
        let tree_authority: anchor_lang::accounts::account::Account<TreeConfig> =
            anchor_lang::Accounts::try_accounts(program_id, accounts, ix_data, __bumps, __reallocs)
                .map_err(|e| e.with_account_name("tree_authority"))?;
        let system_program: anchor_lang::accounts::program::Program<System> =
            anchor_lang::Accounts::try_accounts(program_id, accounts, ix_data, __bumps, __reallocs)
                .map_err(|e| e.with_account_name("system_program"))?;
        let merkle_slab: UncheckedAccount =
            anchor_lang::Accounts::try_accounts(program_id, accounts, ix_data, __bumps, __reallocs)
                .map_err(|e| e.with_account_name("merkle_slab"))?;
        let __anchor_rent = Rent::get()?;
        let (__pda_address, __bump) = Pubkey::find_program_address(
            &[merkle_slab.key().as_ref(), mint_authority.key().as_ref()],
            program_id,
        );
        __bumps.insert("mint_authority_request".to_string(), __bump);
        let mint_authority_request = {
            let actual_field = mint_authority_request.to_account_info();
            let actual_owner = actual_field.owner;
            let space = MINT_REQUEST_SIZE;
            let pa: anchor_lang::accounts::account::Account<MintRequest> = if !true
                || actual_owner == &anchor_lang::solana_program::system_program::ID
            {
                let payer = payer.to_account_info();
                let __current_lamports = mint_authority_request.lamports();
                if __current_lamports == 0 {
                    let lamports = __anchor_rent.minimum_balance(space);
                    let cpi_accounts = anchor_lang::system_program::CreateAccount {
                        from: payer.to_account_info(),
                        to: mint_authority_request.to_account_info(),
                    };
                    let cpi_context = anchor_lang::context::CpiContext::new(
                        system_program.to_account_info(),
                        cpi_accounts,
                    );
                    anchor_lang::system_program::create_account(
                        cpi_context.with_signer(&[&[
                            merkle_slab.key().as_ref(),
                            mint_authority.key().as_ref(),
                            &[__bump][..],
                        ][..]]),
                        lamports,
                        space as u64,
                        program_id,
                    )?;
                } else {
                    let required_lamports = __anchor_rent
                        .minimum_balance(space)
                        .max(1)
                        .saturating_sub(__current_lamports);
                    if required_lamports > 0 {
                        let cpi_accounts = anchor_lang::system_program::Transfer {
                            from: payer.to_account_info(),
                            to: mint_authority_request.to_account_info(),
                        };
                        let cpi_context = anchor_lang::context::CpiContext::new(
                            system_program.to_account_info(),
                            cpi_accounts,
                        );
                        anchor_lang::system_program::transfer(cpi_context, required_lamports)?;
                    }
                    let cpi_accounts = anchor_lang::system_program::Allocate {
                        account_to_allocate: mint_authority_request.to_account_info(),
                    };
                    let cpi_context = anchor_lang::context::CpiContext::new(
                        system_program.to_account_info(),
                        cpi_accounts,
                    );
                    anchor_lang::system_program::allocate(
                        cpi_context.with_signer(&[&[
                            merkle_slab.key().as_ref(),
                            mint_authority.key().as_ref(),
                            &[__bump][..],
                        ][..]]),
                        space as u64,
                    )?;
                    let cpi_accounts = anchor_lang::system_program::Assign {
                        account_to_assign: mint_authority_request.to_account_info(),
                    };
                    let cpi_context = anchor_lang::context::CpiContext::new(
                        system_program.to_account_info(),
                        cpi_accounts,
                    );
                    anchor_lang::system_program::assign(
                        cpi_context.with_signer(&[&[
                            merkle_slab.key().as_ref(),
                            mint_authority.key().as_ref(),
                            &[__bump][..],
                        ][..]]),
                        program_id,
                    )?;
                }
                anchor_lang::accounts::account::Account::try_from_unchecked(&mint_authority_request)
                    .map_err(|e| e.with_account_name("mint_authority_request"))?
            } else {
                anchor_lang::accounts::account::Account::try_from(&mint_authority_request)
                    .map_err(|e| e.with_account_name("mint_authority_request"))?
            };
            if true {
                if space != actual_field.data_len() {
                    return Err(anchor_lang::error::Error::from(
                        anchor_lang::error::ErrorCode::ConstraintSpace,
                    )
                    .with_account_name("mint_authority_request")
                    .with_values((space, actual_field.data_len())));
                }
                if actual_owner != program_id {
                    return Err(anchor_lang::error::Error::from(
                        anchor_lang::error::ErrorCode::ConstraintOwner,
                    )
                    .with_account_name("mint_authority_request")
                    .with_pubkeys((*actual_owner, *program_id)));
                }
                {
                    let required_lamports = __anchor_rent.minimum_balance(space);
                    if pa.to_account_info().lamports() < required_lamports {
                        return Err(anchor_lang::error::Error::from(
                            anchor_lang::error::ErrorCode::ConstraintRentExempt,
                        )
                        .with_account_name("mint_authority_request"));
                    }
                }
            }
            pa
        };
        if mint_authority_request.key() != __pda_address {
            return Err(anchor_lang::error::Error::from(
                anchor_lang::error::ErrorCode::ConstraintSeeds,
            )
            .with_account_name("mint_authority_request")
            .with_pubkeys((mint_authority_request.key(), __pda_address)));
        }
        if !mint_authority_request.to_account_info().is_writable {
            return Err(anchor_lang::error::Error::from(
                anchor_lang::error::ErrorCode::ConstraintMut,
            )
            .with_account_name("mint_authority_request"));
        }
        if !__anchor_rent.is_exempt(
            mint_authority_request.to_account_info().lamports(),
            mint_authority_request.to_account_info().try_data_len()?,
        ) {
            return Err(anchor_lang::error::Error::from(
                anchor_lang::error::ErrorCode::ConstraintRentExempt,
            )
            .with_account_name("mint_authority_request"));
        }
        if !payer.to_account_info().is_writable {
            return Err(anchor_lang::error::Error::from(
                anchor_lang::error::ErrorCode::ConstraintMut,
            )
            .with_account_name("payer"));
        }
        let (__pda_address, __bump) =
            Pubkey::find_program_address(&[merkle_slab.key().as_ref()], &program_id);
        __bumps.insert("tree_authority".to_string(), __bump);
        if tree_authority.key() != __pda_address {
            return Err(anchor_lang::error::Error::from(
                anchor_lang::error::ErrorCode::ConstraintSeeds,
            )
            .with_account_name("tree_authority")
            .with_pubkeys((tree_authority.key(), __pda_address)));
        }
        if !tree_authority.to_account_info().is_writable {
            return Err(anchor_lang::error::Error::from(
                anchor_lang::error::ErrorCode::ConstraintMut,
            )
            .with_account_name("tree_authority"));
        }
        Ok(SetMintRequest {
            mint_authority_request,
            payer,
            mint_authority,
            tree_authority,
            system_program,
            merkle_slab,
        })
    }
}
#[automatically_derived]
impl<'info> anchor_lang::ToAccountInfos<'info> for SetMintRequest<'info>
where
    'info: 'info,
{
    fn to_account_infos(
        &self,
    ) -> Vec<anchor_lang::solana_program::account_info::AccountInfo<'info>> {
        let mut account_infos = ::alloc::vec::Vec::new();
        account_infos.extend(self.mint_authority_request.to_account_infos());
        account_infos.extend(self.payer.to_account_infos());
        account_infos.extend(self.mint_authority.to_account_infos());
        account_infos.extend(self.tree_authority.to_account_infos());
        account_infos.extend(self.system_program.to_account_infos());
        account_infos.extend(self.merkle_slab.to_account_infos());
        account_infos
    }
}
#[automatically_derived]
impl<'info> anchor_lang::ToAccountMetas for SetMintRequest<'info> {
    fn to_account_metas(
        &self,
        is_signer: Option<bool>,
    ) -> Vec<anchor_lang::solana_program::instruction::AccountMeta> {
        let mut account_metas = ::alloc::vec::Vec::new();
        account_metas.extend(self.mint_authority_request.to_account_metas(None));
        account_metas.extend(self.payer.to_account_metas(None));
        account_metas.extend(self.mint_authority.to_account_metas(None));
        account_metas.extend(self.tree_authority.to_account_metas(None));
        account_metas.extend(self.system_program.to_account_metas(None));
        account_metas.extend(self.merkle_slab.to_account_metas(None));
        account_metas
    }
}
#[automatically_derived]
impl<'info> anchor_lang::AccountsExit<'info> for SetMintRequest<'info>
where
    'info: 'info,
{
    fn exit(
        &self,
        program_id: &anchor_lang::solana_program::pubkey::Pubkey,
    ) -> anchor_lang::Result<()> {
        anchor_lang::AccountsExit::exit(&self.mint_authority_request, program_id)
            .map_err(|e| e.with_account_name("mint_authority_request"))?;
        anchor_lang::AccountsExit::exit(&self.payer, program_id)
            .map_err(|e| e.with_account_name("payer"))?;
        anchor_lang::AccountsExit::exit(&self.tree_authority, program_id)
            .map_err(|e| e.with_account_name("tree_authority"))?;
        Ok(())
    }
}
/// An internal, Anchor generated module. This is used (as an
/// implementation detail), to generate a struct for a given
/// `#[derive(Accounts)]` implementation, where each field is a Pubkey,
/// instead of an `AccountInfo`. This is useful for clients that want
/// to generate a list of accounts, without explicitly knowing the
/// order all the fields should be in.
///
/// To access the struct in this module, one should use the sibling
/// `accounts` module (also generated), which re-exports this.
pub(crate) mod __client_accounts_set_mint_request {
    use super::*;
    use anchor_lang::prelude::borsh;
    /// Generated client accounts for [`SetMintRequest`].
    pub struct SetMintRequest {
        pub mint_authority_request: anchor_lang::solana_program::pubkey::Pubkey,
        pub payer: anchor_lang::solana_program::pubkey::Pubkey,
        pub mint_authority: anchor_lang::solana_program::pubkey::Pubkey,
        pub tree_authority: anchor_lang::solana_program::pubkey::Pubkey,
        pub system_program: anchor_lang::solana_program::pubkey::Pubkey,
        pub merkle_slab: anchor_lang::solana_program::pubkey::Pubkey,
    }
    impl borsh::ser::BorshSerialize for SetMintRequest
    where
        anchor_lang::solana_program::pubkey::Pubkey: borsh::ser::BorshSerialize,
        anchor_lang::solana_program::pubkey::Pubkey: borsh::ser::BorshSerialize,
        anchor_lang::solana_program::pubkey::Pubkey: borsh::ser::BorshSerialize,
        anchor_lang::solana_program::pubkey::Pubkey: borsh::ser::BorshSerialize,
        anchor_lang::solana_program::pubkey::Pubkey: borsh::ser::BorshSerialize,
        anchor_lang::solana_program::pubkey::Pubkey: borsh::ser::BorshSerialize,
    {
        fn serialize<W: borsh::maybestd::io::Write>(
            &self,
            writer: &mut W,
        ) -> ::core::result::Result<(), borsh::maybestd::io::Error> {
            borsh::BorshSerialize::serialize(&self.mint_authority_request, writer)?;
            borsh::BorshSerialize::serialize(&self.payer, writer)?;
            borsh::BorshSerialize::serialize(&self.mint_authority, writer)?;
            borsh::BorshSerialize::serialize(&self.tree_authority, writer)?;
            borsh::BorshSerialize::serialize(&self.system_program, writer)?;
            borsh::BorshSerialize::serialize(&self.merkle_slab, writer)?;
            Ok(())
        }
    }
    #[automatically_derived]
    impl anchor_lang::ToAccountMetas for SetMintRequest {
        fn to_account_metas(
            &self,
            is_signer: Option<bool>,
        ) -> Vec<anchor_lang::solana_program::instruction::AccountMeta> {
            let mut account_metas = ::alloc::vec::Vec::new();
            account_metas.push(anchor_lang::solana_program::instruction::AccountMeta::new(
                self.mint_authority_request,
                false,
            ));
            account_metas.push(anchor_lang::solana_program::instruction::AccountMeta::new(
                self.payer, true,
            ));
            account_metas.push(
                anchor_lang::solana_program::instruction::AccountMeta::new_readonly(
                    self.mint_authority,
                    true,
                ),
            );
            account_metas.push(anchor_lang::solana_program::instruction::AccountMeta::new(
                self.tree_authority,
                false,
            ));
            account_metas.push(
                anchor_lang::solana_program::instruction::AccountMeta::new_readonly(
                    self.system_program,
                    false,
                ),
            );
            account_metas.push(
                anchor_lang::solana_program::instruction::AccountMeta::new_readonly(
                    self.merkle_slab,
                    false,
                ),
            );
            account_metas
        }
    }
}
/// An internal, Anchor generated module. This is used (as an
/// implementation detail), to generate a CPI struct for a given
/// `#[derive(Accounts)]` implementation, where each field is an
/// AccountInfo.
///
/// To access the struct in this module, one should use the sibling
/// [`cpi::accounts`] module (also generated), which re-exports this.
pub(crate) mod __cpi_client_accounts_set_mint_request {
    use super::*;
    /// Generated CPI struct of the accounts for [`SetMintRequest`].
    pub struct SetMintRequest<'info> {
        pub mint_authority_request: anchor_lang::solana_program::account_info::AccountInfo<'info>,
        pub payer: anchor_lang::solana_program::account_info::AccountInfo<'info>,
        pub mint_authority: anchor_lang::solana_program::account_info::AccountInfo<'info>,
        pub tree_authority: anchor_lang::solana_program::account_info::AccountInfo<'info>,
        pub system_program: anchor_lang::solana_program::account_info::AccountInfo<'info>,
        pub merkle_slab: anchor_lang::solana_program::account_info::AccountInfo<'info>,
    }
    #[automatically_derived]
    impl<'info> anchor_lang::ToAccountMetas for SetMintRequest<'info> {
        fn to_account_metas(
            &self,
            is_signer: Option<bool>,
        ) -> Vec<anchor_lang::solana_program::instruction::AccountMeta> {
            let mut account_metas = ::alloc::vec::Vec::new();
            account_metas.push(anchor_lang::solana_program::instruction::AccountMeta::new(
                anchor_lang::Key::key(&self.mint_authority_request),
                false,
            ));
            account_metas.push(anchor_lang::solana_program::instruction::AccountMeta::new(
                anchor_lang::Key::key(&self.payer),
                true,
            ));
            account_metas.push(
                anchor_lang::solana_program::instruction::AccountMeta::new_readonly(
                    anchor_lang::Key::key(&self.mint_authority),
                    true,
                ),
            );
            account_metas.push(anchor_lang::solana_program::instruction::AccountMeta::new(
                anchor_lang::Key::key(&self.tree_authority),
                false,
            ));
            account_metas.push(
                anchor_lang::solana_program::instruction::AccountMeta::new_readonly(
                    anchor_lang::Key::key(&self.system_program),
                    false,
                ),
            );
            account_metas.push(
                anchor_lang::solana_program::instruction::AccountMeta::new_readonly(
                    anchor_lang::Key::key(&self.merkle_slab),
                    false,
                ),
            );
            account_metas
        }
    }
    #[automatically_derived]
    impl<'info> anchor_lang::ToAccountInfos<'info> for SetMintRequest<'info> {
        fn to_account_infos(
            &self,
        ) -> Vec<anchor_lang::solana_program::account_info::AccountInfo<'info>> {
            let mut account_infos = ::alloc::vec::Vec::new();
            account_infos.push(anchor_lang::ToAccountInfo::to_account_info(
                &self.mint_authority_request,
            ));
            account_infos.push(anchor_lang::ToAccountInfo::to_account_info(&self.payer));
            account_infos.push(anchor_lang::ToAccountInfo::to_account_info(
                &self.mint_authority,
            ));
            account_infos.push(anchor_lang::ToAccountInfo::to_account_info(
                &self.tree_authority,
            ));
            account_infos.push(anchor_lang::ToAccountInfo::to_account_info(
                &self.system_program,
            ));
            account_infos.push(anchor_lang::ToAccountInfo::to_account_info(
                &self.merkle_slab,
            ));
            account_infos
        }
    }
}
pub struct SetDefaultMintRequest<'info> {
    # [account (init_if_needed , space = MINT_REQUEST_SIZE , seeds = [merkle_slab . key () . as_ref () , tree_authority . key () . as_ref ()] , payer = payer , bump)]
    pub mint_authority_request: Account<'info, MintRequest>,
    #[account(mut)]
    pub payer: Signer<'info>,
    pub creator: Signer<'info>,
    # [account (mut , seeds = [merkle_slab . key () . as_ref ()] , bump , has_one = creator ,)]
    pub tree_authority: Account<'info, TreeConfig>,
    pub system_program: Program<'info, System>,
    /// CHECK: this account is neither read from or written to
    pub merkle_slab: UncheckedAccount<'info>,
}
#[automatically_derived]
impl<'info> anchor_lang::Accounts<'info> for SetDefaultMintRequest<'info>
where
    'info: 'info,
{
    #[inline(never)]
    fn try_accounts(
        program_id: &anchor_lang::solana_program::pubkey::Pubkey,
        accounts: &mut &[anchor_lang::solana_program::account_info::AccountInfo<'info>],
        ix_data: &[u8],
        __bumps: &mut std::collections::BTreeMap<String, u8>,
        __reallocs: &mut std::collections::BTreeSet<anchor_lang::solana_program::pubkey::Pubkey>,
    ) -> anchor_lang::Result<Self> {
        if accounts.is_empty() {
            return Err(anchor_lang::error::ErrorCode::AccountNotEnoughKeys.into());
        }
        let mint_authority_request = &accounts[0];
        *accounts = &accounts[1..];
        let payer: Signer =
            anchor_lang::Accounts::try_accounts(program_id, accounts, ix_data, __bumps, __reallocs)
                .map_err(|e| e.with_account_name("payer"))?;
        let creator: Signer =
            anchor_lang::Accounts::try_accounts(program_id, accounts, ix_data, __bumps, __reallocs)
                .map_err(|e| e.with_account_name("creator"))?;
        let tree_authority: anchor_lang::accounts::account::Account<TreeConfig> =
            anchor_lang::Accounts::try_accounts(program_id, accounts, ix_data, __bumps, __reallocs)
                .map_err(|e| e.with_account_name("tree_authority"))?;
        let system_program: anchor_lang::accounts::program::Program<System> =
            anchor_lang::Accounts::try_accounts(program_id, accounts, ix_data, __bumps, __reallocs)
                .map_err(|e| e.with_account_name("system_program"))?;
        let merkle_slab: UncheckedAccount =
            anchor_lang::Accounts::try_accounts(program_id, accounts, ix_data, __bumps, __reallocs)
                .map_err(|e| e.with_account_name("merkle_slab"))?;
        let __anchor_rent = Rent::get()?;
        let (__pda_address, __bump) = Pubkey::find_program_address(
            &[merkle_slab.key().as_ref(), tree_authority.key().as_ref()],
            program_id,
        );
        __bumps.insert("mint_authority_request".to_string(), __bump);
        let mint_authority_request = {
            let actual_field = mint_authority_request.to_account_info();
            let actual_owner = actual_field.owner;
            let space = MINT_REQUEST_SIZE;
            let pa: anchor_lang::accounts::account::Account<MintRequest> = if !true
                || actual_owner == &anchor_lang::solana_program::system_program::ID
            {
                let payer = payer.to_account_info();
                let __current_lamports = mint_authority_request.lamports();
                if __current_lamports == 0 {
                    let lamports = __anchor_rent.minimum_balance(space);
                    let cpi_accounts = anchor_lang::system_program::CreateAccount {
                        from: payer.to_account_info(),
                        to: mint_authority_request.to_account_info(),
                    };
                    let cpi_context = anchor_lang::context::CpiContext::new(
                        system_program.to_account_info(),
                        cpi_accounts,
                    );
                    anchor_lang::system_program::create_account(
                        cpi_context.with_signer(&[&[
                            merkle_slab.key().as_ref(),
                            tree_authority.key().as_ref(),
                            &[__bump][..],
                        ][..]]),
                        lamports,
                        space as u64,
                        program_id,
                    )?;
                } else {
                    let required_lamports = __anchor_rent
                        .minimum_balance(space)
                        .max(1)
                        .saturating_sub(__current_lamports);
                    if required_lamports > 0 {
                        let cpi_accounts = anchor_lang::system_program::Transfer {
                            from: payer.to_account_info(),
                            to: mint_authority_request.to_account_info(),
                        };
                        let cpi_context = anchor_lang::context::CpiContext::new(
                            system_program.to_account_info(),
                            cpi_accounts,
                        );
                        anchor_lang::system_program::transfer(cpi_context, required_lamports)?;
                    }
                    let cpi_accounts = anchor_lang::system_program::Allocate {
                        account_to_allocate: mint_authority_request.to_account_info(),
                    };
                    let cpi_context = anchor_lang::context::CpiContext::new(
                        system_program.to_account_info(),
                        cpi_accounts,
                    );
                    anchor_lang::system_program::allocate(
                        cpi_context.with_signer(&[&[
                            merkle_slab.key().as_ref(),
                            tree_authority.key().as_ref(),
                            &[__bump][..],
                        ][..]]),
                        space as u64,
                    )?;
                    let cpi_accounts = anchor_lang::system_program::Assign {
                        account_to_assign: mint_authority_request.to_account_info(),
                    };
                    let cpi_context = anchor_lang::context::CpiContext::new(
                        system_program.to_account_info(),
                        cpi_accounts,
                    );
                    anchor_lang::system_program::assign(
                        cpi_context.with_signer(&[&[
                            merkle_slab.key().as_ref(),
                            tree_authority.key().as_ref(),
                            &[__bump][..],
                        ][..]]),
                        program_id,
                    )?;
                }
                anchor_lang::accounts::account::Account::try_from_unchecked(&mint_authority_request)
                    .map_err(|e| e.with_account_name("mint_authority_request"))?
            } else {
                anchor_lang::accounts::account::Account::try_from(&mint_authority_request)
                    .map_err(|e| e.with_account_name("mint_authority_request"))?
            };
            if true {
                if space != actual_field.data_len() {
                    return Err(anchor_lang::error::Error::from(
                        anchor_lang::error::ErrorCode::ConstraintSpace,
                    )
                    .with_account_name("mint_authority_request")
                    .with_values((space, actual_field.data_len())));
                }
                if actual_owner != program_id {
                    return Err(anchor_lang::error::Error::from(
                        anchor_lang::error::ErrorCode::ConstraintOwner,
                    )
                    .with_account_name("mint_authority_request")
                    .with_pubkeys((*actual_owner, *program_id)));
                }
                {
                    let required_lamports = __anchor_rent.minimum_balance(space);
                    if pa.to_account_info().lamports() < required_lamports {
                        return Err(anchor_lang::error::Error::from(
                            anchor_lang::error::ErrorCode::ConstraintRentExempt,
                        )
                        .with_account_name("mint_authority_request"));
                    }
                }
            }
            pa
        };
        if mint_authority_request.key() != __pda_address {
            return Err(anchor_lang::error::Error::from(
                anchor_lang::error::ErrorCode::ConstraintSeeds,
            )
            .with_account_name("mint_authority_request")
            .with_pubkeys((mint_authority_request.key(), __pda_address)));
        }
        if !mint_authority_request.to_account_info().is_writable {
            return Err(anchor_lang::error::Error::from(
                anchor_lang::error::ErrorCode::ConstraintMut,
            )
            .with_account_name("mint_authority_request"));
        }
        if !__anchor_rent.is_exempt(
            mint_authority_request.to_account_info().lamports(),
            mint_authority_request.to_account_info().try_data_len()?,
        ) {
            return Err(anchor_lang::error::Error::from(
                anchor_lang::error::ErrorCode::ConstraintRentExempt,
            )
            .with_account_name("mint_authority_request"));
        }
        if !payer.to_account_info().is_writable {
            return Err(anchor_lang::error::Error::from(
                anchor_lang::error::ErrorCode::ConstraintMut,
            )
            .with_account_name("payer"));
        }
        let (__pda_address, __bump) =
            Pubkey::find_program_address(&[merkle_slab.key().as_ref()], &program_id);
        __bumps.insert("tree_authority".to_string(), __bump);
        if tree_authority.key() != __pda_address {
            return Err(anchor_lang::error::Error::from(
                anchor_lang::error::ErrorCode::ConstraintSeeds,
            )
            .with_account_name("tree_authority")
            .with_pubkeys((tree_authority.key(), __pda_address)));
        }
        if !tree_authority.to_account_info().is_writable {
            return Err(anchor_lang::error::Error::from(
                anchor_lang::error::ErrorCode::ConstraintMut,
            )
            .with_account_name("tree_authority"));
        }
        {
            let my_key = tree_authority.creator;
            let target_key = creator.key();
            if my_key != target_key {
                return Err(anchor_lang::error::Error::from(
                    anchor_lang::error::ErrorCode::ConstraintHasOne,
                )
                .with_account_name("tree_authority")
                .with_pubkeys((my_key, target_key)));
            }
        }
        Ok(SetDefaultMintRequest {
            mint_authority_request,
            payer,
            creator,
            tree_authority,
            system_program,
            merkle_slab,
        })
    }
}
#[automatically_derived]
impl<'info> anchor_lang::ToAccountInfos<'info> for SetDefaultMintRequest<'info>
where
    'info: 'info,
{
    fn to_account_infos(
        &self,
    ) -> Vec<anchor_lang::solana_program::account_info::AccountInfo<'info>> {
        let mut account_infos = ::alloc::vec::Vec::new();
        account_infos.extend(self.mint_authority_request.to_account_infos());
        account_infos.extend(self.payer.to_account_infos());
        account_infos.extend(self.creator.to_account_infos());
        account_infos.extend(self.tree_authority.to_account_infos());
        account_infos.extend(self.system_program.to_account_infos());
        account_infos.extend(self.merkle_slab.to_account_infos());
        account_infos
    }
}
#[automatically_derived]
impl<'info> anchor_lang::ToAccountMetas for SetDefaultMintRequest<'info> {
    fn to_account_metas(
        &self,
        is_signer: Option<bool>,
    ) -> Vec<anchor_lang::solana_program::instruction::AccountMeta> {
        let mut account_metas = ::alloc::vec::Vec::new();
        account_metas.extend(self.mint_authority_request.to_account_metas(None));
        account_metas.extend(self.payer.to_account_metas(None));
        account_metas.extend(self.creator.to_account_metas(None));
        account_metas.extend(self.tree_authority.to_account_metas(None));
        account_metas.extend(self.system_program.to_account_metas(None));
        account_metas.extend(self.merkle_slab.to_account_metas(None));
        account_metas
    }
}
#[automatically_derived]
impl<'info> anchor_lang::AccountsExit<'info> for SetDefaultMintRequest<'info>
where
    'info: 'info,
{
    fn exit(
        &self,
        program_id: &anchor_lang::solana_program::pubkey::Pubkey,
    ) -> anchor_lang::Result<()> {
        anchor_lang::AccountsExit::exit(&self.mint_authority_request, program_id)
            .map_err(|e| e.with_account_name("mint_authority_request"))?;
        anchor_lang::AccountsExit::exit(&self.payer, program_id)
            .map_err(|e| e.with_account_name("payer"))?;
        anchor_lang::AccountsExit::exit(&self.tree_authority, program_id)
            .map_err(|e| e.with_account_name("tree_authority"))?;
        Ok(())
    }
}
/// An internal, Anchor generated module. This is used (as an
/// implementation detail), to generate a struct for a given
/// `#[derive(Accounts)]` implementation, where each field is a Pubkey,
/// instead of an `AccountInfo`. This is useful for clients that want
/// to generate a list of accounts, without explicitly knowing the
/// order all the fields should be in.
///
/// To access the struct in this module, one should use the sibling
/// `accounts` module (also generated), which re-exports this.
pub(crate) mod __client_accounts_set_default_mint_request {
    use super::*;
    use anchor_lang::prelude::borsh;
    /// Generated client accounts for [`SetDefaultMintRequest`].
    pub struct SetDefaultMintRequest {
        pub mint_authority_request: anchor_lang::solana_program::pubkey::Pubkey,
        pub payer: anchor_lang::solana_program::pubkey::Pubkey,
        pub creator: anchor_lang::solana_program::pubkey::Pubkey,
        pub tree_authority: anchor_lang::solana_program::pubkey::Pubkey,
        pub system_program: anchor_lang::solana_program::pubkey::Pubkey,
        pub merkle_slab: anchor_lang::solana_program::pubkey::Pubkey,
    }
    impl borsh::ser::BorshSerialize for SetDefaultMintRequest
    where
        anchor_lang::solana_program::pubkey::Pubkey: borsh::ser::BorshSerialize,
        anchor_lang::solana_program::pubkey::Pubkey: borsh::ser::BorshSerialize,
        anchor_lang::solana_program::pubkey::Pubkey: borsh::ser::BorshSerialize,
        anchor_lang::solana_program::pubkey::Pubkey: borsh::ser::BorshSerialize,
        anchor_lang::solana_program::pubkey::Pubkey: borsh::ser::BorshSerialize,
        anchor_lang::solana_program::pubkey::Pubkey: borsh::ser::BorshSerialize,
    {
        fn serialize<W: borsh::maybestd::io::Write>(
            &self,
            writer: &mut W,
        ) -> ::core::result::Result<(), borsh::maybestd::io::Error> {
            borsh::BorshSerialize::serialize(&self.mint_authority_request, writer)?;
            borsh::BorshSerialize::serialize(&self.payer, writer)?;
            borsh::BorshSerialize::serialize(&self.creator, writer)?;
            borsh::BorshSerialize::serialize(&self.tree_authority, writer)?;
            borsh::BorshSerialize::serialize(&self.system_program, writer)?;
            borsh::BorshSerialize::serialize(&self.merkle_slab, writer)?;
            Ok(())
        }
    }
    #[automatically_derived]
    impl anchor_lang::ToAccountMetas for SetDefaultMintRequest {
        fn to_account_metas(
            &self,
            is_signer: Option<bool>,
        ) -> Vec<anchor_lang::solana_program::instruction::AccountMeta> {
            let mut account_metas = ::alloc::vec::Vec::new();
            account_metas.push(anchor_lang::solana_program::instruction::AccountMeta::new(
                self.mint_authority_request,
                false,
            ));
            account_metas.push(anchor_lang::solana_program::instruction::AccountMeta::new(
                self.payer, true,
            ));
            account_metas.push(
                anchor_lang::solana_program::instruction::AccountMeta::new_readonly(
                    self.creator,
                    true,
                ),
            );
            account_metas.push(anchor_lang::solana_program::instruction::AccountMeta::new(
                self.tree_authority,
                false,
            ));
            account_metas.push(
                anchor_lang::solana_program::instruction::AccountMeta::new_readonly(
                    self.system_program,
                    false,
                ),
            );
            account_metas.push(
                anchor_lang::solana_program::instruction::AccountMeta::new_readonly(
                    self.merkle_slab,
                    false,
                ),
            );
            account_metas
        }
    }
}
/// An internal, Anchor generated module. This is used (as an
/// implementation detail), to generate a CPI struct for a given
/// `#[derive(Accounts)]` implementation, where each field is an
/// AccountInfo.
///
/// To access the struct in this module, one should use the sibling
/// [`cpi::accounts`] module (also generated), which re-exports this.
pub(crate) mod __cpi_client_accounts_set_default_mint_request {
    use super::*;
    /// Generated CPI struct of the accounts for [`SetDefaultMintRequest`].
    pub struct SetDefaultMintRequest<'info> {
        pub mint_authority_request: anchor_lang::solana_program::account_info::AccountInfo<'info>,
        pub payer: anchor_lang::solana_program::account_info::AccountInfo<'info>,
        pub creator: anchor_lang::solana_program::account_info::AccountInfo<'info>,
        pub tree_authority: anchor_lang::solana_program::account_info::AccountInfo<'info>,
        pub system_program: anchor_lang::solana_program::account_info::AccountInfo<'info>,
        pub merkle_slab: anchor_lang::solana_program::account_info::AccountInfo<'info>,
    }
    #[automatically_derived]
    impl<'info> anchor_lang::ToAccountMetas for SetDefaultMintRequest<'info> {
        fn to_account_metas(
            &self,
            is_signer: Option<bool>,
        ) -> Vec<anchor_lang::solana_program::instruction::AccountMeta> {
            let mut account_metas = ::alloc::vec::Vec::new();
            account_metas.push(anchor_lang::solana_program::instruction::AccountMeta::new(
                anchor_lang::Key::key(&self.mint_authority_request),
                false,
            ));
            account_metas.push(anchor_lang::solana_program::instruction::AccountMeta::new(
                anchor_lang::Key::key(&self.payer),
                true,
            ));
            account_metas.push(
                anchor_lang::solana_program::instruction::AccountMeta::new_readonly(
                    anchor_lang::Key::key(&self.creator),
                    true,
                ),
            );
            account_metas.push(anchor_lang::solana_program::instruction::AccountMeta::new(
                anchor_lang::Key::key(&self.tree_authority),
                false,
            ));
            account_metas.push(
                anchor_lang::solana_program::instruction::AccountMeta::new_readonly(
                    anchor_lang::Key::key(&self.system_program),
                    false,
                ),
            );
            account_metas.push(
                anchor_lang::solana_program::instruction::AccountMeta::new_readonly(
                    anchor_lang::Key::key(&self.merkle_slab),
                    false,
                ),
            );
            account_metas
        }
    }
    #[automatically_derived]
    impl<'info> anchor_lang::ToAccountInfos<'info> for SetDefaultMintRequest<'info> {
        fn to_account_infos(
            &self,
        ) -> Vec<anchor_lang::solana_program::account_info::AccountInfo<'info>> {
            let mut account_infos = ::alloc::vec::Vec::new();
            account_infos.push(anchor_lang::ToAccountInfo::to_account_info(
                &self.mint_authority_request,
            ));
            account_infos.push(anchor_lang::ToAccountInfo::to_account_info(&self.payer));
            account_infos.push(anchor_lang::ToAccountInfo::to_account_info(&self.creator));
            account_infos.push(anchor_lang::ToAccountInfo::to_account_info(
                &self.tree_authority,
            ));
            account_infos.push(anchor_lang::ToAccountInfo::to_account_info(
                &self.system_program,
            ));
            account_infos.push(anchor_lang::ToAccountInfo::to_account_info(
                &self.merkle_slab,
            ));
            account_infos
        }
    }
}
pub struct ApproveMintRequest<'info> {
    # [account (mut , seeds = [merkle_slab . key () . as_ref () , mint_authority_request . mint_authority . as_ref ()] , bump)]
    pub mint_authority_request: Account<'info, MintRequest>,
    # [account (constraint = * tree_delegate . key == tree_authority . creator || * tree_delegate . key == tree_authority . delegate)]
    pub tree_delegate: Signer<'info>,
    # [account (mut , seeds = [merkle_slab . key () . as_ref ()] , bump)]
    pub tree_authority: Account<'info, TreeConfig>,
    /// CHECK: this account is neither read from or written to
    pub merkle_slab: UncheckedAccount<'info>,
}
#[automatically_derived]
impl<'info> anchor_lang::Accounts<'info> for ApproveMintRequest<'info>
where
    'info: 'info,
{
    #[inline(never)]
    fn try_accounts(
        program_id: &anchor_lang::solana_program::pubkey::Pubkey,
        accounts: &mut &[anchor_lang::solana_program::account_info::AccountInfo<'info>],
        ix_data: &[u8],
        __bumps: &mut std::collections::BTreeMap<String, u8>,
        __reallocs: &mut std::collections::BTreeSet<anchor_lang::solana_program::pubkey::Pubkey>,
    ) -> anchor_lang::Result<Self> {
        let mint_authority_request: anchor_lang::accounts::account::Account<MintRequest> =
            anchor_lang::Accounts::try_accounts(program_id, accounts, ix_data, __bumps, __reallocs)
                .map_err(|e| e.with_account_name("mint_authority_request"))?;
        let tree_delegate: Signer =
            anchor_lang::Accounts::try_accounts(program_id, accounts, ix_data, __bumps, __reallocs)
                .map_err(|e| e.with_account_name("tree_delegate"))?;
        let tree_authority: anchor_lang::accounts::account::Account<TreeConfig> =
            anchor_lang::Accounts::try_accounts(program_id, accounts, ix_data, __bumps, __reallocs)
                .map_err(|e| e.with_account_name("tree_authority"))?;
        let merkle_slab: UncheckedAccount =
            anchor_lang::Accounts::try_accounts(program_id, accounts, ix_data, __bumps, __reallocs)
                .map_err(|e| e.with_account_name("merkle_slab"))?;
        let (__pda_address, __bump) = Pubkey::find_program_address(
            &[
                merkle_slab.key().as_ref(),
                mint_authority_request.mint_authority.as_ref(),
            ],
            &program_id,
        );
        __bumps.insert("mint_authority_request".to_string(), __bump);
        if mint_authority_request.key() != __pda_address {
            return Err(anchor_lang::error::Error::from(
                anchor_lang::error::ErrorCode::ConstraintSeeds,
            )
            .with_account_name("mint_authority_request")
            .with_pubkeys((mint_authority_request.key(), __pda_address)));
        }
        if !mint_authority_request.to_account_info().is_writable {
            return Err(anchor_lang::error::Error::from(
                anchor_lang::error::ErrorCode::ConstraintMut,
            )
            .with_account_name("mint_authority_request"));
        }
        if !(*tree_delegate.key == tree_authority.creator
            || *tree_delegate.key == tree_authority.delegate)
        {
            return Err(anchor_lang::error::Error::from(
                anchor_lang::error::ErrorCode::ConstraintRaw,
            )
            .with_account_name("tree_delegate"));
        }
        let (__pda_address, __bump) =
            Pubkey::find_program_address(&[merkle_slab.key().as_ref()], &program_id);
        __bumps.insert("tree_authority".to_string(), __bump);
        if tree_authority.key() != __pda_address {
            return Err(anchor_lang::error::Error::from(
                anchor_lang::error::ErrorCode::ConstraintSeeds,
            )
            .with_account_name("tree_authority")
            .with_pubkeys((tree_authority.key(), __pda_address)));
        }
        if !tree_authority.to_account_info().is_writable {
            return Err(anchor_lang::error::Error::from(
                anchor_lang::error::ErrorCode::ConstraintMut,
            )
            .with_account_name("tree_authority"));
        }
        Ok(ApproveMintRequest {
            mint_authority_request,
            tree_delegate,
            tree_authority,
            merkle_slab,
        })
    }
}
#[automatically_derived]
impl<'info> anchor_lang::ToAccountInfos<'info> for ApproveMintRequest<'info>
where
    'info: 'info,
{
    fn to_account_infos(
        &self,
    ) -> Vec<anchor_lang::solana_program::account_info::AccountInfo<'info>> {
        let mut account_infos = ::alloc::vec::Vec::new();
        account_infos.extend(self.mint_authority_request.to_account_infos());
        account_infos.extend(self.tree_delegate.to_account_infos());
        account_infos.extend(self.tree_authority.to_account_infos());
        account_infos.extend(self.merkle_slab.to_account_infos());
        account_infos
    }
}
#[automatically_derived]
impl<'info> anchor_lang::ToAccountMetas for ApproveMintRequest<'info> {
    fn to_account_metas(
        &self,
        is_signer: Option<bool>,
    ) -> Vec<anchor_lang::solana_program::instruction::AccountMeta> {
        let mut account_metas = ::alloc::vec::Vec::new();
        account_metas.extend(self.mint_authority_request.to_account_metas(None));
        account_metas.extend(self.tree_delegate.to_account_metas(None));
        account_metas.extend(self.tree_authority.to_account_metas(None));
        account_metas.extend(self.merkle_slab.to_account_metas(None));
        account_metas
    }
}
#[automatically_derived]
impl<'info> anchor_lang::AccountsExit<'info> for ApproveMintRequest<'info>
where
    'info: 'info,
{
    fn exit(
        &self,
        program_id: &anchor_lang::solana_program::pubkey::Pubkey,
    ) -> anchor_lang::Result<()> {
        anchor_lang::AccountsExit::exit(&self.mint_authority_request, program_id)
            .map_err(|e| e.with_account_name("mint_authority_request"))?;
        anchor_lang::AccountsExit::exit(&self.tree_authority, program_id)
            .map_err(|e| e.with_account_name("tree_authority"))?;
        Ok(())
    }
}
/// An internal, Anchor generated module. This is used (as an
/// implementation detail), to generate a struct for a given
/// `#[derive(Accounts)]` implementation, where each field is a Pubkey,
/// instead of an `AccountInfo`. This is useful for clients that want
/// to generate a list of accounts, without explicitly knowing the
/// order all the fields should be in.
///
/// To access the struct in this module, one should use the sibling
/// `accounts` module (also generated), which re-exports this.
pub(crate) mod __client_accounts_approve_mint_request {
    use super::*;
    use anchor_lang::prelude::borsh;
    /// Generated client accounts for [`ApproveMintRequest`].
    pub struct ApproveMintRequest {
        pub mint_authority_request: anchor_lang::solana_program::pubkey::Pubkey,
        pub tree_delegate: anchor_lang::solana_program::pubkey::Pubkey,
        pub tree_authority: anchor_lang::solana_program::pubkey::Pubkey,
        pub merkle_slab: anchor_lang::solana_program::pubkey::Pubkey,
    }
    impl borsh::ser::BorshSerialize for ApproveMintRequest
    where
        anchor_lang::solana_program::pubkey::Pubkey: borsh::ser::BorshSerialize,
        anchor_lang::solana_program::pubkey::Pubkey: borsh::ser::BorshSerialize,
        anchor_lang::solana_program::pubkey::Pubkey: borsh::ser::BorshSerialize,
        anchor_lang::solana_program::pubkey::Pubkey: borsh::ser::BorshSerialize,
    {
        fn serialize<W: borsh::maybestd::io::Write>(
            &self,
            writer: &mut W,
        ) -> ::core::result::Result<(), borsh::maybestd::io::Error> {
            borsh::BorshSerialize::serialize(&self.mint_authority_request, writer)?;
            borsh::BorshSerialize::serialize(&self.tree_delegate, writer)?;
            borsh::BorshSerialize::serialize(&self.tree_authority, writer)?;
            borsh::BorshSerialize::serialize(&self.merkle_slab, writer)?;
            Ok(())
        }
    }
    #[automatically_derived]
    impl anchor_lang::ToAccountMetas for ApproveMintRequest {
        fn to_account_metas(
            &self,
            is_signer: Option<bool>,
        ) -> Vec<anchor_lang::solana_program::instruction::AccountMeta> {
            let mut account_metas = ::alloc::vec::Vec::new();
            account_metas.push(anchor_lang::solana_program::instruction::AccountMeta::new(
                self.mint_authority_request,
                false,
            ));
            account_metas.push(
                anchor_lang::solana_program::instruction::AccountMeta::new_readonly(
                    self.tree_delegate,
                    true,
                ),
            );
            account_metas.push(anchor_lang::solana_program::instruction::AccountMeta::new(
                self.tree_authority,
                false,
            ));
            account_metas.push(
                anchor_lang::solana_program::instruction::AccountMeta::new_readonly(
                    self.merkle_slab,
                    false,
                ),
            );
            account_metas
        }
    }
}
/// An internal, Anchor generated module. This is used (as an
/// implementation detail), to generate a CPI struct for a given
/// `#[derive(Accounts)]` implementation, where each field is an
/// AccountInfo.
///
/// To access the struct in this module, one should use the sibling
/// [`cpi::accounts`] module (also generated), which re-exports this.
pub(crate) mod __cpi_client_accounts_approve_mint_request {
    use super::*;
    /// Generated CPI struct of the accounts for [`ApproveMintRequest`].
    pub struct ApproveMintRequest<'info> {
        pub mint_authority_request: anchor_lang::solana_program::account_info::AccountInfo<'info>,
        pub tree_delegate: anchor_lang::solana_program::account_info::AccountInfo<'info>,
        pub tree_authority: anchor_lang::solana_program::account_info::AccountInfo<'info>,
        pub merkle_slab: anchor_lang::solana_program::account_info::AccountInfo<'info>,
    }
    #[automatically_derived]
    impl<'info> anchor_lang::ToAccountMetas for ApproveMintRequest<'info> {
        fn to_account_metas(
            &self,
            is_signer: Option<bool>,
        ) -> Vec<anchor_lang::solana_program::instruction::AccountMeta> {
            let mut account_metas = ::alloc::vec::Vec::new();
            account_metas.push(anchor_lang::solana_program::instruction::AccountMeta::new(
                anchor_lang::Key::key(&self.mint_authority_request),
                false,
            ));
            account_metas.push(
                anchor_lang::solana_program::instruction::AccountMeta::new_readonly(
                    anchor_lang::Key::key(&self.tree_delegate),
                    true,
                ),
            );
            account_metas.push(anchor_lang::solana_program::instruction::AccountMeta::new(
                anchor_lang::Key::key(&self.tree_authority),
                false,
            ));
            account_metas.push(
                anchor_lang::solana_program::instruction::AccountMeta::new_readonly(
                    anchor_lang::Key::key(&self.merkle_slab),
                    false,
                ),
            );
            account_metas
        }
    }
    #[automatically_derived]
    impl<'info> anchor_lang::ToAccountInfos<'info> for ApproveMintRequest<'info> {
        fn to_account_infos(
            &self,
        ) -> Vec<anchor_lang::solana_program::account_info::AccountInfo<'info>> {
            let mut account_infos = ::alloc::vec::Vec::new();
            account_infos.push(anchor_lang::ToAccountInfo::to_account_info(
                &self.mint_authority_request,
            ));
            account_infos.push(anchor_lang::ToAccountInfo::to_account_info(
                &self.tree_delegate,
            ));
            account_infos.push(anchor_lang::ToAccountInfo::to_account_info(
                &self.tree_authority,
            ));
            account_infos.push(anchor_lang::ToAccountInfo::to_account_info(
                &self.merkle_slab,
            ));
            account_infos
        }
    }
}
pub struct CloseMintRequest<'info> {
    # [account (mut , close = mint_authority , seeds = [merkle_slab . key () . as_ref () , mint_authority . key () . as_ref ()] , bump)]
    pub mint_authority_request: Account<'info, MintRequest>,
    #[account(mut)]
    pub mint_authority: Signer<'info>,
    # [account (mut , seeds = [merkle_slab . key () . as_ref ()] , bump)]
    pub tree_authority: Account<'info, TreeConfig>,
    /// CHECK: this account is neither read from or written to
    pub merkle_slab: UncheckedAccount<'info>,
}
#[automatically_derived]
impl<'info> anchor_lang::Accounts<'info> for CloseMintRequest<'info>
where
    'info: 'info,
{
    #[inline(never)]
    fn try_accounts(
        program_id: &anchor_lang::solana_program::pubkey::Pubkey,
        accounts: &mut &[anchor_lang::solana_program::account_info::AccountInfo<'info>],
        ix_data: &[u8],
        __bumps: &mut std::collections::BTreeMap<String, u8>,
        __reallocs: &mut std::collections::BTreeSet<anchor_lang::solana_program::pubkey::Pubkey>,
    ) -> anchor_lang::Result<Self> {
        let mint_authority_request: anchor_lang::accounts::account::Account<MintRequest> =
            anchor_lang::Accounts::try_accounts(program_id, accounts, ix_data, __bumps, __reallocs)
                .map_err(|e| e.with_account_name("mint_authority_request"))?;
        let mint_authority: Signer =
            anchor_lang::Accounts::try_accounts(program_id, accounts, ix_data, __bumps, __reallocs)
                .map_err(|e| e.with_account_name("mint_authority"))?;
        let tree_authority: anchor_lang::accounts::account::Account<TreeConfig> =
            anchor_lang::Accounts::try_accounts(program_id, accounts, ix_data, __bumps, __reallocs)
                .map_err(|e| e.with_account_name("tree_authority"))?;
        let merkle_slab: UncheckedAccount =
            anchor_lang::Accounts::try_accounts(program_id, accounts, ix_data, __bumps, __reallocs)
                .map_err(|e| e.with_account_name("merkle_slab"))?;
        let (__pda_address, __bump) = Pubkey::find_program_address(
            &[merkle_slab.key().as_ref(), mint_authority.key().as_ref()],
            &program_id,
        );
        __bumps.insert("mint_authority_request".to_string(), __bump);
        if mint_authority_request.key() != __pda_address {
            return Err(anchor_lang::error::Error::from(
                anchor_lang::error::ErrorCode::ConstraintSeeds,
            )
            .with_account_name("mint_authority_request")
            .with_pubkeys((mint_authority_request.key(), __pda_address)));
        }
        if !mint_authority_request.to_account_info().is_writable {
            return Err(anchor_lang::error::Error::from(
                anchor_lang::error::ErrorCode::ConstraintMut,
            )
            .with_account_name("mint_authority_request"));
        }
        if mint_authority_request.key() == mint_authority.key() {
            return Err(anchor_lang::error::Error::from(
                anchor_lang::error::ErrorCode::ConstraintClose,
            )
            .with_account_name("mint_authority_request"));
        }
        if !mint_authority.to_account_info().is_writable {
            return Err(anchor_lang::error::Error::from(
                anchor_lang::error::ErrorCode::ConstraintMut,
            )
            .with_account_name("mint_authority"));
        }
        let (__pda_address, __bump) =
            Pubkey::find_program_address(&[merkle_slab.key().as_ref()], &program_id);
        __bumps.insert("tree_authority".to_string(), __bump);
        if tree_authority.key() != __pda_address {
            return Err(anchor_lang::error::Error::from(
                anchor_lang::error::ErrorCode::ConstraintSeeds,
            )
            .with_account_name("tree_authority")
            .with_pubkeys((tree_authority.key(), __pda_address)));
        }
        if !tree_authority.to_account_info().is_writable {
            return Err(anchor_lang::error::Error::from(
                anchor_lang::error::ErrorCode::ConstraintMut,
            )
            .with_account_name("tree_authority"));
        }
        Ok(CloseMintRequest {
            mint_authority_request,
            mint_authority,
            tree_authority,
            merkle_slab,
        })
    }
}
#[automatically_derived]
impl<'info> anchor_lang::ToAccountInfos<'info> for CloseMintRequest<'info>
where
    'info: 'info,
{
    fn to_account_infos(
        &self,
    ) -> Vec<anchor_lang::solana_program::account_info::AccountInfo<'info>> {
        let mut account_infos = ::alloc::vec::Vec::new();
        account_infos.extend(self.mint_authority_request.to_account_infos());
        account_infos.extend(self.mint_authority.to_account_infos());
        account_infos.extend(self.tree_authority.to_account_infos());
        account_infos.extend(self.merkle_slab.to_account_infos());
        account_infos
    }
}
#[automatically_derived]
impl<'info> anchor_lang::ToAccountMetas for CloseMintRequest<'info> {
    fn to_account_metas(
        &self,
        is_signer: Option<bool>,
    ) -> Vec<anchor_lang::solana_program::instruction::AccountMeta> {
        let mut account_metas = ::alloc::vec::Vec::new();
        account_metas.extend(self.mint_authority_request.to_account_metas(None));
        account_metas.extend(self.mint_authority.to_account_metas(None));
        account_metas.extend(self.tree_authority.to_account_metas(None));
        account_metas.extend(self.merkle_slab.to_account_metas(None));
        account_metas
    }
}
#[automatically_derived]
impl<'info> anchor_lang::AccountsExit<'info> for CloseMintRequest<'info>
where
    'info: 'info,
{
    fn exit(
        &self,
        program_id: &anchor_lang::solana_program::pubkey::Pubkey,
    ) -> anchor_lang::Result<()> {
        anchor_lang::AccountsClose::close(
            &self.mint_authority_request,
            self.mint_authority.to_account_info(),
        )
        .map_err(|e| e.with_account_name("mint_authority_request"))?;
        anchor_lang::AccountsExit::exit(&self.mint_authority, program_id)
            .map_err(|e| e.with_account_name("mint_authority"))?;
        anchor_lang::AccountsExit::exit(&self.tree_authority, program_id)
            .map_err(|e| e.with_account_name("tree_authority"))?;
        Ok(())
    }
}
/// An internal, Anchor generated module. This is used (as an
/// implementation detail), to generate a struct for a given
/// `#[derive(Accounts)]` implementation, where each field is a Pubkey,
/// instead of an `AccountInfo`. This is useful for clients that want
/// to generate a list of accounts, without explicitly knowing the
/// order all the fields should be in.
///
/// To access the struct in this module, one should use the sibling
/// `accounts` module (also generated), which re-exports this.
pub(crate) mod __client_accounts_close_mint_request {
    use super::*;
    use anchor_lang::prelude::borsh;
    /// Generated client accounts for [`CloseMintRequest`].
    pub struct CloseMintRequest {
        pub mint_authority_request: anchor_lang::solana_program::pubkey::Pubkey,
        pub mint_authority: anchor_lang::solana_program::pubkey::Pubkey,
        pub tree_authority: anchor_lang::solana_program::pubkey::Pubkey,
        pub merkle_slab: anchor_lang::solana_program::pubkey::Pubkey,
    }
    impl borsh::ser::BorshSerialize for CloseMintRequest
    where
        anchor_lang::solana_program::pubkey::Pubkey: borsh::ser::BorshSerialize,
        anchor_lang::solana_program::pubkey::Pubkey: borsh::ser::BorshSerialize,
        anchor_lang::solana_program::pubkey::Pubkey: borsh::ser::BorshSerialize,
        anchor_lang::solana_program::pubkey::Pubkey: borsh::ser::BorshSerialize,
    {
        fn serialize<W: borsh::maybestd::io::Write>(
            &self,
            writer: &mut W,
        ) -> ::core::result::Result<(), borsh::maybestd::io::Error> {
            borsh::BorshSerialize::serialize(&self.mint_authority_request, writer)?;
            borsh::BorshSerialize::serialize(&self.mint_authority, writer)?;
            borsh::BorshSerialize::serialize(&self.tree_authority, writer)?;
            borsh::BorshSerialize::serialize(&self.merkle_slab, writer)?;
            Ok(())
        }
    }
    #[automatically_derived]
    impl anchor_lang::ToAccountMetas for CloseMintRequest {
        fn to_account_metas(
            &self,
            is_signer: Option<bool>,
        ) -> Vec<anchor_lang::solana_program::instruction::AccountMeta> {
            let mut account_metas = ::alloc::vec::Vec::new();
            account_metas.push(anchor_lang::solana_program::instruction::AccountMeta::new(
                self.mint_authority_request,
                false,
            ));
            account_metas.push(anchor_lang::solana_program::instruction::AccountMeta::new(
                self.mint_authority,
                true,
            ));
            account_metas.push(anchor_lang::solana_program::instruction::AccountMeta::new(
                self.tree_authority,
                false,
            ));
            account_metas.push(
                anchor_lang::solana_program::instruction::AccountMeta::new_readonly(
                    self.merkle_slab,
                    false,
                ),
            );
            account_metas
        }
    }
}
/// An internal, Anchor generated module. This is used (as an
/// implementation detail), to generate a CPI struct for a given
/// `#[derive(Accounts)]` implementation, where each field is an
/// AccountInfo.
///
/// To access the struct in this module, one should use the sibling
/// [`cpi::accounts`] module (also generated), which re-exports this.
pub(crate) mod __cpi_client_accounts_close_mint_request {
    use super::*;
    /// Generated CPI struct of the accounts for [`CloseMintRequest`].
    pub struct CloseMintRequest<'info> {
        pub mint_authority_request: anchor_lang::solana_program::account_info::AccountInfo<'info>,
        pub mint_authority: anchor_lang::solana_program::account_info::AccountInfo<'info>,
        pub tree_authority: anchor_lang::solana_program::account_info::AccountInfo<'info>,
        pub merkle_slab: anchor_lang::solana_program::account_info::AccountInfo<'info>,
    }
    #[automatically_derived]
    impl<'info> anchor_lang::ToAccountMetas for CloseMintRequest<'info> {
        fn to_account_metas(
            &self,
            is_signer: Option<bool>,
        ) -> Vec<anchor_lang::solana_program::instruction::AccountMeta> {
            let mut account_metas = ::alloc::vec::Vec::new();
            account_metas.push(anchor_lang::solana_program::instruction::AccountMeta::new(
                anchor_lang::Key::key(&self.mint_authority_request),
                false,
            ));
            account_metas.push(anchor_lang::solana_program::instruction::AccountMeta::new(
                anchor_lang::Key::key(&self.mint_authority),
                true,
            ));
            account_metas.push(anchor_lang::solana_program::instruction::AccountMeta::new(
                anchor_lang::Key::key(&self.tree_authority),
                false,
            ));
            account_metas.push(
                anchor_lang::solana_program::instruction::AccountMeta::new_readonly(
                    anchor_lang::Key::key(&self.merkle_slab),
                    false,
                ),
            );
            account_metas
        }
    }
    #[automatically_derived]
    impl<'info> anchor_lang::ToAccountInfos<'info> for CloseMintRequest<'info> {
        fn to_account_infos(
            &self,
        ) -> Vec<anchor_lang::solana_program::account_info::AccountInfo<'info>> {
            let mut account_infos = ::alloc::vec::Vec::new();
            account_infos.push(anchor_lang::ToAccountInfo::to_account_info(
                &self.mint_authority_request,
            ));
            account_infos.push(anchor_lang::ToAccountInfo::to_account_info(
                &self.mint_authority,
            ));
            account_infos.push(anchor_lang::ToAccountInfo::to_account_info(
                &self.tree_authority,
            ));
            account_infos.push(anchor_lang::ToAccountInfo::to_account_info(
                &self.merkle_slab,
            ));
            account_infos
        }
    }
}
pub struct SetTreeDelegate<'info> {
    pub creator: Signer<'info>,
    /// CHECK: this account is neither read from or written to
    pub new_delegate: UncheckedAccount<'info>,
    /// CHECK: this account is neither read from or written to
    pub merkle_slab: UncheckedAccount<'info>,
    # [account (mut , seeds = [merkle_slab . key () . as_ref ()] , bump , has_one = creator)]
    pub tree_authority: Account<'info, TreeConfig>,
}
#[automatically_derived]
impl<'info> anchor_lang::Accounts<'info> for SetTreeDelegate<'info>
where
    'info: 'info,
{
    #[inline(never)]
    fn try_accounts(
        program_id: &anchor_lang::solana_program::pubkey::Pubkey,
        accounts: &mut &[anchor_lang::solana_program::account_info::AccountInfo<'info>],
        ix_data: &[u8],
        __bumps: &mut std::collections::BTreeMap<String, u8>,
        __reallocs: &mut std::collections::BTreeSet<anchor_lang::solana_program::pubkey::Pubkey>,
    ) -> anchor_lang::Result<Self> {
        let creator: Signer =
            anchor_lang::Accounts::try_accounts(program_id, accounts, ix_data, __bumps, __reallocs)
                .map_err(|e| e.with_account_name("creator"))?;
        let new_delegate: UncheckedAccount =
            anchor_lang::Accounts::try_accounts(program_id, accounts, ix_data, __bumps, __reallocs)
                .map_err(|e| e.with_account_name("new_delegate"))?;
        let merkle_slab: UncheckedAccount =
            anchor_lang::Accounts::try_accounts(program_id, accounts, ix_data, __bumps, __reallocs)
                .map_err(|e| e.with_account_name("merkle_slab"))?;
        let tree_authority: anchor_lang::accounts::account::Account<TreeConfig> =
            anchor_lang::Accounts::try_accounts(program_id, accounts, ix_data, __bumps, __reallocs)
                .map_err(|e| e.with_account_name("tree_authority"))?;
        let (__pda_address, __bump) =
            Pubkey::find_program_address(&[merkle_slab.key().as_ref()], &program_id);
        __bumps.insert("tree_authority".to_string(), __bump);
        if tree_authority.key() != __pda_address {
            return Err(anchor_lang::error::Error::from(
                anchor_lang::error::ErrorCode::ConstraintSeeds,
            )
            .with_account_name("tree_authority")
            .with_pubkeys((tree_authority.key(), __pda_address)));
        }
        if !tree_authority.to_account_info().is_writable {
            return Err(anchor_lang::error::Error::from(
                anchor_lang::error::ErrorCode::ConstraintMut,
            )
            .with_account_name("tree_authority"));
        }
        {
            let my_key = tree_authority.creator;
            let target_key = creator.key();
            if my_key != target_key {
                return Err(anchor_lang::error::Error::from(
                    anchor_lang::error::ErrorCode::ConstraintHasOne,
                )
                .with_account_name("tree_authority")
                .with_pubkeys((my_key, target_key)));
            }
        }
        Ok(SetTreeDelegate {
            creator,
            new_delegate,
            merkle_slab,
            tree_authority,
        })
    }
}
#[automatically_derived]
impl<'info> anchor_lang::ToAccountInfos<'info> for SetTreeDelegate<'info>
where
    'info: 'info,
{
    fn to_account_infos(
        &self,
    ) -> Vec<anchor_lang::solana_program::account_info::AccountInfo<'info>> {
        let mut account_infos = ::alloc::vec::Vec::new();
        account_infos.extend(self.creator.to_account_infos());
        account_infos.extend(self.new_delegate.to_account_infos());
        account_infos.extend(self.merkle_slab.to_account_infos());
        account_infos.extend(self.tree_authority.to_account_infos());
        account_infos
    }
}
#[automatically_derived]
impl<'info> anchor_lang::ToAccountMetas for SetTreeDelegate<'info> {
    fn to_account_metas(
        &self,
        is_signer: Option<bool>,
    ) -> Vec<anchor_lang::solana_program::instruction::AccountMeta> {
        let mut account_metas = ::alloc::vec::Vec::new();
        account_metas.extend(self.creator.to_account_metas(None));
        account_metas.extend(self.new_delegate.to_account_metas(None));
        account_metas.extend(self.merkle_slab.to_account_metas(None));
        account_metas.extend(self.tree_authority.to_account_metas(None));
        account_metas
    }
}
#[automatically_derived]
impl<'info> anchor_lang::AccountsExit<'info> for SetTreeDelegate<'info>
where
    'info: 'info,
{
    fn exit(
        &self,
        program_id: &anchor_lang::solana_program::pubkey::Pubkey,
    ) -> anchor_lang::Result<()> {
        anchor_lang::AccountsExit::exit(&self.tree_authority, program_id)
            .map_err(|e| e.with_account_name("tree_authority"))?;
        Ok(())
    }
}
/// An internal, Anchor generated module. This is used (as an
/// implementation detail), to generate a struct for a given
/// `#[derive(Accounts)]` implementation, where each field is a Pubkey,
/// instead of an `AccountInfo`. This is useful for clients that want
/// to generate a list of accounts, without explicitly knowing the
/// order all the fields should be in.
///
/// To access the struct in this module, one should use the sibling
/// `accounts` module (also generated), which re-exports this.
pub(crate) mod __client_accounts_set_tree_delegate {
    use super::*;
    use anchor_lang::prelude::borsh;
    /// Generated client accounts for [`SetTreeDelegate`].
    pub struct SetTreeDelegate {
        pub creator: anchor_lang::solana_program::pubkey::Pubkey,
        pub new_delegate: anchor_lang::solana_program::pubkey::Pubkey,
        pub merkle_slab: anchor_lang::solana_program::pubkey::Pubkey,
        pub tree_authority: anchor_lang::solana_program::pubkey::Pubkey,
    }
    impl borsh::ser::BorshSerialize for SetTreeDelegate
    where
        anchor_lang::solana_program::pubkey::Pubkey: borsh::ser::BorshSerialize,
        anchor_lang::solana_program::pubkey::Pubkey: borsh::ser::BorshSerialize,
        anchor_lang::solana_program::pubkey::Pubkey: borsh::ser::BorshSerialize,
        anchor_lang::solana_program::pubkey::Pubkey: borsh::ser::BorshSerialize,
    {
        fn serialize<W: borsh::maybestd::io::Write>(
            &self,
            writer: &mut W,
        ) -> ::core::result::Result<(), borsh::maybestd::io::Error> {
            borsh::BorshSerialize::serialize(&self.creator, writer)?;
            borsh::BorshSerialize::serialize(&self.new_delegate, writer)?;
            borsh::BorshSerialize::serialize(&self.merkle_slab, writer)?;
            borsh::BorshSerialize::serialize(&self.tree_authority, writer)?;
            Ok(())
        }
    }
    #[automatically_derived]
    impl anchor_lang::ToAccountMetas for SetTreeDelegate {
        fn to_account_metas(
            &self,
            is_signer: Option<bool>,
        ) -> Vec<anchor_lang::solana_program::instruction::AccountMeta> {
            let mut account_metas = ::alloc::vec::Vec::new();
            account_metas.push(
                anchor_lang::solana_program::instruction::AccountMeta::new_readonly(
                    self.creator,
                    true,
                ),
            );
            account_metas.push(
                anchor_lang::solana_program::instruction::AccountMeta::new_readonly(
                    self.new_delegate,
                    false,
                ),
            );
            account_metas.push(
                anchor_lang::solana_program::instruction::AccountMeta::new_readonly(
                    self.merkle_slab,
                    false,
                ),
            );
            account_metas.push(anchor_lang::solana_program::instruction::AccountMeta::new(
                self.tree_authority,
                false,
            ));
            account_metas
        }
    }
}
/// An internal, Anchor generated module. This is used (as an
/// implementation detail), to generate a CPI struct for a given
/// `#[derive(Accounts)]` implementation, where each field is an
/// AccountInfo.
///
/// To access the struct in this module, one should use the sibling
/// [`cpi::accounts`] module (also generated), which re-exports this.
pub(crate) mod __cpi_client_accounts_set_tree_delegate {
    use super::*;
    /// Generated CPI struct of the accounts for [`SetTreeDelegate`].
    pub struct SetTreeDelegate<'info> {
        pub creator: anchor_lang::solana_program::account_info::AccountInfo<'info>,
        pub new_delegate: anchor_lang::solana_program::account_info::AccountInfo<'info>,
        pub merkle_slab: anchor_lang::solana_program::account_info::AccountInfo<'info>,
        pub tree_authority: anchor_lang::solana_program::account_info::AccountInfo<'info>,
    }
    #[automatically_derived]
    impl<'info> anchor_lang::ToAccountMetas for SetTreeDelegate<'info> {
        fn to_account_metas(
            &self,
            is_signer: Option<bool>,
        ) -> Vec<anchor_lang::solana_program::instruction::AccountMeta> {
            let mut account_metas = ::alloc::vec::Vec::new();
            account_metas.push(
                anchor_lang::solana_program::instruction::AccountMeta::new_readonly(
                    anchor_lang::Key::key(&self.creator),
                    true,
                ),
            );
            account_metas.push(
                anchor_lang::solana_program::instruction::AccountMeta::new_readonly(
                    anchor_lang::Key::key(&self.new_delegate),
                    false,
                ),
            );
            account_metas.push(
                anchor_lang::solana_program::instruction::AccountMeta::new_readonly(
                    anchor_lang::Key::key(&self.merkle_slab),
                    false,
                ),
            );
            account_metas.push(anchor_lang::solana_program::instruction::AccountMeta::new(
                anchor_lang::Key::key(&self.tree_authority),
                false,
            ));
            account_metas
        }
    }
    #[automatically_derived]
    impl<'info> anchor_lang::ToAccountInfos<'info> for SetTreeDelegate<'info> {
        fn to_account_infos(
            &self,
        ) -> Vec<anchor_lang::solana_program::account_info::AccountInfo<'info>> {
            let mut account_infos = ::alloc::vec::Vec::new();
            account_infos.push(anchor_lang::ToAccountInfo::to_account_info(&self.creator));
            account_infos.push(anchor_lang::ToAccountInfo::to_account_info(
                &self.new_delegate,
            ));
            account_infos.push(anchor_lang::ToAccountInfo::to_account_info(
                &self.merkle_slab,
            ));
            account_infos.push(anchor_lang::ToAccountInfo::to_account_info(
                &self.tree_authority,
            ));
            account_infos
        }
    }
}
pub fn hash_metadata(metadata: &MetadataArgs) -> Result<[u8; 32]> {
    let metadata_args_hash = keccak::hashv(&[metadata.try_to_vec()?.as_slice()]);
    Ok(keccak::hashv(&[
        &metadata_args_hash.to_bytes(),
        &metadata.seller_fee_basis_points.to_le_bytes(),
    ])
    .to_bytes())
}
pub enum InstructionName {
    Unknown,
    MintV1,
    Redeem,
    CancelRedeem,
    Transfer,
    Delegate,
    DecompressV1,
    Compress,
    Burn,
}
pub fn get_instruction_type(full_bytes: &[u8]) -> InstructionName {
    let disc: [u8; 8] = {
        let mut disc = [0; 8];
        disc.copy_from_slice(&full_bytes[..8]);
        disc
    };
    match disc {
        [145, 98, 192, 118, 184, 147, 118, 104] => InstructionName::MintV1,
        [111, 76, 232, 50, 39, 175, 48, 242] => InstructionName::CancelRedeem,
        [184, 12, 86, 149, 70, 196, 97, 225] => InstructionName::Redeem,
        [163, 52, 200, 231, 140, 3, 69, 186] => InstructionName::Transfer,
        [90, 147, 75, 178, 85, 88, 4, 137] => InstructionName::Delegate,
        [54, 85, 76, 70, 228, 250, 164, 81] => InstructionName::DecompressV1,
        [116, 110, 29, 56, 107, 219, 42, 93] => InstructionName::Burn,
        [82, 193, 176, 117, 176, 21, 115, 253] => InstructionName::Compress,
        _ => InstructionName::Unknown,
    }
}
fn assert_enough_mints_to_approve<'info>(
    authority: &Account<'info, TreeConfig>,
    to_approve: u64,
) -> Result<()> {
    if !authority.contains_mint_capacity(to_approve) {
        return Err(BubblegumError::InsufficientMintCapacity.into());
    }
    Ok(())
}
fn process_mint_v1<'info>(
    message: MetadataArgs,
    owner: Pubkey,
    delegate: Pubkey,
    metadata_auth: HashSet<Pubkey>,
    authority_bump: u8,
    authority: &mut Account<'info, TreeConfig>,
    merkle_slab: &AccountInfo<'info>,
    candy_wrapper: &Program<'info, Wrapper>,
    gummyroll_program: &AccountInfo<'info>,
) -> Result<()> {
    assert_metadata_is_mpl_compatible(&message)?;
    let metadata_args_hash = keccak::hashv(&[message.try_to_vec()?.as_slice()]);
    let data_hash = keccak::hashv(&[
        &metadata_args_hash.to_bytes(),
        &message.seller_fee_basis_points.to_le_bytes(),
    ]);
    let creator_data = message
        .creators
        .iter()
        .map(|c| {
            if c.verified && !metadata_auth.contains(&c.address) {
                Err(BubblegumError::CreatorDidNotVerify.into())
            } else {
                Ok([c.address.as_ref(), &[c.verified as u8], &[c.share]].concat())
            }
        })
        .collect::<Result<Vec<_>>>()?;
    let creator_hash = keccak::hashv(
        creator_data
            .iter()
            .map(|c| c.as_slice())
            .collect::<Vec<&[u8]>>()
            .as_ref(),
    );
    let asset_id = get_asset_id(&merkle_slab.key(), authority.num_minted);
    let leaf = LeafSchema::new_v0(
        asset_id,
        owner,
        delegate,
        authority.num_minted,
        data_hash.to_bytes(),
        creator_hash.to_bytes(),
    );
    let new_nft = NewNFTEvent {
        version: Version::V1,
        metadata: message,
        nonce: authority.num_minted,
    };
    {
        anchor_lang::solana_program::log::sol_log_data(&[&anchor_lang::Event::data(&new_nft)]);
    };
    wrap_event(new_nft.try_to_vec()?, &candy_wrapper)?;
    {
        anchor_lang::solana_program::log::sol_log_data(&[&anchor_lang::Event::data(
            &leaf.to_event(),
        )]);
    };
    authority.num_minted = authority.num_minted.saturating_add(1);
    append_leaf(
        &merkle_slab.key(),
        authority_bump,
        &gummyroll_program.to_account_info(),
        &authority.to_account_info(),
        &merkle_slab.to_account_info(),
        &candy_wrapper.to_account_info(),
        leaf.to_node(),
    )
}
fn process_creator_verification<'info>(
    ctx: Context<'_, '_, '_, 'info, CreatorVerification<'info>>,
    root: [u8; 32],
    data_hash: [u8; 32],
    creator_hash: [u8; 32],
    nonce: u64,
    index: u32,
    mut message: MetadataArgs,
    verify: bool,
) -> Result<()> {
    let owner = ctx.accounts.owner.to_account_info();
    let delegate = ctx.accounts.delegate.to_account_info();
    let merkle_slab = ctx.accounts.merkle_slab.to_account_info();
    let creator = ctx.accounts.creator.key();
    if message.creators.is_empty() {
        return Err(BubblegumError::NoCreatorsPresent.into());
    }
    if !message.creators.iter().any(|c| c.address == creator) {
        return Err(BubblegumError::CreatorNotFound.into());
    }
    let provided_creator_data = message
        .creators
        .iter()
        .map(|c| [c.address.as_ref(), &[c.verified as u8], &[c.share]].concat())
        .collect::<Vec<_>>();
    let calculated_creator_hash = keccak::hashv(
        provided_creator_data
            .iter()
            .map(|c| c.as_slice())
            .collect::<Vec<&[u8]>>()
            .as_ref(),
    );
    match (&creator_hash, &calculated_creator_hash.to_bytes()) {
        (left_val, right_val) => {
            if !(*left_val == *right_val) {
                let kind = ::core::panicking::AssertKind::Eq;
                ::core::panicking::assert_failed(
                    kind,
                    &*left_val,
                    &*right_val,
                    ::core::option::Option::None,
                );
            }
        }
    };
    let updated_creator_vec = message
        .creators
        .iter()
        .map(|c| {
            let verified = if c.address == creator.key() {
                verify
            } else {
                c.verified
            };
            Creator {
                address: c.address,
                verified,
                share: c.share,
            }
        })
        .collect::<Vec<Creator>>();
    message.creators = updated_creator_vec;
    let updated_creator_data = message
        .creators
        .iter()
        .map(|c| [c.address.as_ref(), &[c.verified as u8], &[c.share]].concat())
        .collect::<Vec<_>>();
    let updated_creator_hash = keccak::hashv(
        updated_creator_data
            .iter()
            .map(|c| c.as_slice())
            .collect::<Vec<&[u8]>>()
            .as_ref(),
    );
    let metadata_args_hash = keccak::hashv(&[message.try_to_vec()?.as_slice()]);
    let updated_data_hash = keccak::hashv(&[
        &metadata_args_hash.to_bytes(),
        &message.seller_fee_basis_points.to_le_bytes(),
    ]);
    let asset_id = get_asset_id(&merkle_slab.key(), nonce);
    let previous_leaf = LeafSchema::new_v0(
        asset_id,
        owner.key(),
        delegate.key(),
        nonce,
        data_hash,
        creator_hash,
    );
    let new_leaf = LeafSchema::new_v0(
        asset_id,
        owner.key(),
        delegate.key(),
        nonce,
        updated_data_hash.to_bytes(),
        updated_creator_hash.to_bytes(),
    );
    {
        anchor_lang::solana_program::log::sol_log_data(&[&anchor_lang::Event::data(
            &new_leaf.to_event(),
        )]);
    };
    replace_leaf(
        &merkle_slab.key(),
        *ctx.bumps.get("authority").unwrap(),
        &ctx.accounts.gummyroll_program.to_account_info(),
        &ctx.accounts.authority.to_account_info(),
        &ctx.accounts.merkle_slab.to_account_info(),
        &ctx.accounts.candy_wrapper.to_account_info(),
        ctx.remaining_accounts,
        root,
        previous_leaf.to_node(),
        new_leaf.to_node(),
        index,
    )
}
use self::bubblegum::*;
/// # Safety
#[no_mangle]
pub unsafe extern "C" fn entrypoint(input: *mut u8) -> u64 {
    let (program_id, accounts, instruction_data) =
        unsafe { ::solana_program::entrypoint::deserialize(input) };
    match entry(&program_id, &accounts, &instruction_data) {
        Ok(()) => ::solana_program::entrypoint::SUCCESS,
        Err(error) => error.into(),
    }
}
/// The Anchor codegen exposes a programming model where a user defines
/// a set of methods inside of a `#[program]` module in a way similar
/// to writing RPC request handlers. The macro then generates a bunch of
/// code wrapping these user defined methods into something that can be
/// executed on Solana.
///
/// These methods fall into one of three categories, each of which
/// can be considered a different "namespace" of the program.
///
/// 1) Global methods - regular methods inside of the `#[program]`.
/// 2) State methods - associated methods inside a `#[state]` struct.
/// 3) Interface methods - methods inside a strait struct's
///    implementation of an `#[interface]` trait.
///
/// Care must be taken by the codegen to prevent collisions between
/// methods in these different namespaces. For this reason, Anchor uses
/// a variant of sighash to perform method dispatch, rather than
/// something like a simple enum variant discriminator.
///
/// The execution flow of the generated code can be roughly outlined:
///
/// * Start program via the entrypoint.
/// * Strip method identifier off the first 8 bytes of the instruction
///   data and invoke the identified method. The method identifier
///   is a variant of sighash. See docs.rs for `anchor_lang` for details.
/// * If the method identifier is an IDL identifier, execute the IDL
///   instructions, which are a special set of hardcoded instructions
///   baked into every Anchor program. Then exit.
/// * Otherwise, the method identifier is for a user defined
///   instruction, i.e., one of the methods in the user defined
///   `#[program]` module. Perform method dispatch, i.e., execute the
///   big match statement mapping method identifier to method handler
///   wrapper.
/// * Run the method handler wrapper. This wraps the code the user
///   actually wrote, deserializing the accounts, constructing the
///   context, invoking the user's code, and finally running the exit
///   routine, which typically persists account changes.
///
/// The `entry` function here, defines the standard entry to a Solana
/// program, where execution begins.
pub fn entry(
    program_id: &Pubkey,
    accounts: &[AccountInfo],
    data: &[u8],
) -> anchor_lang::solana_program::entrypoint::ProgramResult {
    try_entry(program_id, accounts, data).map_err(|e| {
        e.log();
        e.into()
    })
}
fn try_entry(
    program_id: &Pubkey,
    accounts: &[AccountInfo],
    data: &[u8],
) -> anchor_lang::Result<()> {
    if *program_id != ID {
        return Err(anchor_lang::error::ErrorCode::DeclaredProgramIdMismatch.into());
    }
    if data.len() < 8 {
        return Err(anchor_lang::error::ErrorCode::InstructionMissing.into());
    }
    dispatch(program_id, accounts, data)
}
/// Module representing the program.
pub mod program {
    use super::*;
    /// Type representing the program.
    pub struct Bubblegum;
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::clone::Clone for Bubblegum {
        #[inline]
        fn clone(&self) -> Bubblegum {
            match *self {
                Bubblegum => Bubblegum,
            }
        }
    }
    impl anchor_lang::Id for Bubblegum {
        fn id() -> Pubkey {
            ID
        }
    }
}
/// Performs method dispatch.
///
/// Each method in an anchor program is uniquely defined by a namespace
/// and a rust identifier (i.e., the name given to the method). These
/// two pieces can be combined to creater a method identifier,
/// specifically, Anchor uses
///
/// Sha256("<namespace>:<rust-identifier>")[..8],
///
/// where the namespace can be one of three types. 1) "global" for a
/// regular instruction, 2) "state" for a state struct instruction
/// handler and 3) a trait namespace (used in combination with the
/// `#[interface]` attribute), which is defined by the trait name, e..
/// `MyTrait`.
///
/// With this 8 byte identifier, Anchor performs method dispatch,
/// matching the given 8 byte identifier to the associated method
/// handler, which leads to user defined code being eventually invoked.
fn dispatch(program_id: &Pubkey, accounts: &[AccountInfo], data: &[u8]) -> anchor_lang::Result<()> {
    let mut ix_data: &[u8] = data;
    let sighash: [u8; 8] = {
        let mut sighash: [u8; 8] = [0; 8];
        sighash.copy_from_slice(&ix_data[..8]);
        ix_data = &ix_data[8..];
        sighash
    };
    if true {
        if sighash == anchor_lang::idl::IDL_IX_TAG.to_le_bytes() {
            return __private::__idl::__idl_dispatch(program_id, accounts, &ix_data);
        }
    }
    match sighash {
        [165, 83, 136, 142, 89, 202, 47, 220] => {
            __private::__global::create_tree(program_id, accounts, ix_data)
        }
        [120, 51, 89, 77, 2, 133, 224, 130] => {
            __private::__global::create_default_mint_request(program_id, accounts, ix_data)
        }
        [68, 130, 170, 21, 167, 61, 63, 76] => {
            __private::__global::request_mint_authority(program_id, accounts, ix_data)
        }
        [59, 153, 108, 196, 228, 165, 169, 242] => {
            __private::__global::approve_mint_authority_request(program_id, accounts, ix_data)
        }
        [110, 107, 165, 251, 73, 53, 214, 194] => {
            __private::__global::close_mint_request(program_id, accounts, ix_data)
        }
        [253, 118, 66, 37, 190, 49, 154, 102] => {
            __private::__global::set_tree_delegate(program_id, accounts, ix_data)
        }
        [145, 98, 192, 118, 184, 147, 118, 104] => {
            __private::__global::mint_v1(program_id, accounts, ix_data)
        }
        [52, 17, 96, 132, 71, 4, 85, 194] => {
            __private::__global::verify_creator(program_id, accounts, ix_data)
        }
        [107, 178, 57, 39, 105, 115, 112, 152] => {
            __private::__global::unverify_creator(program_id, accounts, ix_data)
        }
        [163, 52, 200, 231, 140, 3, 69, 186] => {
            __private::__global::transfer(program_id, accounts, ix_data)
        }
        [90, 147, 75, 178, 85, 88, 4, 137] => {
            __private::__global::delegate(program_id, accounts, ix_data)
        }
        [116, 110, 29, 56, 107, 219, 42, 93] => {
            __private::__global::burn(program_id, accounts, ix_data)
        }
        [184, 12, 86, 149, 70, 196, 97, 225] => {
            __private::__global::redeem(program_id, accounts, ix_data)
        }
        [111, 76, 232, 50, 39, 175, 48, 242] => {
            __private::__global::cancel_redeem(program_id, accounts, ix_data)
        }
        [54, 85, 76, 70, 228, 250, 164, 81] => {
            __private::__global::decompress_v1(program_id, accounts, ix_data)
        }
        [82, 193, 176, 117, 176, 21, 115, 253] => {
            __private::__global::compress(program_id, accounts, ix_data)
        }
        _ => Err(anchor_lang::error::ErrorCode::InstructionFallbackNotFound.into()),
    }
}
/// Create a private module to not clutter the program's namespace.
/// Defines an entrypoint for each individual instruction handler
/// wrapper.
mod __private {
    use super::*;
    /// __idl mod defines handlers for injected Anchor IDL instructions.
    pub mod __idl {
        use super::*;
        #[inline(never)]
        #[cfg(not(feature = "no-idl"))]
        pub fn __idl_dispatch(
            program_id: &Pubkey,
            accounts: &[AccountInfo],
            idl_ix_data: &[u8],
        ) -> anchor_lang::Result<()> {
            let mut accounts = accounts;
            let mut data: &[u8] = idl_ix_data;
            let ix = anchor_lang::idl::IdlInstruction::deserialize(&mut data)
                .map_err(|_| anchor_lang::error::ErrorCode::InstructionDidNotDeserialize)?;
            match ix {
                anchor_lang::idl::IdlInstruction::Create { data_len } => {
                    let mut bumps = std::collections::BTreeMap::new();
                    let mut reallocs = std::collections::BTreeSet::new();
                    let mut accounts = anchor_lang::idl::IdlCreateAccounts::try_accounts(
                        program_id,
                        &mut accounts,
                        &[],
                        &mut bumps,
                        &mut reallocs,
                    )?;
                    __idl_create_account(program_id, &mut accounts, data_len)?;
                    accounts.exit(program_id)?;
                }
                anchor_lang::idl::IdlInstruction::CreateBuffer => {
                    let mut bumps = std::collections::BTreeMap::new();
                    let mut reallocs = std::collections::BTreeSet::new();
                    let mut accounts = anchor_lang::idl::IdlCreateBuffer::try_accounts(
                        program_id,
                        &mut accounts,
                        &[],
                        &mut bumps,
                        &mut reallocs,
                    )?;
                    __idl_create_buffer(program_id, &mut accounts)?;
                    accounts.exit(program_id)?;
                }
                anchor_lang::idl::IdlInstruction::Write { data } => {
                    let mut bumps = std::collections::BTreeMap::new();
                    let mut reallocs = std::collections::BTreeSet::new();
                    let mut accounts = anchor_lang::idl::IdlAccounts::try_accounts(
                        program_id,
                        &mut accounts,
                        &[],
                        &mut bumps,
                        &mut reallocs,
                    )?;
                    __idl_write(program_id, &mut accounts, data)?;
                    accounts.exit(program_id)?;
                }
                anchor_lang::idl::IdlInstruction::SetAuthority { new_authority } => {
                    let mut bumps = std::collections::BTreeMap::new();
                    let mut reallocs = std::collections::BTreeSet::new();
                    let mut accounts = anchor_lang::idl::IdlAccounts::try_accounts(
                        program_id,
                        &mut accounts,
                        &[],
                        &mut bumps,
                        &mut reallocs,
                    )?;
                    __idl_set_authority(program_id, &mut accounts, new_authority)?;
                    accounts.exit(program_id)?;
                }
                anchor_lang::idl::IdlInstruction::SetBuffer => {
                    let mut bumps = std::collections::BTreeMap::new();
                    let mut reallocs = std::collections::BTreeSet::new();
                    let mut accounts = anchor_lang::idl::IdlSetBuffer::try_accounts(
                        program_id,
                        &mut accounts,
                        &[],
                        &mut bumps,
                        &mut reallocs,
                    )?;
                    __idl_set_buffer(program_id, &mut accounts)?;
                    accounts.exit(program_id)?;
                }
            }
            Ok(())
        }
        #[inline(never)]
        pub fn __idl_create_account(
            program_id: &Pubkey,
            accounts: &mut anchor_lang::idl::IdlCreateAccounts,
            data_len: u64,
        ) -> anchor_lang::Result<()> {
            ::solana_program::log::sol_log("Instruction: IdlCreateAccount");
            if program_id != accounts.program.key {
                return Err(anchor_lang::error::ErrorCode::IdlInstructionInvalidProgram.into());
            }
            let from = accounts.from.key;
            let (base, nonce) = Pubkey::find_program_address(&[], program_id);
            let seed = anchor_lang::idl::IdlAccount::seed();
            let owner = accounts.program.key;
            let to = Pubkey::create_with_seed(&base, seed, owner).unwrap();
            let space = 8 + 32 + 4 + data_len as usize;
            let rent = Rent::get()?;
            let lamports = rent.minimum_balance(space);
            let seeds = &[&[nonce][..]];
            let ix = anchor_lang::solana_program::system_instruction::create_account_with_seed(
                from,
                &to,
                &base,
                seed,
                lamports,
                space as u64,
                owner,
            );
            anchor_lang::solana_program::program::invoke_signed(
                &ix,
                &[
                    accounts.from.clone(),
                    accounts.to.clone(),
                    accounts.base.clone(),
                    accounts.system_program.clone(),
                ],
                &[seeds],
            )?;
            let mut idl_account = {
                let mut account_data = accounts.to.try_borrow_data()?;
                let mut account_data_slice: &[u8] = &account_data;
                anchor_lang::idl::IdlAccount::try_deserialize_unchecked(&mut account_data_slice)?
            };
            idl_account.authority = *accounts.from.key;
            let mut data = accounts.to.try_borrow_mut_data()?;
            let dst: &mut [u8] = &mut data;
            let mut cursor = std::io::Cursor::new(dst);
            idl_account.try_serialize(&mut cursor)?;
            Ok(())
        }
        #[inline(never)]
        pub fn __idl_create_buffer(
            program_id: &Pubkey,
            accounts: &mut anchor_lang::idl::IdlCreateBuffer,
        ) -> anchor_lang::Result<()> {
            ::solana_program::log::sol_log("Instruction: IdlCreateBuffer");
            let mut buffer = &mut accounts.buffer;
            buffer.authority = *accounts.authority.key;
            Ok(())
        }
        #[inline(never)]
        pub fn __idl_write(
            program_id: &Pubkey,
            accounts: &mut anchor_lang::idl::IdlAccounts,
            idl_data: Vec<u8>,
        ) -> anchor_lang::Result<()> {
            ::solana_program::log::sol_log("Instruction: IdlWrite");
            let mut idl = &mut accounts.idl;
            idl.data.extend(idl_data);
            Ok(())
        }
        #[inline(never)]
        pub fn __idl_set_authority(
            program_id: &Pubkey,
            accounts: &mut anchor_lang::idl::IdlAccounts,
            new_authority: Pubkey,
        ) -> anchor_lang::Result<()> {
            ::solana_program::log::sol_log("Instruction: IdlSetAuthority");
            accounts.idl.authority = new_authority;
            Ok(())
        }
        #[inline(never)]
        pub fn __idl_set_buffer(
            program_id: &Pubkey,
            accounts: &mut anchor_lang::idl::IdlSetBuffer,
        ) -> anchor_lang::Result<()> {
            ::solana_program::log::sol_log("Instruction: IdlSetBuffer");
            accounts.idl.data = accounts.buffer.data.clone();
            Ok(())
        }
    }
    /// __state mod defines wrapped handlers for state instructions.
    pub mod __state {
        use super::*;
    }
    /// __interface mod defines wrapped handlers for `#[interface]` trait
    /// implementations.
    pub mod __interface {
        use super::*;
    }
    /// __global mod defines wrapped handlers for global instructions.
    pub mod __global {
        use super::*;
        #[inline(never)]
        pub fn create_tree(
            program_id: &Pubkey,
            accounts: &[AccountInfo],
            ix_data: &[u8],
        ) -> anchor_lang::Result<()> {
            ::solana_program::log::sol_log("Instruction: CreateTree");
            let ix = instruction::CreateTree::deserialize(&mut &ix_data[..])
                .map_err(|_| anchor_lang::error::ErrorCode::InstructionDidNotDeserialize)?;
            let instruction::CreateTree {
                max_depth,
                max_buffer_size,
            } = ix;
            let mut __bumps = std::collections::BTreeMap::new();
            let mut __reallocs = std::collections::BTreeSet::new();
            let mut remaining_accounts: &[AccountInfo] = accounts;
            let mut accounts = CreateTree::try_accounts(
                program_id,
                &mut remaining_accounts,
                ix_data,
                &mut __bumps,
                &mut __reallocs,
            )?;
            let result = bubblegum::create_tree(
                anchor_lang::context::Context::new(
                    program_id,
                    &mut accounts,
                    remaining_accounts,
                    __bumps,
                ),
                max_depth,
                max_buffer_size,
            )?;
            accounts.exit(program_id)
        }
        #[inline(never)]
        pub fn create_default_mint_request(
            program_id: &Pubkey,
            accounts: &[AccountInfo],
            ix_data: &[u8],
        ) -> anchor_lang::Result<()> {
            ::solana_program::log::sol_log("Instruction: CreateDefaultMintRequest");
            let ix = instruction::CreateDefaultMintRequest::deserialize(&mut &ix_data[..])
                .map_err(|_| anchor_lang::error::ErrorCode::InstructionDidNotDeserialize)?;
            let instruction::CreateDefaultMintRequest { mint_capacity } = ix;
            let mut __bumps = std::collections::BTreeMap::new();
            let mut __reallocs = std::collections::BTreeSet::new();
            let mut remaining_accounts: &[AccountInfo] = accounts;
            let mut accounts = SetDefaultMintRequest::try_accounts(
                program_id,
                &mut remaining_accounts,
                ix_data,
                &mut __bumps,
                &mut __reallocs,
            )?;
            let result = bubblegum::create_default_mint_request(
                anchor_lang::context::Context::new(
                    program_id,
                    &mut accounts,
                    remaining_accounts,
                    __bumps,
                ),
                mint_capacity,
            )?;
            accounts.exit(program_id)
        }
        #[inline(never)]
        pub fn request_mint_authority(
            program_id: &Pubkey,
            accounts: &[AccountInfo],
            ix_data: &[u8],
        ) -> anchor_lang::Result<()> {
            ::solana_program::log::sol_log("Instruction: RequestMintAuthority");
            let ix = instruction::RequestMintAuthority::deserialize(&mut &ix_data[..])
                .map_err(|_| anchor_lang::error::ErrorCode::InstructionDidNotDeserialize)?;
            let instruction::RequestMintAuthority { mint_capacity } = ix;
            let mut __bumps = std::collections::BTreeMap::new();
            let mut __reallocs = std::collections::BTreeSet::new();
            let mut remaining_accounts: &[AccountInfo] = accounts;
            let mut accounts = SetMintRequest::try_accounts(
                program_id,
                &mut remaining_accounts,
                ix_data,
                &mut __bumps,
                &mut __reallocs,
            )?;
            let result = bubblegum::request_mint_authority(
                anchor_lang::context::Context::new(
                    program_id,
                    &mut accounts,
                    remaining_accounts,
                    __bumps,
                ),
                mint_capacity,
            )?;
            accounts.exit(program_id)
        }
        #[inline(never)]
        pub fn approve_mint_authority_request(
            program_id: &Pubkey,
            accounts: &[AccountInfo],
            ix_data: &[u8],
        ) -> anchor_lang::Result<()> {
            ::solana_program::log::sol_log("Instruction: ApproveMintAuthorityRequest");
            let ix = instruction::ApproveMintAuthorityRequest::deserialize(&mut &ix_data[..])
                .map_err(|_| anchor_lang::error::ErrorCode::InstructionDidNotDeserialize)?;
            let instruction::ApproveMintAuthorityRequest {
                num_mints_to_approve,
            } = ix;
            let mut __bumps = std::collections::BTreeMap::new();
            let mut __reallocs = std::collections::BTreeSet::new();
            let mut remaining_accounts: &[AccountInfo] = accounts;
            let mut accounts = ApproveMintRequest::try_accounts(
                program_id,
                &mut remaining_accounts,
                ix_data,
                &mut __bumps,
                &mut __reallocs,
            )?;
            let result = bubblegum::approve_mint_authority_request(
                anchor_lang::context::Context::new(
                    program_id,
                    &mut accounts,
                    remaining_accounts,
                    __bumps,
                ),
                num_mints_to_approve,
            )?;
            accounts.exit(program_id)
        }
        #[inline(never)]
        pub fn close_mint_request(
            program_id: &Pubkey,
            accounts: &[AccountInfo],
            ix_data: &[u8],
        ) -> anchor_lang::Result<()> {
            ::solana_program::log::sol_log("Instruction: CloseMintRequest");
            let ix = instruction::CloseMintRequest::deserialize(&mut &ix_data[..])
                .map_err(|_| anchor_lang::error::ErrorCode::InstructionDidNotDeserialize)?;
            let instruction::CloseMintRequest = ix;
            let mut __bumps = std::collections::BTreeMap::new();
            let mut __reallocs = std::collections::BTreeSet::new();
            let mut remaining_accounts: &[AccountInfo] = accounts;
            let mut accounts = CloseMintRequest::try_accounts(
                program_id,
                &mut remaining_accounts,
                ix_data,
                &mut __bumps,
                &mut __reallocs,
            )?;
            let result = bubblegum::close_mint_request(anchor_lang::context::Context::new(
                program_id,
                &mut accounts,
                remaining_accounts,
                __bumps,
            ))?;
            accounts.exit(program_id)
        }
        #[inline(never)]
        pub fn set_tree_delegate(
            program_id: &Pubkey,
            accounts: &[AccountInfo],
            ix_data: &[u8],
        ) -> anchor_lang::Result<()> {
            ::solana_program::log::sol_log("Instruction: SetTreeDelegate");
            let ix = instruction::SetTreeDelegate::deserialize(&mut &ix_data[..])
                .map_err(|_| anchor_lang::error::ErrorCode::InstructionDidNotDeserialize)?;
            let instruction::SetTreeDelegate = ix;
            let mut __bumps = std::collections::BTreeMap::new();
            let mut __reallocs = std::collections::BTreeSet::new();
            let mut remaining_accounts: &[AccountInfo] = accounts;
            let mut accounts = SetTreeDelegate::try_accounts(
                program_id,
                &mut remaining_accounts,
                ix_data,
                &mut __bumps,
                &mut __reallocs,
            )?;
            let result = bubblegum::set_tree_delegate(anchor_lang::context::Context::new(
                program_id,
                &mut accounts,
                remaining_accounts,
                __bumps,
            ))?;
            accounts.exit(program_id)
        }
        #[inline(never)]
        pub fn mint_v1(
            program_id: &Pubkey,
            accounts: &[AccountInfo],
            ix_data: &[u8],
        ) -> anchor_lang::Result<()> {
            ::solana_program::log::sol_log("Instruction: MintV1");
            let ix = instruction::MintV1::deserialize(&mut &ix_data[..])
                .map_err(|_| anchor_lang::error::ErrorCode::InstructionDidNotDeserialize)?;
            let instruction::MintV1 { message } = ix;
            let mut __bumps = std::collections::BTreeMap::new();
            let mut __reallocs = std::collections::BTreeSet::new();
            let mut remaining_accounts: &[AccountInfo] = accounts;
            let mut accounts = MintV1::try_accounts(
                program_id,
                &mut remaining_accounts,
                ix_data,
                &mut __bumps,
                &mut __reallocs,
            )?;
            let result = bubblegum::mint_v1(
                anchor_lang::context::Context::new(
                    program_id,
                    &mut accounts,
                    remaining_accounts,
                    __bumps,
                ),
                message,
            )?;
            accounts.exit(program_id)
        }
        #[inline(never)]
        pub fn verify_creator(
            program_id: &Pubkey,
            accounts: &[AccountInfo],
            ix_data: &[u8],
        ) -> anchor_lang::Result<()> {
            ::solana_program::log::sol_log("Instruction: VerifyCreator");
            let ix = instruction::VerifyCreator::deserialize(&mut &ix_data[..])
                .map_err(|_| anchor_lang::error::ErrorCode::InstructionDidNotDeserialize)?;
            let instruction::VerifyCreator {
                root,
                data_hash,
                creator_hash,
                nonce,
                index,
                message,
            } = ix;
            let mut __bumps = std::collections::BTreeMap::new();
            let mut __reallocs = std::collections::BTreeSet::new();
            let mut remaining_accounts: &[AccountInfo] = accounts;
            let mut accounts = CreatorVerification::try_accounts(
                program_id,
                &mut remaining_accounts,
                ix_data,
                &mut __bumps,
                &mut __reallocs,
            )?;
            let result = bubblegum::verify_creator(
                anchor_lang::context::Context::new(
                    program_id,
                    &mut accounts,
                    remaining_accounts,
                    __bumps,
                ),
                root,
                data_hash,
                creator_hash,
                nonce,
                index,
                message,
            )?;
            accounts.exit(program_id)
        }
        #[inline(never)]
        pub fn unverify_creator(
            program_id: &Pubkey,
            accounts: &[AccountInfo],
            ix_data: &[u8],
        ) -> anchor_lang::Result<()> {
            ::solana_program::log::sol_log("Instruction: UnverifyCreator");
            let ix = instruction::UnverifyCreator::deserialize(&mut &ix_data[..])
                .map_err(|_| anchor_lang::error::ErrorCode::InstructionDidNotDeserialize)?;
            let instruction::UnverifyCreator {
                root,
                data_hash,
                creator_hash,
                nonce,
                index,
                message,
            } = ix;
            let mut __bumps = std::collections::BTreeMap::new();
            let mut __reallocs = std::collections::BTreeSet::new();
            let mut remaining_accounts: &[AccountInfo] = accounts;
            let mut accounts = CreatorVerification::try_accounts(
                program_id,
                &mut remaining_accounts,
                ix_data,
                &mut __bumps,
                &mut __reallocs,
            )?;
            let result = bubblegum::unverify_creator(
                anchor_lang::context::Context::new(
                    program_id,
                    &mut accounts,
                    remaining_accounts,
                    __bumps,
                ),
                root,
                data_hash,
                creator_hash,
                nonce,
                index,
                message,
            )?;
            accounts.exit(program_id)
        }
        #[inline(never)]
        pub fn transfer(
            program_id: &Pubkey,
            accounts: &[AccountInfo],
            ix_data: &[u8],
        ) -> anchor_lang::Result<()> {
            ::solana_program::log::sol_log("Instruction: Transfer");
            let ix = instruction::Transfer::deserialize(&mut &ix_data[..])
                .map_err(|_| anchor_lang::error::ErrorCode::InstructionDidNotDeserialize)?;
            let instruction::Transfer {
                root,
                data_hash,
                creator_hash,
                nonce,
                index,
            } = ix;
            let mut __bumps = std::collections::BTreeMap::new();
            let mut __reallocs = std::collections::BTreeSet::new();
            let mut remaining_accounts: &[AccountInfo] = accounts;
            let mut accounts = Transfer::try_accounts(
                program_id,
                &mut remaining_accounts,
                ix_data,
                &mut __bumps,
                &mut __reallocs,
            )?;
            let result = bubblegum::transfer(
                anchor_lang::context::Context::new(
                    program_id,
                    &mut accounts,
                    remaining_accounts,
                    __bumps,
                ),
                root,
                data_hash,
                creator_hash,
                nonce,
                index,
            )?;
            accounts.exit(program_id)
        }
        #[inline(never)]
        pub fn delegate(
            program_id: &Pubkey,
            accounts: &[AccountInfo],
            ix_data: &[u8],
        ) -> anchor_lang::Result<()> {
            ::solana_program::log::sol_log("Instruction: Delegate");
            let ix = instruction::Delegate::deserialize(&mut &ix_data[..])
                .map_err(|_| anchor_lang::error::ErrorCode::InstructionDidNotDeserialize)?;
            let instruction::Delegate {
                root,
                data_hash,
                creator_hash,
                nonce,
                index,
            } = ix;
            let mut __bumps = std::collections::BTreeMap::new();
            let mut __reallocs = std::collections::BTreeSet::new();
            let mut remaining_accounts: &[AccountInfo] = accounts;
            let mut accounts = Delegate::try_accounts(
                program_id,
                &mut remaining_accounts,
                ix_data,
                &mut __bumps,
                &mut __reallocs,
            )?;
            let result = bubblegum::delegate(
                anchor_lang::context::Context::new(
                    program_id,
                    &mut accounts,
                    remaining_accounts,
                    __bumps,
                ),
                root,
                data_hash,
                creator_hash,
                nonce,
                index,
            )?;
            accounts.exit(program_id)
        }
        #[inline(never)]
        pub fn burn(
            program_id: &Pubkey,
            accounts: &[AccountInfo],
            ix_data: &[u8],
        ) -> anchor_lang::Result<()> {
            ::solana_program::log::sol_log("Instruction: Burn");
            let ix = instruction::Burn::deserialize(&mut &ix_data[..])
                .map_err(|_| anchor_lang::error::ErrorCode::InstructionDidNotDeserialize)?;
            let instruction::Burn {
                root,
                data_hash,
                creator_hash,
                nonce,
                index,
            } = ix;
            let mut __bumps = std::collections::BTreeMap::new();
            let mut __reallocs = std::collections::BTreeSet::new();
            let mut remaining_accounts: &[AccountInfo] = accounts;
            let mut accounts = Burn::try_accounts(
                program_id,
                &mut remaining_accounts,
                ix_data,
                &mut __bumps,
                &mut __reallocs,
            )?;
            let result = bubblegum::burn(
                anchor_lang::context::Context::new(
                    program_id,
                    &mut accounts,
                    remaining_accounts,
                    __bumps,
                ),
                root,
                data_hash,
                creator_hash,
                nonce,
                index,
            )?;
            accounts.exit(program_id)
        }
        #[inline(never)]
        pub fn redeem(
            program_id: &Pubkey,
            accounts: &[AccountInfo],
            ix_data: &[u8],
        ) -> anchor_lang::Result<()> {
            ::solana_program::log::sol_log("Instruction: Redeem");
            let ix = instruction::Redeem::deserialize(&mut &ix_data[..])
                .map_err(|_| anchor_lang::error::ErrorCode::InstructionDidNotDeserialize)?;
            let instruction::Redeem {
                root,
                data_hash,
                creator_hash,
                nonce,
                index,
            } = ix;
            let mut __bumps = std::collections::BTreeMap::new();
            let mut __reallocs = std::collections::BTreeSet::new();
            let mut remaining_accounts: &[AccountInfo] = accounts;
            let mut accounts = Redeem::try_accounts(
                program_id,
                &mut remaining_accounts,
                ix_data,
                &mut __bumps,
                &mut __reallocs,
            )?;
            let result = bubblegum::redeem(
                anchor_lang::context::Context::new(
                    program_id,
                    &mut accounts,
                    remaining_accounts,
                    __bumps,
                ),
                root,
                data_hash,
                creator_hash,
                nonce,
                index,
            )?;
            accounts.exit(program_id)
        }
        #[inline(never)]
        pub fn cancel_redeem(
            program_id: &Pubkey,
            accounts: &[AccountInfo],
            ix_data: &[u8],
        ) -> anchor_lang::Result<()> {
            ::solana_program::log::sol_log("Instruction: CancelRedeem");
            let ix = instruction::CancelRedeem::deserialize(&mut &ix_data[..])
                .map_err(|_| anchor_lang::error::ErrorCode::InstructionDidNotDeserialize)?;
            let instruction::CancelRedeem { root } = ix;
            let mut __bumps = std::collections::BTreeMap::new();
            let mut __reallocs = std::collections::BTreeSet::new();
            let mut remaining_accounts: &[AccountInfo] = accounts;
            let mut accounts = CancelRedeem::try_accounts(
                program_id,
                &mut remaining_accounts,
                ix_data,
                &mut __bumps,
                &mut __reallocs,
            )?;
            let result = bubblegum::cancel_redeem(
                anchor_lang::context::Context::new(
                    program_id,
                    &mut accounts,
                    remaining_accounts,
                    __bumps,
                ),
                root,
            )?;
            accounts.exit(program_id)
        }
        #[inline(never)]
        pub fn decompress_v1(
            program_id: &Pubkey,
            accounts: &[AccountInfo],
            ix_data: &[u8],
        ) -> anchor_lang::Result<()> {
            ::solana_program::log::sol_log("Instruction: DecompressV1");
            let ix = instruction::DecompressV1::deserialize(&mut &ix_data[..])
                .map_err(|_| anchor_lang::error::ErrorCode::InstructionDidNotDeserialize)?;
            let instruction::DecompressV1 { metadata } = ix;
            let mut __bumps = std::collections::BTreeMap::new();
            let mut __reallocs = std::collections::BTreeSet::new();
            let mut remaining_accounts: &[AccountInfo] = accounts;
            let mut accounts = DecompressV1::try_accounts(
                program_id,
                &mut remaining_accounts,
                ix_data,
                &mut __bumps,
                &mut __reallocs,
            )?;
            let result = bubblegum::decompress_v1(
                anchor_lang::context::Context::new(
                    program_id,
                    &mut accounts,
                    remaining_accounts,
                    __bumps,
                ),
                metadata,
            )?;
            accounts.exit(program_id)
        }
        #[inline(never)]
        pub fn compress(
            program_id: &Pubkey,
            accounts: &[AccountInfo],
            ix_data: &[u8],
        ) -> anchor_lang::Result<()> {
            ::solana_program::log::sol_log("Instruction: Compress");
            let ix = instruction::Compress::deserialize(&mut &ix_data[..])
                .map_err(|_| anchor_lang::error::ErrorCode::InstructionDidNotDeserialize)?;
            let instruction::Compress = ix;
            let mut __bumps = std::collections::BTreeMap::new();
            let mut __reallocs = std::collections::BTreeSet::new();
            let mut remaining_accounts: &[AccountInfo] = accounts;
            let mut accounts = Compress::try_accounts(
                program_id,
                &mut remaining_accounts,
                ix_data,
                &mut __bumps,
                &mut __reallocs,
            )?;
            let result = bubblegum::compress(anchor_lang::context::Context::new(
                program_id,
                &mut accounts,
                remaining_accounts,
                __bumps,
            ))?;
            accounts.exit(program_id)
        }
    }
}
pub mod bubblegum {
    use super::*;
    pub fn create_tree(
        ctx: Context<CreateTree>,
        max_depth: u32,
        max_buffer_size: u32,
    ) -> Result<()> {
        let merkle_slab = ctx.accounts.merkle_slab.to_account_info();
        let seed = merkle_slab.key();
        let seeds = &[seed.as_ref(), &[*ctx.bumps.get("authority").unwrap()]];
        let authority = &mut ctx.accounts.authority;
        authority.set_inner(TreeConfig {
            creator: ctx.accounts.tree_creator.key(),
            delegate: ctx.accounts.tree_creator.key(),
            total_mint_capacity: 1 << max_depth,
            num_mints_approved: 0,
            num_minted: 0,
        });
        let authority_pda_signer = &[&seeds[..]];
        let cpi_ctx = CpiContext::new_with_signer(
            ctx.accounts.gummyroll_program.to_account_info(),
            spl_compression::cpi::accounts::Initialize {
                authority: ctx.accounts.authority.to_account_info(),
                merkle_tree: merkle_slab,
                log_wrapper: ctx.accounts.candy_wrapper.to_account_info(),
            },
            authority_pda_signer,
        );
        spl_compression::cpi::init_empty_merkle_tree(cpi_ctx, max_depth, max_buffer_size)
    }
    /// Creates a special mint request the tree_authority PDA. This allows permissionless minting without
    /// requiring a higher level CPI
    pub fn create_default_mint_request(
        ctx: Context<SetDefaultMintRequest>,
        mint_capacity: u64,
    ) -> Result<()> {
        let request = &mut ctx.accounts.mint_authority_request;
        assert_enough_mints_to_approve(&ctx.accounts.tree_authority, mint_capacity)?;
        request.init_or_set(ctx.accounts.tree_authority.key(), mint_capacity);
        Ok(())
    }
    pub fn request_mint_authority(ctx: Context<SetMintRequest>, mint_capacity: u64) -> Result<()> {
        let request = &mut ctx.accounts.mint_authority_request;
        assert_enough_mints_to_approve(&ctx.accounts.tree_authority, mint_capacity)?;
        request.init_or_set(ctx.accounts.mint_authority.key(), mint_capacity);
        Ok(())
    }
    pub fn approve_mint_authority_request(
        ctx: Context<ApproveMintRequest>,
        num_mints_to_approve: u64,
    ) -> Result<()> {
        let authority = &mut ctx.accounts.tree_authority;
        let request = &mut ctx.accounts.mint_authority_request;
        assert_enough_mints_to_approve(&authority, num_mints_to_approve)?;
        authority.approve_mint_capacity(num_mints_to_approve);
        request.approve(num_mints_to_approve)?;
        Ok(())
    }
    pub fn close_mint_request(ctx: Context<CloseMintRequest>) -> Result<()> {
        let authority = &mut ctx.accounts.tree_authority;
        let request = &ctx.accounts.mint_authority_request;
        authority.restore_mint_capacity(request.num_mints_approved);
        Ok(())
    }
    pub fn set_tree_delegate(ctx: Context<SetTreeDelegate>) -> Result<()> {
        ctx.accounts.tree_authority.delegate = ctx.accounts.new_delegate.key();
        Ok(())
    }
    pub fn mint_v1(ctx: Context<MintV1>, message: MetadataArgs) -> Result<()> {
        let owner = ctx.accounts.owner.key();
        let delegate = ctx.accounts.delegate.key();
        let mint_authority = &mut ctx.accounts.mint_authority;
        let merkle_slab = &ctx.accounts.merkle_slab;
        let mut metadata_auth = HashSet::<Pubkey>::new();
        if mint_authority.key() != ctx.accounts.authority.key() {
            if !mint_authority.is_signer {
                ::core::panicking::panic("assertion failed: mint_authority.is_signer")
            };
            metadata_auth.insert(mint_authority.key());
        }
        metadata_auth.extend(
            ctx.remaining_accounts
                .iter()
                .filter(|a| a.is_signer)
                .map(|a| a.key()),
        );
        let authority = &mut ctx.accounts.authority;
        let request = &mut ctx.accounts.mint_authority_request;
        request.decrement_approvals()?;
        process_mint_v1(
            message,
            owner,
            delegate,
            metadata_auth,
            *ctx.bumps.get("authority").unwrap(),
            authority,
            merkle_slab,
            &ctx.accounts.candy_wrapper,
            &ctx.accounts.gummyroll_program,
        )?;
        if request.num_mints_approved == 0 && request.num_mints_requested == 0 {
            let request_info = request.to_account_info();
            **mint_authority.lamports.borrow_mut() = mint_authority
                .lamports()
                .checked_add(request_info.lamports())
                .ok_or(BubblegumError::CloseMintRequestError)?;
            **request_info.lamports.borrow_mut() = 0;
        }
        Ok(())
    }
    pub fn verify_creator<'info>(
        ctx: Context<'_, '_, '_, 'info, CreatorVerification<'info>>,
        root: [u8; 32],
        data_hash: [u8; 32],
        creator_hash: [u8; 32],
        nonce: u64,
        index: u32,
        message: MetadataArgs,
    ) -> Result<()> {
        process_creator_verification(
            ctx,
            root,
            data_hash,
            creator_hash,
            nonce,
            index,
            message,
            true,
        )
    }
    pub fn unverify_creator<'info>(
        ctx: Context<'_, '_, '_, 'info, CreatorVerification<'info>>,
        root: [u8; 32],
        data_hash: [u8; 32],
        creator_hash: [u8; 32],
        nonce: u64,
        index: u32,
        message: MetadataArgs,
    ) -> Result<()> {
        process_creator_verification(
            ctx,
            root,
            data_hash,
            creator_hash,
            nonce,
            index,
            message,
            false,
        )
    }
    pub fn transfer<'info>(
        ctx: Context<'_, '_, '_, 'info, Transfer<'info>>,
        root: [u8; 32],
        data_hash: [u8; 32],
        creator_hash: [u8; 32],
        nonce: u64,
        index: u32,
    ) -> Result<()> {
        let merkle_slab = ctx.accounts.merkle_slab.to_account_info();
        let owner = ctx.accounts.owner.to_account_info();
        let delegate = ctx.accounts.delegate.to_account_info();
        if !(owner.is_signer || delegate.is_signer) {
            ::core::panicking::panic("assertion failed: owner.is_signer || delegate.is_signer")
        };
        let new_owner = ctx.accounts.new_owner.key();
        let asset_id = get_asset_id(&merkle_slab.key(), nonce);
        let previous_leaf = LeafSchema::new_v0(
            asset_id,
            owner.key(),
            delegate.key(),
            nonce,
            data_hash,
            creator_hash,
        );
        let new_leaf = LeafSchema::new_v0(
            asset_id,
            new_owner,
            new_owner,
            nonce,
            data_hash,
            creator_hash,
        );
        {
            anchor_lang::solana_program::log::sol_log_data(&[&anchor_lang::Event::data(
                &new_leaf.to_event(),
            )]);
        };
        replace_leaf(
            &merkle_slab.key(),
            *ctx.bumps.get("authority").unwrap(),
            &ctx.accounts.gummyroll_program.to_account_info(),
            &ctx.accounts.authority.to_account_info(),
            &ctx.accounts.merkle_slab.to_account_info(),
            &ctx.accounts.candy_wrapper.to_account_info(),
            ctx.remaining_accounts,
            root,
            previous_leaf.to_node(),
            new_leaf.to_node(),
            index,
        )
    }
    pub fn delegate<'info>(
        ctx: Context<'_, '_, '_, 'info, Delegate<'info>>,
        root: [u8; 32],
        data_hash: [u8; 32],
        creator_hash: [u8; 32],
        nonce: u64,
        index: u32,
    ) -> Result<()> {
        let merkle_slab = ctx.accounts.merkle_slab.to_account_info();
        let owner = ctx.accounts.owner.key();
        let previous_delegate = ctx.accounts.previous_delegate.key();
        let new_delegate = ctx.accounts.new_delegate.key();
        let asset_id = get_asset_id(&merkle_slab.key(), nonce);
        let previous_leaf = LeafSchema::new_v0(
            asset_id,
            owner,
            previous_delegate,
            nonce,
            data_hash,
            creator_hash,
        );
        let new_leaf = LeafSchema::new_v0(
            asset_id,
            owner,
            new_delegate,
            nonce,
            data_hash,
            creator_hash,
        );
        wrap_event(new_leaf.try_to_vec()?, &ctx.accounts.candy_wrapper)?;
        {
            anchor_lang::solana_program::log::sol_log_data(&[&anchor_lang::Event::data(
                &new_leaf.to_event(),
            )]);
        };
        replace_leaf(
            &merkle_slab.key(),
            *ctx.bumps.get("authority").unwrap(),
            &ctx.accounts.gummyroll_program.to_account_info(),
            &ctx.accounts.authority.to_account_info(),
            &ctx.accounts.merkle_slab.to_account_info(),
            &ctx.accounts.candy_wrapper.to_account_info(),
            ctx.remaining_accounts,
            root,
            previous_leaf.to_node(),
            new_leaf.to_node(),
            index,
        )
    }
    pub fn burn<'info>(
        ctx: Context<'_, '_, '_, 'info, Burn<'info>>,
        root: [u8; 32],
        data_hash: [u8; 32],
        creator_hash: [u8; 32],
        nonce: u64,
        index: u32,
    ) -> Result<()> {
        let owner = ctx.accounts.owner.to_account_info();
        let delegate = ctx.accounts.delegate.to_account_info();
        if !(owner.is_signer || delegate.is_signer) {
            ::core::panicking::panic("assertion failed: owner.is_signer || delegate.is_signer")
        };
        let merkle_slab = ctx.accounts.merkle_slab.to_account_info();
        let asset_id = get_asset_id(&merkle_slab.key(), nonce);
        let previous_leaf = LeafSchema::new_v0(
            asset_id,
            owner.key(),
            delegate.key(),
            nonce,
            data_hash,
            creator_hash,
        );
        {
            anchor_lang::solana_program::log::sol_log_data(&[&anchor_lang::Event::data(
                &previous_leaf.to_event(),
            )]);
        };
        let new_leaf = Node::default();
        wrap_event(new_leaf.try_to_vec()?, &ctx.accounts.candy_wrapper)?;
        replace_leaf(
            &merkle_slab.key(),
            *ctx.bumps.get("authority").unwrap(),
            &ctx.accounts.gummyroll_program.to_account_info(),
            &ctx.accounts.authority.to_account_info(),
            &ctx.accounts.merkle_slab.to_account_info(),
            &ctx.accounts.candy_wrapper.to_account_info(),
            ctx.remaining_accounts,
            root,
            previous_leaf.to_node(),
            new_leaf,
            index,
        )
    }
    pub fn redeem<'info>(
        ctx: Context<'_, '_, '_, 'info, Redeem<'info>>,
        root: [u8; 32],
        data_hash: [u8; 32],
        creator_hash: [u8; 32],
        nonce: u64,
        index: u32,
    ) -> Result<()> {
        let owner = ctx.accounts.owner.key();
        let delegate = ctx.accounts.delegate.key();
        let merkle_slab = ctx.accounts.merkle_slab.to_account_info();
        let asset_id = get_asset_id(&merkle_slab.key(), nonce);
        let previous_leaf =
            LeafSchema::new_v0(asset_id, owner, delegate, nonce, data_hash, creator_hash);
        {
            anchor_lang::solana_program::log::sol_log_data(&[&anchor_lang::Event::data(
                &previous_leaf.to_event(),
            )]);
        };
        let new_leaf = Node::default();
        wrap_event(new_leaf.try_to_vec()?, &ctx.accounts.candy_wrapper)?;
        replace_leaf(
            &merkle_slab.key(),
            *ctx.bumps.get("authority").unwrap(),
            &ctx.accounts.gummyroll_program.to_account_info(),
            &ctx.accounts.authority.to_account_info(),
            &ctx.accounts.merkle_slab.to_account_info(),
            &ctx.accounts.candy_wrapper.to_account_info(),
            ctx.remaining_accounts,
            root,
            previous_leaf.to_node(),
            new_leaf,
            index,
        )?;
        ctx.accounts
            .voucher
            .set_inner(Voucher::new(previous_leaf, index, merkle_slab.key()));
        Ok(())
    }
    pub fn cancel_redeem<'info>(
        ctx: Context<'_, '_, '_, 'info, CancelRedeem<'info>>,
        root: [u8; 32],
    ) -> Result<()> {
        let voucher = &ctx.accounts.voucher;
        match ctx.accounts.voucher.leaf_schema {
            LeafSchema::V1 { owner, .. } => assert_pubkey_equal(
                &ctx.accounts.owner.key(),
                &owner,
                Some(BubblegumError::AssetOwnerMismatch.into()),
            ),
        }?;
        let merkle_slab = ctx.accounts.merkle_slab.to_account_info();
        {
            anchor_lang::solana_program::log::sol_log_data(&[&anchor_lang::Event::data(
                &voucher.leaf_schema.to_event(),
            )]);
        };
        wrap_event(
            voucher.leaf_schema.try_to_vec()?,
            &ctx.accounts.candy_wrapper,
        )?;
        replace_leaf(
            &merkle_slab.key(),
            *ctx.bumps.get("authority").unwrap(),
            &ctx.accounts.gummyroll_program.to_account_info(),
            &ctx.accounts.authority.to_account_info(),
            &ctx.accounts.merkle_slab.to_account_info(),
            &ctx.accounts.candy_wrapper.to_account_info(),
            ctx.remaining_accounts,
            root,
            [0; 32],
            voucher.leaf_schema.to_node(),
            voucher.index,
        )
    }
    pub fn decompress_v1(ctx: Context<DecompressV1>, metadata: MetadataArgs) -> Result<()> {
        let incoming_data_hash = hash_metadata(&metadata)?;
        let event = match ctx.accounts.voucher.leaf_schema {
            LeafSchema::V1 {
                owner,
                data_hash,
                nonce,
                ..
            } => {
                if !cmp_bytes(&data_hash, &incoming_data_hash, 32) {
                    return Err(BubblegumError::HashingMismatch.into());
                }
                if !cmp_pubkeys(&owner, ctx.accounts.owner.key) {
                    return Err(BubblegumError::AssetOwnerMismatch.into());
                }
                Ok(NFTDecompressionEvent {
                    version: Version::V1,
                    tree_id: ctx.accounts.voucher.merkle_slab.key(),
                    id: get_asset_id(&ctx.accounts.voucher.merkle_slab.key(), nonce),
                    nonce: nonce,
                })
            }
            _ => Err(BubblegumError::UnsupportedSchemaVersion),
        }?;
        let voucher = &ctx.accounts.voucher;
        match metadata.token_program_version {
            TokenProgramVersion::Original => {
                if ctx.accounts.mint.data_is_empty() {
                    invoke_signed(
                        &system_instruction::create_account(
                            &ctx.accounts.owner.key(),
                            &ctx.accounts.mint.key(),
                            Rent::get()?.minimum_balance(SplMint::LEN),
                            SplMint::LEN as u64,
                            &spl_token::id(),
                        ),
                        &[
                            ctx.accounts.owner.to_account_info(),
                            ctx.accounts.mint.to_account_info(),
                            ctx.accounts.system_program.to_account_info(),
                        ],
                        &[&[
                            ASSET_PREFIX.as_bytes(),
                            voucher.merkle_slab.key().as_ref(),
                            voucher.leaf_schema.nonce().to_le_bytes().as_ref(),
                            &[*ctx.bumps.get("mint").unwrap()],
                        ]],
                    )?;
                    invoke(
                        &spl_token::instruction::initialize_mint2(
                            &spl_token::id(),
                            &ctx.accounts.mint.key(),
                            &ctx.accounts.mint_authority.key(),
                            None,
                            0,
                        )?,
                        &[
                            ctx.accounts.token_program.to_account_info(),
                            ctx.accounts.mint.to_account_info(),
                        ],
                    )?;
                }
                if ctx.accounts.token_account.data_is_empty() {
                    invoke(
                        &spl_associated_token_account::instruction::create_associated_token_account(
                            &ctx.accounts.owner.key(),
                            &ctx.accounts.owner.key(),
                            &ctx.accounts.mint.key(),
                        ),
                        &[
                            ctx.accounts.owner.to_account_info(),
                            ctx.accounts.mint.to_account_info(),
                            ctx.accounts.token_account.to_account_info(),
                            ctx.accounts.token_program.to_account_info(),
                            ctx.accounts.associated_token_program.to_account_info(),
                            ctx.accounts.system_program.to_account_info(),
                            ctx.accounts.sysvar_rent.to_account_info(),
                        ],
                    )?;
                }
                invoke_signed(
                    &spl_token::instruction::mint_to(
                        &spl_token::id(),
                        &ctx.accounts.mint.key(),
                        &ctx.accounts.token_account.key(),
                        &ctx.accounts.mint_authority.key(),
                        &[],
                        1,
                    )?,
                    &[
                        ctx.accounts.mint.to_account_info(),
                        ctx.accounts.token_account.to_account_info(),
                        ctx.accounts.mint_authority.to_account_info(),
                        ctx.accounts.token_program.to_account_info(),
                    ],
                    &[&[
                        ctx.accounts.mint.key().as_ref(),
                        &[ctx.bumps["mint_authority"]],
                    ]],
                )?;
            }
            TokenProgramVersion::Token2022 => return Err(ProgramError::InvalidArgument.into()),
        }
        let metadata_infos = <[_]>::into_vec(box [
            ctx.accounts.metadata.to_account_info(),
            ctx.accounts.mint.to_account_info(),
            ctx.accounts.mint_authority.to_account_info(),
            ctx.accounts.owner.to_account_info(),
            ctx.accounts.token_metadata_program.to_account_info(),
            ctx.accounts.token_program.to_account_info(),
            ctx.accounts.system_program.to_account_info(),
            ctx.accounts.sysvar_rent.to_account_info(),
        ]);
        let master_edition_infos = <[_]>::into_vec(box [
            ctx.accounts.master_edition.to_account_info(),
            ctx.accounts.mint.to_account_info(),
            ctx.accounts.mint_authority.to_account_info(),
            ctx.accounts.owner.to_account_info(),
            ctx.accounts.metadata.to_account_info(),
            ctx.accounts.token_metadata_program.to_account_info(),
            ctx.accounts.token_program.to_account_info(),
            ctx.accounts.system_program.to_account_info(),
            ctx.accounts.sysvar_rent.to_account_info(),
        ]);
        ::solana_program::log::sol_log("Creating metadata!");
        invoke_signed(
            &mpl_token_metadata::instruction::create_metadata_accounts_v2(
                ctx.accounts.token_metadata_program.key(),
                ctx.accounts.metadata.key(),
                ctx.accounts.mint.key(),
                ctx.accounts.mint_authority.key(),
                ctx.accounts.owner.key(),
                ctx.accounts.mint_authority.key(),
                metadata.name.clone(),
                metadata.symbol.clone(),
                metadata.uri.clone(),
                if metadata.creators.len() > 0 {
                    let mut amended_metadata_creators = metadata.creators;
                    amended_metadata_creators.push(Creator {
                        address: ctx.accounts.mint_authority.key(),
                        verified: true,
                        share: 0,
                    });
                    Some(
                        amended_metadata_creators
                            .iter()
                            .map(|c| c.adapt())
                            .collect(),
                    )
                } else {
                    None
                },
                metadata.seller_fee_basis_points,
                true,
                metadata.is_mutable,
                match metadata.collection {
                    Some(c) => Some(c.adapt()),
                    None => None,
                },
                match metadata.uses {
                    Some(u) => Some(u.adapt()),
                    None => None,
                },
            ),
            metadata_infos.as_slice(),
            &[&[
                ctx.accounts.mint.key().as_ref(),
                &[ctx.bumps["mint_authority"]],
            ]],
        )?;
        ::solana_program::log::sol_log("Creating master edition!");
        invoke_signed(
            &mpl_token_metadata::instruction::create_master_edition_v3(
                ctx.accounts.token_metadata_program.key(),
                ctx.accounts.master_edition.key(),
                ctx.accounts.mint.key(),
                ctx.accounts.mint_authority.key(),
                ctx.accounts.mint_authority.key(),
                ctx.accounts.metadata.key(),
                ctx.accounts.owner.key(),
                Some(0),
            ),
            master_edition_infos.as_slice(),
            &[&[
                ctx.accounts.mint.key().as_ref(),
                &[ctx.bumps["mint_authority"]],
            ]],
        )?;
        {
            anchor_lang::solana_program::log::sol_log_data(&[&anchor_lang::Event::data(&event)]);
        };
        Ok(())
    }
    pub fn compress(_ctx: Context<Compress>) -> Result<()> {
        Ok(())
    }
}
/// An Anchor generated module containing the program's set of
/// instructions, where each method handler in the `#[program]` mod is
/// associated with a struct defining the input arguments to the
/// method. These should be used directly, when one wants to serialize
/// Anchor instruction data, for example, when speciying
/// instructions on a client.
pub mod instruction {
    use super::*;
    /// Instruction struct definitions for `#[state]` methods.
    pub mod state {
        use super::*;
    }
    /// Instruction.
    pub struct CreateTree {
        pub max_depth: u32,
        pub max_buffer_size: u32,
    }
    impl borsh::ser::BorshSerialize for CreateTree
    where
        u32: borsh::ser::BorshSerialize,
        u32: borsh::ser::BorshSerialize,
    {
        fn serialize<W: borsh::maybestd::io::Write>(
            &self,
            writer: &mut W,
        ) -> ::core::result::Result<(), borsh::maybestd::io::Error> {
            borsh::BorshSerialize::serialize(&self.max_depth, writer)?;
            borsh::BorshSerialize::serialize(&self.max_buffer_size, writer)?;
            Ok(())
        }
    }
    impl borsh::de::BorshDeserialize for CreateTree
    where
        u32: borsh::BorshDeserialize,
        u32: borsh::BorshDeserialize,
    {
        fn deserialize(
            buf: &mut &[u8],
        ) -> ::core::result::Result<Self, borsh::maybestd::io::Error> {
            Ok(Self {
                max_depth: borsh::BorshDeserialize::deserialize(buf)?,
                max_buffer_size: borsh::BorshDeserialize::deserialize(buf)?,
            })
        }
    }
    impl anchor_lang::InstructionData for CreateTree {
        fn data(&self) -> Vec<u8> {
            let mut d = [165, 83, 136, 142, 89, 202, 47, 220].to_vec();
            d.append(&mut self.try_to_vec().expect("Should always serialize"));
            d
        }
    }
    /// Instruction.
    pub struct CreateDefaultMintRequest {
        pub mint_capacity: u64,
    }
    impl borsh::ser::BorshSerialize for CreateDefaultMintRequest
    where
        u64: borsh::ser::BorshSerialize,
    {
        fn serialize<W: borsh::maybestd::io::Write>(
            &self,
            writer: &mut W,
        ) -> ::core::result::Result<(), borsh::maybestd::io::Error> {
            borsh::BorshSerialize::serialize(&self.mint_capacity, writer)?;
            Ok(())
        }
    }
    impl borsh::de::BorshDeserialize for CreateDefaultMintRequest
    where
        u64: borsh::BorshDeserialize,
    {
        fn deserialize(
            buf: &mut &[u8],
        ) -> ::core::result::Result<Self, borsh::maybestd::io::Error> {
            Ok(Self {
                mint_capacity: borsh::BorshDeserialize::deserialize(buf)?,
            })
        }
    }
    impl anchor_lang::InstructionData for CreateDefaultMintRequest {
        fn data(&self) -> Vec<u8> {
            let mut d = [120, 51, 89, 77, 2, 133, 224, 130].to_vec();
            d.append(&mut self.try_to_vec().expect("Should always serialize"));
            d
        }
    }
    /// Instruction.
    pub struct RequestMintAuthority {
        pub mint_capacity: u64,
    }
    impl borsh::ser::BorshSerialize for RequestMintAuthority
    where
        u64: borsh::ser::BorshSerialize,
    {
        fn serialize<W: borsh::maybestd::io::Write>(
            &self,
            writer: &mut W,
        ) -> ::core::result::Result<(), borsh::maybestd::io::Error> {
            borsh::BorshSerialize::serialize(&self.mint_capacity, writer)?;
            Ok(())
        }
    }
    impl borsh::de::BorshDeserialize for RequestMintAuthority
    where
        u64: borsh::BorshDeserialize,
    {
        fn deserialize(
            buf: &mut &[u8],
        ) -> ::core::result::Result<Self, borsh::maybestd::io::Error> {
            Ok(Self {
                mint_capacity: borsh::BorshDeserialize::deserialize(buf)?,
            })
        }
    }
    impl anchor_lang::InstructionData for RequestMintAuthority {
        fn data(&self) -> Vec<u8> {
            let mut d = [68, 130, 170, 21, 167, 61, 63, 76].to_vec();
            d.append(&mut self.try_to_vec().expect("Should always serialize"));
            d
        }
    }
    /// Instruction.
    pub struct ApproveMintAuthorityRequest {
        pub num_mints_to_approve: u64,
    }
    impl borsh::ser::BorshSerialize for ApproveMintAuthorityRequest
    where
        u64: borsh::ser::BorshSerialize,
    {
        fn serialize<W: borsh::maybestd::io::Write>(
            &self,
            writer: &mut W,
        ) -> ::core::result::Result<(), borsh::maybestd::io::Error> {
            borsh::BorshSerialize::serialize(&self.num_mints_to_approve, writer)?;
            Ok(())
        }
    }
    impl borsh::de::BorshDeserialize for ApproveMintAuthorityRequest
    where
        u64: borsh::BorshDeserialize,
    {
        fn deserialize(
            buf: &mut &[u8],
        ) -> ::core::result::Result<Self, borsh::maybestd::io::Error> {
            Ok(Self {
                num_mints_to_approve: borsh::BorshDeserialize::deserialize(buf)?,
            })
        }
    }
    impl anchor_lang::InstructionData for ApproveMintAuthorityRequest {
        fn data(&self) -> Vec<u8> {
            let mut d = [59, 153, 108, 196, 228, 165, 169, 242].to_vec();
            d.append(&mut self.try_to_vec().expect("Should always serialize"));
            d
        }
    }
    /// Instruction.
    pub struct CloseMintRequest;
    impl borsh::ser::BorshSerialize for CloseMintRequest {
        fn serialize<W: borsh::maybestd::io::Write>(
            &self,
            writer: &mut W,
        ) -> ::core::result::Result<(), borsh::maybestd::io::Error> {
            Ok(())
        }
    }
    impl borsh::de::BorshDeserialize for CloseMintRequest {
        fn deserialize(
            buf: &mut &[u8],
        ) -> ::core::result::Result<Self, borsh::maybestd::io::Error> {
            Ok(Self {})
        }
    }
    impl anchor_lang::InstructionData for CloseMintRequest {
        fn data(&self) -> Vec<u8> {
            let mut d = [110, 107, 165, 251, 73, 53, 214, 194].to_vec();
            d.append(&mut self.try_to_vec().expect("Should always serialize"));
            d
        }
    }
    /// Instruction.
    pub struct SetTreeDelegate;
    impl borsh::ser::BorshSerialize for SetTreeDelegate {
        fn serialize<W: borsh::maybestd::io::Write>(
            &self,
            writer: &mut W,
        ) -> ::core::result::Result<(), borsh::maybestd::io::Error> {
            Ok(())
        }
    }
    impl borsh::de::BorshDeserialize for SetTreeDelegate {
        fn deserialize(
            buf: &mut &[u8],
        ) -> ::core::result::Result<Self, borsh::maybestd::io::Error> {
            Ok(Self {})
        }
    }
    impl anchor_lang::InstructionData for SetTreeDelegate {
        fn data(&self) -> Vec<u8> {
            let mut d = [253, 118, 66, 37, 190, 49, 154, 102].to_vec();
            d.append(&mut self.try_to_vec().expect("Should always serialize"));
            d
        }
    }
    /// Instruction.
    pub struct MintV1 {
        pub message: MetadataArgs,
    }
    impl borsh::ser::BorshSerialize for MintV1
    where
        MetadataArgs: borsh::ser::BorshSerialize,
    {
        fn serialize<W: borsh::maybestd::io::Write>(
            &self,
            writer: &mut W,
        ) -> ::core::result::Result<(), borsh::maybestd::io::Error> {
            borsh::BorshSerialize::serialize(&self.message, writer)?;
            Ok(())
        }
    }
    impl borsh::de::BorshDeserialize for MintV1
    where
        MetadataArgs: borsh::BorshDeserialize,
    {
        fn deserialize(
            buf: &mut &[u8],
        ) -> ::core::result::Result<Self, borsh::maybestd::io::Error> {
            Ok(Self {
                message: borsh::BorshDeserialize::deserialize(buf)?,
            })
        }
    }
    impl anchor_lang::InstructionData for MintV1 {
        fn data(&self) -> Vec<u8> {
            let mut d = [145, 98, 192, 118, 184, 147, 118, 104].to_vec();
            d.append(&mut self.try_to_vec().expect("Should always serialize"));
            d
        }
    }
    /// Instruction.
    pub struct VerifyCreator {
        pub root: [u8; 32],
        pub data_hash: [u8; 32],
        pub creator_hash: [u8; 32],
        pub nonce: u64,
        pub index: u32,
        pub message: MetadataArgs,
    }
    impl borsh::ser::BorshSerialize for VerifyCreator
    where
        [u8; 32]: borsh::ser::BorshSerialize,
        [u8; 32]: borsh::ser::BorshSerialize,
        [u8; 32]: borsh::ser::BorshSerialize,
        u64: borsh::ser::BorshSerialize,
        u32: borsh::ser::BorshSerialize,
        MetadataArgs: borsh::ser::BorshSerialize,
    {
        fn serialize<W: borsh::maybestd::io::Write>(
            &self,
            writer: &mut W,
        ) -> ::core::result::Result<(), borsh::maybestd::io::Error> {
            borsh::BorshSerialize::serialize(&self.root, writer)?;
            borsh::BorshSerialize::serialize(&self.data_hash, writer)?;
            borsh::BorshSerialize::serialize(&self.creator_hash, writer)?;
            borsh::BorshSerialize::serialize(&self.nonce, writer)?;
            borsh::BorshSerialize::serialize(&self.index, writer)?;
            borsh::BorshSerialize::serialize(&self.message, writer)?;
            Ok(())
        }
    }
    impl borsh::de::BorshDeserialize for VerifyCreator
    where
        [u8; 32]: borsh::BorshDeserialize,
        [u8; 32]: borsh::BorshDeserialize,
        [u8; 32]: borsh::BorshDeserialize,
        u64: borsh::BorshDeserialize,
        u32: borsh::BorshDeserialize,
        MetadataArgs: borsh::BorshDeserialize,
    {
        fn deserialize(
            buf: &mut &[u8],
        ) -> ::core::result::Result<Self, borsh::maybestd::io::Error> {
            Ok(Self {
                root: borsh::BorshDeserialize::deserialize(buf)?,
                data_hash: borsh::BorshDeserialize::deserialize(buf)?,
                creator_hash: borsh::BorshDeserialize::deserialize(buf)?,
                nonce: borsh::BorshDeserialize::deserialize(buf)?,
                index: borsh::BorshDeserialize::deserialize(buf)?,
                message: borsh::BorshDeserialize::deserialize(buf)?,
            })
        }
    }
    impl anchor_lang::InstructionData for VerifyCreator {
        fn data(&self) -> Vec<u8> {
            let mut d = [52, 17, 96, 132, 71, 4, 85, 194].to_vec();
            d.append(&mut self.try_to_vec().expect("Should always serialize"));
            d
        }
    }
    /// Instruction.
    pub struct UnverifyCreator {
        pub root: [u8; 32],
        pub data_hash: [u8; 32],
        pub creator_hash: [u8; 32],
        pub nonce: u64,
        pub index: u32,
        pub message: MetadataArgs,
    }
    impl borsh::ser::BorshSerialize for UnverifyCreator
    where
        [u8; 32]: borsh::ser::BorshSerialize,
        [u8; 32]: borsh::ser::BorshSerialize,
        [u8; 32]: borsh::ser::BorshSerialize,
        u64: borsh::ser::BorshSerialize,
        u32: borsh::ser::BorshSerialize,
        MetadataArgs: borsh::ser::BorshSerialize,
    {
        fn serialize<W: borsh::maybestd::io::Write>(
            &self,
            writer: &mut W,
        ) -> ::core::result::Result<(), borsh::maybestd::io::Error> {
            borsh::BorshSerialize::serialize(&self.root, writer)?;
            borsh::BorshSerialize::serialize(&self.data_hash, writer)?;
            borsh::BorshSerialize::serialize(&self.creator_hash, writer)?;
            borsh::BorshSerialize::serialize(&self.nonce, writer)?;
            borsh::BorshSerialize::serialize(&self.index, writer)?;
            borsh::BorshSerialize::serialize(&self.message, writer)?;
            Ok(())
        }
    }
    impl borsh::de::BorshDeserialize for UnverifyCreator
    where
        [u8; 32]: borsh::BorshDeserialize,
        [u8; 32]: borsh::BorshDeserialize,
        [u8; 32]: borsh::BorshDeserialize,
        u64: borsh::BorshDeserialize,
        u32: borsh::BorshDeserialize,
        MetadataArgs: borsh::BorshDeserialize,
    {
        fn deserialize(
            buf: &mut &[u8],
        ) -> ::core::result::Result<Self, borsh::maybestd::io::Error> {
            Ok(Self {
                root: borsh::BorshDeserialize::deserialize(buf)?,
                data_hash: borsh::BorshDeserialize::deserialize(buf)?,
                creator_hash: borsh::BorshDeserialize::deserialize(buf)?,
                nonce: borsh::BorshDeserialize::deserialize(buf)?,
                index: borsh::BorshDeserialize::deserialize(buf)?,
                message: borsh::BorshDeserialize::deserialize(buf)?,
            })
        }
    }
    impl anchor_lang::InstructionData for UnverifyCreator {
        fn data(&self) -> Vec<u8> {
            let mut d = [107, 178, 57, 39, 105, 115, 112, 152].to_vec();
            d.append(&mut self.try_to_vec().expect("Should always serialize"));
            d
        }
    }
    /// Instruction.
    pub struct Transfer {
        pub root: [u8; 32],
        pub data_hash: [u8; 32],
        pub creator_hash: [u8; 32],
        pub nonce: u64,
        pub index: u32,
    }
    impl borsh::ser::BorshSerialize for Transfer
    where
        [u8; 32]: borsh::ser::BorshSerialize,
        [u8; 32]: borsh::ser::BorshSerialize,
        [u8; 32]: borsh::ser::BorshSerialize,
        u64: borsh::ser::BorshSerialize,
        u32: borsh::ser::BorshSerialize,
    {
        fn serialize<W: borsh::maybestd::io::Write>(
            &self,
            writer: &mut W,
        ) -> ::core::result::Result<(), borsh::maybestd::io::Error> {
            borsh::BorshSerialize::serialize(&self.root, writer)?;
            borsh::BorshSerialize::serialize(&self.data_hash, writer)?;
            borsh::BorshSerialize::serialize(&self.creator_hash, writer)?;
            borsh::BorshSerialize::serialize(&self.nonce, writer)?;
            borsh::BorshSerialize::serialize(&self.index, writer)?;
            Ok(())
        }
    }
    impl borsh::de::BorshDeserialize for Transfer
    where
        [u8; 32]: borsh::BorshDeserialize,
        [u8; 32]: borsh::BorshDeserialize,
        [u8; 32]: borsh::BorshDeserialize,
        u64: borsh::BorshDeserialize,
        u32: borsh::BorshDeserialize,
    {
        fn deserialize(
            buf: &mut &[u8],
        ) -> ::core::result::Result<Self, borsh::maybestd::io::Error> {
            Ok(Self {
                root: borsh::BorshDeserialize::deserialize(buf)?,
                data_hash: borsh::BorshDeserialize::deserialize(buf)?,
                creator_hash: borsh::BorshDeserialize::deserialize(buf)?,
                nonce: borsh::BorshDeserialize::deserialize(buf)?,
                index: borsh::BorshDeserialize::deserialize(buf)?,
            })
        }
    }
    impl anchor_lang::InstructionData for Transfer {
        fn data(&self) -> Vec<u8> {
            let mut d = [163, 52, 200, 231, 140, 3, 69, 186].to_vec();
            d.append(&mut self.try_to_vec().expect("Should always serialize"));
            d
        }
    }
    /// Instruction.
    pub struct Delegate {
        pub root: [u8; 32],
        pub data_hash: [u8; 32],
        pub creator_hash: [u8; 32],
        pub nonce: u64,
        pub index: u32,
    }
    impl borsh::ser::BorshSerialize for Delegate
    where
        [u8; 32]: borsh::ser::BorshSerialize,
        [u8; 32]: borsh::ser::BorshSerialize,
        [u8; 32]: borsh::ser::BorshSerialize,
        u64: borsh::ser::BorshSerialize,
        u32: borsh::ser::BorshSerialize,
    {
        fn serialize<W: borsh::maybestd::io::Write>(
            &self,
            writer: &mut W,
        ) -> ::core::result::Result<(), borsh::maybestd::io::Error> {
            borsh::BorshSerialize::serialize(&self.root, writer)?;
            borsh::BorshSerialize::serialize(&self.data_hash, writer)?;
            borsh::BorshSerialize::serialize(&self.creator_hash, writer)?;
            borsh::BorshSerialize::serialize(&self.nonce, writer)?;
            borsh::BorshSerialize::serialize(&self.index, writer)?;
            Ok(())
        }
    }
    impl borsh::de::BorshDeserialize for Delegate
    where
        [u8; 32]: borsh::BorshDeserialize,
        [u8; 32]: borsh::BorshDeserialize,
        [u8; 32]: borsh::BorshDeserialize,
        u64: borsh::BorshDeserialize,
        u32: borsh::BorshDeserialize,
    {
        fn deserialize(
            buf: &mut &[u8],
        ) -> ::core::result::Result<Self, borsh::maybestd::io::Error> {
            Ok(Self {
                root: borsh::BorshDeserialize::deserialize(buf)?,
                data_hash: borsh::BorshDeserialize::deserialize(buf)?,
                creator_hash: borsh::BorshDeserialize::deserialize(buf)?,
                nonce: borsh::BorshDeserialize::deserialize(buf)?,
                index: borsh::BorshDeserialize::deserialize(buf)?,
            })
        }
    }
    impl anchor_lang::InstructionData for Delegate {
        fn data(&self) -> Vec<u8> {
            let mut d = [90, 147, 75, 178, 85, 88, 4, 137].to_vec();
            d.append(&mut self.try_to_vec().expect("Should always serialize"));
            d
        }
    }
    /// Instruction.
    pub struct Burn {
        pub root: [u8; 32],
        pub data_hash: [u8; 32],
        pub creator_hash: [u8; 32],
        pub nonce: u64,
        pub index: u32,
    }
    impl borsh::ser::BorshSerialize for Burn
    where
        [u8; 32]: borsh::ser::BorshSerialize,
        [u8; 32]: borsh::ser::BorshSerialize,
        [u8; 32]: borsh::ser::BorshSerialize,
        u64: borsh::ser::BorshSerialize,
        u32: borsh::ser::BorshSerialize,
    {
        fn serialize<W: borsh::maybestd::io::Write>(
            &self,
            writer: &mut W,
        ) -> ::core::result::Result<(), borsh::maybestd::io::Error> {
            borsh::BorshSerialize::serialize(&self.root, writer)?;
            borsh::BorshSerialize::serialize(&self.data_hash, writer)?;
            borsh::BorshSerialize::serialize(&self.creator_hash, writer)?;
            borsh::BorshSerialize::serialize(&self.nonce, writer)?;
            borsh::BorshSerialize::serialize(&self.index, writer)?;
            Ok(())
        }
    }
    impl borsh::de::BorshDeserialize for Burn
    where
        [u8; 32]: borsh::BorshDeserialize,
        [u8; 32]: borsh::BorshDeserialize,
        [u8; 32]: borsh::BorshDeserialize,
        u64: borsh::BorshDeserialize,
        u32: borsh::BorshDeserialize,
    {
        fn deserialize(
            buf: &mut &[u8],
        ) -> ::core::result::Result<Self, borsh::maybestd::io::Error> {
            Ok(Self {
                root: borsh::BorshDeserialize::deserialize(buf)?,
                data_hash: borsh::BorshDeserialize::deserialize(buf)?,
                creator_hash: borsh::BorshDeserialize::deserialize(buf)?,
                nonce: borsh::BorshDeserialize::deserialize(buf)?,
                index: borsh::BorshDeserialize::deserialize(buf)?,
            })
        }
    }
    impl anchor_lang::InstructionData for Burn {
        fn data(&self) -> Vec<u8> {
            let mut d = [116, 110, 29, 56, 107, 219, 42, 93].to_vec();
            d.append(&mut self.try_to_vec().expect("Should always serialize"));
            d
        }
    }
    /// Instruction.
    pub struct Redeem {
        pub root: [u8; 32],
        pub data_hash: [u8; 32],
        pub creator_hash: [u8; 32],
        pub nonce: u64,
        pub index: u32,
    }
    impl borsh::ser::BorshSerialize for Redeem
    where
        [u8; 32]: borsh::ser::BorshSerialize,
        [u8; 32]: borsh::ser::BorshSerialize,
        [u8; 32]: borsh::ser::BorshSerialize,
        u64: borsh::ser::BorshSerialize,
        u32: borsh::ser::BorshSerialize,
    {
        fn serialize<W: borsh::maybestd::io::Write>(
            &self,
            writer: &mut W,
        ) -> ::core::result::Result<(), borsh::maybestd::io::Error> {
            borsh::BorshSerialize::serialize(&self.root, writer)?;
            borsh::BorshSerialize::serialize(&self.data_hash, writer)?;
            borsh::BorshSerialize::serialize(&self.creator_hash, writer)?;
            borsh::BorshSerialize::serialize(&self.nonce, writer)?;
            borsh::BorshSerialize::serialize(&self.index, writer)?;
            Ok(())
        }
    }
    impl borsh::de::BorshDeserialize for Redeem
    where
        [u8; 32]: borsh::BorshDeserialize,
        [u8; 32]: borsh::BorshDeserialize,
        [u8; 32]: borsh::BorshDeserialize,
        u64: borsh::BorshDeserialize,
        u32: borsh::BorshDeserialize,
    {
        fn deserialize(
            buf: &mut &[u8],
        ) -> ::core::result::Result<Self, borsh::maybestd::io::Error> {
            Ok(Self {
                root: borsh::BorshDeserialize::deserialize(buf)?,
                data_hash: borsh::BorshDeserialize::deserialize(buf)?,
                creator_hash: borsh::BorshDeserialize::deserialize(buf)?,
                nonce: borsh::BorshDeserialize::deserialize(buf)?,
                index: borsh::BorshDeserialize::deserialize(buf)?,
            })
        }
    }
    impl anchor_lang::InstructionData for Redeem {
        fn data(&self) -> Vec<u8> {
            let mut d = [184, 12, 86, 149, 70, 196, 97, 225].to_vec();
            d.append(&mut self.try_to_vec().expect("Should always serialize"));
            d
        }
    }
    /// Instruction.
    pub struct CancelRedeem {
        pub root: [u8; 32],
    }
    impl borsh::ser::BorshSerialize for CancelRedeem
    where
        [u8; 32]: borsh::ser::BorshSerialize,
    {
        fn serialize<W: borsh::maybestd::io::Write>(
            &self,
            writer: &mut W,
        ) -> ::core::result::Result<(), borsh::maybestd::io::Error> {
            borsh::BorshSerialize::serialize(&self.root, writer)?;
            Ok(())
        }
    }
    impl borsh::de::BorshDeserialize for CancelRedeem
    where
        [u8; 32]: borsh::BorshDeserialize,
    {
        fn deserialize(
            buf: &mut &[u8],
        ) -> ::core::result::Result<Self, borsh::maybestd::io::Error> {
            Ok(Self {
                root: borsh::BorshDeserialize::deserialize(buf)?,
            })
        }
    }
    impl anchor_lang::InstructionData for CancelRedeem {
        fn data(&self) -> Vec<u8> {
            let mut d = [111, 76, 232, 50, 39, 175, 48, 242].to_vec();
            d.append(&mut self.try_to_vec().expect("Should always serialize"));
            d
        }
    }
    /// Instruction.
    pub struct DecompressV1 {
        pub metadata: MetadataArgs,
    }
    impl borsh::ser::BorshSerialize for DecompressV1
    where
        MetadataArgs: borsh::ser::BorshSerialize,
    {
        fn serialize<W: borsh::maybestd::io::Write>(
            &self,
            writer: &mut W,
        ) -> ::core::result::Result<(), borsh::maybestd::io::Error> {
            borsh::BorshSerialize::serialize(&self.metadata, writer)?;
            Ok(())
        }
    }
    impl borsh::de::BorshDeserialize for DecompressV1
    where
        MetadataArgs: borsh::BorshDeserialize,
    {
        fn deserialize(
            buf: &mut &[u8],
        ) -> ::core::result::Result<Self, borsh::maybestd::io::Error> {
            Ok(Self {
                metadata: borsh::BorshDeserialize::deserialize(buf)?,
            })
        }
    }
    impl anchor_lang::InstructionData for DecompressV1 {
        fn data(&self) -> Vec<u8> {
            let mut d = [54, 85, 76, 70, 228, 250, 164, 81].to_vec();
            d.append(&mut self.try_to_vec().expect("Should always serialize"));
            d
        }
    }
    /// Instruction.
    pub struct Compress;
    impl borsh::ser::BorshSerialize for Compress {
        fn serialize<W: borsh::maybestd::io::Write>(
            &self,
            writer: &mut W,
        ) -> ::core::result::Result<(), borsh::maybestd::io::Error> {
            Ok(())
        }
    }
    impl borsh::de::BorshDeserialize for Compress {
        fn deserialize(
            buf: &mut &[u8],
        ) -> ::core::result::Result<Self, borsh::maybestd::io::Error> {
            Ok(Self {})
        }
    }
    impl anchor_lang::InstructionData for Compress {
        fn data(&self) -> Vec<u8> {
            let mut d = [82, 193, 176, 117, 176, 21, 115, 253].to_vec();
            d.append(&mut self.try_to_vec().expect("Should always serialize"));
            d
        }
    }
}
/// An Anchor generated module, providing a set of structs
/// mirroring the structs deriving `Accounts`, where each field is
/// a `Pubkey`. This is useful for specifying accounts for a client.
pub mod accounts {
    pub use crate::__client_accounts_compress::*;
    pub use crate::__client_accounts_transfer::*;
    pub use crate::__client_accounts_burn::*;
    pub use crate::__client_accounts_set_mint_request::*;
    pub use crate::__client_accounts_mint_v1::*;
    pub use crate::__client_accounts_approve_mint_request::*;
    pub use crate::__client_accounts_creator_verification::*;
    pub use crate::__client_accounts_decompress_v1::*;
    pub use crate::__client_accounts_redeem::*;
    pub use crate::__client_accounts_close_mint_request::*;
    pub use crate::__client_accounts_set_tree_delegate::*;
    pub use crate::__client_accounts_cancel_redeem::*;
    pub use crate::__client_accounts_create_tree::*;
    pub use crate::__client_accounts_delegate::*;
    pub use crate::__client_accounts_set_default_mint_request::*;
}
